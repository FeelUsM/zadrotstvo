//! точки нумеруются с 0
//КП - конструкция пар, например (1,5)(3,4) - задается массивом, где
//  каждая пара отсортирована, первые элементы пар отсортированы
//  есть функция, которая может по заданной КП найти следующую, и таким образом перебрать все КП
//Перестановка 0,1,2,3,4 -> 0,2,3,4,1 - тоже задается массивом

//На вход поступают генераторы группы перестановок (сохраняющей гамильтониан)
//из них генерируются все ее элементы

//выводим Ро:
//(1
    
//Begin
//  наше множество состоит из пар (КП и номер группы в которой она находится)
//  берем самую первую КП и из нее генернируем* Группу КП №1 и добавляем каждый ее элемент с номером 1 в наше множество
//    (* в сгенерированной группе КП может оказаться меньше КП чем в группе перестановок Гамильтониана)
//  последовательно с каждым элементом нашего множества
//    генерируем следующую КП и если она присутствует в нашем множестве - ничего не делаем
//    а если отсустсвует - из нее генерируем группу КП №Next и добавляем каждый ее элемент с номером Next в наше множество
//      (они все должны заранее отсутствовать в нашем множестве)
//  продолжаем так до тех пор, пока следующая КП не будет равна самой первой, т.е. пока в нашем множестве не окажутся все КП
//  в конце сравниваем общее число КП в нашем множестве и по формуле
    
//  выводим Ро:
//  +параметр i-й группы*(сумма всех КП, т.е. напр. d(1,2)*d(3,4)+d(1,4)*d(2,3))
//  +... - по всем группам
//End
// - так повторяем сначала для 1 пары, потом для 2 и т.д.

//выводим Ро:
//)

#include <iostream>
using std::out;
// 
int main(int argc, char * argv[]){
	
}








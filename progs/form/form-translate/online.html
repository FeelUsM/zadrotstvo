<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- saved from url=(0086)#pattern -->
<html data-select-like-a-boss="1"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>online</title>
<meta name="description" content="online">
<meta name="keywords" content="online">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">

<meta name="Generator" content="LaTeX2HTML v2008">
<meta http-equiv="Content-Style-Type" content="text/css">

<link rel="STYLESHEET" href="./online_files/online.css">

<style></style></head>

<body>

<p>
</p><div align="CENTER">
<font size="+4">FORM 
<br><font size="+2">Версия 4.1 
<br><font size="+3">Справочное руководство</font></font></font> 
<br></div>
<p>
</p><div align="CENTER">25-окт-2013 
<br></div>
<p>
</p><div align="CENTER">J.A.M.&nbsp;Vermaseren, J.&nbsp;Kuipers, M.&nbsp;Tentyukov, T.&nbsp;Ueda and J.&nbsp;Vollinga

</div>

<p>
<br>

</p><h2><a name="SECTION00100000000000000000">
одержание</a>
</h2>
<!--Table of Contents-->

<ul>
<li><a name="tex2html342" href="#SECTION00200000000000000000">
Запуск FORM</a>
</li><li><a name="tex2html343" href="#SECTION00300000000000000000">
Переменные</a>
<ul>
<li><a name="tex2html344" href="#SECTION00310000000000000000">
Имена</a>
</li><li><a name="tex2html345" href="#SECTION00320000000000000000">
Символы</a>
</li><li><a name="tex2html346" href="#SECTION00330000000000000000">
Векторы</a>
</li><li><a name="tex2html347" href="#SECTION00340000000000000000">
Индексы</a>
</li><li><a name="tex2html348" href="#SECTION00350000000000000000">
Функции</a>
</li><li><a name="tex2html349" href="#SECTION00360000000000000000">
Множества</a>
</li><li><a name="tex2html350" href="#SECTION00370000000000000000">
Соглашения автообъявлений</a>
</li><li><a name="tex2html351" href="#SECTION00380000000000000000">
Списки имен</a>
</li><li><a name="tex2html352" href="#SECTION00390000000000000000">
Свободные индексы</a>
</li><li><a name="tex2html353" href="#SECTION003100000000000000000">
Дельты Кронекеры</a>
</li><li><a name="tex2html354" href="#SECTION003110000000000000000">
Дополнительные символы</a>
</li><li><a name="tex2html355" href="#SECTION003120000000000000000">
Ограничения</a>
</li><li><a name="tex2html356" href="#SECTION003130000000000000000">
Некоторые распространенные ошибки</a>
</li></ul>
<br>
</li><li><a name="tex2html357" href="#SECTION00400000000000000000">
Препроцессор</a>
<ul>
<li><a name="tex2html358" href="#SECTION00410000000000000000">
Переменные препроцессора</a>
</li><li><a name="tex2html359" href="#SECTION00420000000000000000">
Калькулятор препроцессора</a>
</li><li><a name="tex2html360" href="#SECTION00430000000000000000">
Оператор три точки</a>
</li><li><a name="tex2html361" href="#SECTION00440000000000000000">
#add</a>
</li><li><a name="tex2html362" href="#SECTION00450000000000000000">
#addseparator</a>
</li><li><a name="tex2html363" href="#SECTION00460000000000000000">
#append</a>
</li><li><a name="tex2html364" href="#SECTION00470000000000000000">
#break</a>
</li><li><a name="tex2html365" href="#SECTION00480000000000000000">
#breakdo</a>
</li><li><a name="tex2html366" href="#SECTION00490000000000000000">
#call</a>
</li><li><a name="tex2html367" href="#SECTION004100000000000000000">
#case</a>
</li><li><a name="tex2html368" href="#SECTION004110000000000000000">
#clearoptimize</a>
</li><li><a name="tex2html369" href="#SECTION004120000000000000000">
#close</a>
</li><li><a name="tex2html370" href="#SECTION004130000000000000000">
#closedictionary</a>
</li><li><a name="tex2html371" href="#SECTION004140000000000000000">
#commentchar</a>
</li><li><a name="tex2html372" href="#SECTION004150000000000000000">
#create</a>
</li><li><a name="tex2html373" href="#SECTION004160000000000000000">
#default</a>
</li><li><a name="tex2html374" href="#SECTION004170000000000000000">
#define</a>
</li><li><a name="tex2html375" href="#SECTION004180000000000000000">
#do</a>
</li><li><a name="tex2html376" href="#SECTION004190000000000000000">
#else</a>
</li><li><a name="tex2html377" href="#SECTION004200000000000000000">
#elseif</a>
</li><li><a name="tex2html378" href="#SECTION004210000000000000000">
#enddo</a>
</li><li><a name="tex2html379" href="#SECTION004220000000000000000">
#endif</a>
</li><li><a name="tex2html380" href="#SECTION004230000000000000000">
#endinside</a>
</li><li><a name="tex2html381" href="#SECTION004240000000000000000">
#endprocedure</a>
</li><li><a name="tex2html382" href="#SECTION004250000000000000000">
#endswitch</a>
</li><li><a name="tex2html383" href="#SECTION004260000000000000000">
#exchange</a>
</li><li><a name="tex2html384" href="#SECTION004270000000000000000">
#external</a>
</li><li><a name="tex2html385" href="#SECTION004280000000000000000">
#factdollar</a>
</li><li><a name="tex2html386" href="#SECTION004290000000000000000">
#fromexternal</a>
</li><li><a name="tex2html387" href="#SECTION004300000000000000000">
#if</a>
</li><li><a name="tex2html388" href="#SECTION004310000000000000000">
#ifdef</a>
</li><li><a name="tex2html389" href="#SECTION004320000000000000000">
#ifndef</a>
</li><li><a name="tex2html390" href="#SECTION004330000000000000000">
#include</a>
</li><li><a name="tex2html391" href="#SECTION004340000000000000000">
#inside</a>
</li><li><a name="tex2html392" href="#SECTION004350000000000000000">
#message</a>
</li><li><a name="tex2html393" href="#SECTION004360000000000000000">
#opendictionary</a>
</li><li><a name="tex2html394" href="#SECTION004370000000000000000">
#optimize</a>
</li><li><a name="tex2html395" href="#SECTION004380000000000000000">
#pipe</a>
</li><li><a name="tex2html396" href="#SECTION004390000000000000000">
#preout</a>
</li><li><a name="tex2html397" href="#SECTION004400000000000000000">
#printtimes</a>
</li><li><a name="tex2html398" href="#SECTION004410000000000000000">
#procedure</a>
</li><li><a name="tex2html399" href="#SECTION004420000000000000000">
#procedureextension</a>
</li><li><a name="tex2html400" href="#SECTION004430000000000000000">
#prompt</a>
</li><li><a name="tex2html401" href="#SECTION004440000000000000000">
#redefine</a>
</li><li><a name="tex2html402" href="#SECTION004450000000000000000">
#remove</a>
</li><li><a name="tex2html403" href="#SECTION004460000000000000000">
#reset</a>
</li><li><a name="tex2html404" href="#SECTION004470000000000000000">
#reverseinclude</a>
</li><li><a name="tex2html405" href="#SECTION004480000000000000000">
#rmexternal</a>
</li><li><a name="tex2html406" href="#SECTION004490000000000000000">
#rmseparator</a>
</li><li><a name="tex2html407" href="#SECTION004500000000000000000">
#setexternal</a>
</li><li><a name="tex2html408" href="#SECTION004510000000000000000">
#setexternalattr</a>
</li><li><a name="tex2html409" href="#SECTION004520000000000000000">
#setrandom</a>
</li><li><a name="tex2html410" href="#SECTION004530000000000000000">
#show</a>
</li><li><a name="tex2html411" href="#SECTION004540000000000000000">
#skipextrasymbols</a>
</li><li><a name="tex2html412" href="#SECTION004550000000000000000">
#switch</a>
</li><li><a name="tex2html413" href="#SECTION004560000000000000000">
#system</a>
</li><li><a name="tex2html414" href="#SECTION004570000000000000000">
#terminate</a>
</li><li><a name="tex2html415" href="#SECTION004580000000000000000">
#toexternal</a>
</li><li><a name="tex2html416" href="#SECTION004590000000000000000">
#undefine</a>
</li><li><a name="tex2html417" href="#SECTION004600000000000000000">
#usedictionary</a>
</li><li><a name="tex2html418" href="#SECTION004610000000000000000">
#write</a>
</li><li><a name="tex2html419" href="#SECTION004620000000000000000">
Некоторые замечания</a>
</li></ul>
<br>
</li><li><a name="tex2html420" href="#SECTION00500000000000000000">
Модули</a>
<ul>
<li><a name="tex2html421" href="#SECTION00510000000000000000">
Контрольные точки</a>
</li></ul>
<br>
</li><li><a name="tex2html422" href="#SECTION00600000000000000000">
Сопоставление с образцом</a>
</li><li><a name="tex2html423" href="#SECTION00700000000000000000">
Переменные с долларом</a>
<ul>
<li><a name="tex2html424" href="#SECTION00710000000000000000">
Переменные с долларом в параллельных средах</a>
</li></ul>
<br>
</li><li><a name="tex2html425" href="#SECTION00800000000000000000">
Операторы</a>
<ul>
<li><a name="tex2html426" href="#SECTION00810000000000000000">
abrackets, antibrackets</a>
</li><li><a name="tex2html427" href="#SECTION00820000000000000000">
also</a>
</li><li><a name="tex2html428" href="#SECTION00830000000000000000">
antiputinside</a>
</li><li><a name="tex2html429" href="#SECTION00840000000000000000">
antisymmetrize</a>
</li><li><a name="tex2html430" href="#SECTION00850000000000000000">
apply</a>
</li><li><a name="tex2html431" href="#SECTION00860000000000000000">
argexplode</a>
</li><li><a name="tex2html432" href="#SECTION00870000000000000000">
argimplode</a>
</li><li><a name="tex2html433" href="#SECTION00880000000000000000">
argument</a>
</li><li><a name="tex2html434" href="#SECTION00890000000000000000">
auto, autodeclare</a>
</li><li><a name="tex2html435" href="#SECTION008100000000000000000">
bracket</a>
</li><li><a name="tex2html436" href="#SECTION008110000000000000000">
cfunctions</a>
</li><li><a name="tex2html437" href="#SECTION008120000000000000000">
chainin</a>
</li><li><a name="tex2html438" href="#SECTION008130000000000000000">
chainout</a>
</li><li><a name="tex2html439" href="#SECTION008140000000000000000">
chisholm</a>
</li><li><a name="tex2html440" href="#SECTION008150000000000000000">
cleartable</a>
</li><li><a name="tex2html441" href="#SECTION008160000000000000000">
collect</a>
</li><li><a name="tex2html442" href="#SECTION008170000000000000000">
commuteinset</a>
</li><li><a name="tex2html443" href="#SECTION008180000000000000000">
commuting</a>
</li><li><a name="tex2html444" href="#SECTION008190000000000000000">
compress</a>
</li><li><a name="tex2html445" href="#SECTION008200000000000000000">
contract</a>
</li><li><a name="tex2html446" href="#SECTION008210000000000000000">
ctable</a>
</li><li><a name="tex2html447" href="#SECTION008220000000000000000">
ctensors</a>
</li><li><a name="tex2html448" href="#SECTION008230000000000000000">
cyclesymmetrize</a>
</li><li><a name="tex2html449" href="#SECTION008240000000000000000">
deallocatetable</a>
</li><li><a name="tex2html450" href="#SECTION008250000000000000000">
delete</a>
</li><li><a name="tex2html451" href="#SECTION008260000000000000000">
denominators</a>
</li><li><a name="tex2html452" href="#SECTION008270000000000000000">
dimension</a>
</li><li><a name="tex2html453" href="#SECTION008280000000000000000">
discard</a>
</li><li><a name="tex2html454" href="#SECTION008290000000000000000">
disorder</a>
</li><li><a name="tex2html455" href="#SECTION008300000000000000000">
do</a>
</li><li><a name="tex2html456" href="#SECTION008310000000000000000">
drop</a>
</li><li><a name="tex2html457" href="#SECTION008320000000000000000">
dropcoefficient</a>
</li><li><a name="tex2html458" href="#SECTION008330000000000000000">
dropsymbols</a>
</li><li><a name="tex2html459" href="#SECTION008340000000000000000">
else</a>
</li><li><a name="tex2html460" href="#SECTION008350000000000000000">
elseif</a>
</li><li><a name="tex2html461" href="#SECTION008360000000000000000">
endargument</a>
</li><li><a name="tex2html462" href="#SECTION008370000000000000000">
enddo</a>
</li><li><a name="tex2html463" href="#SECTION008380000000000000000">
endif</a>
</li><li><a name="tex2html464" href="#SECTION008390000000000000000">
endinexpression</a>
</li><li><a name="tex2html465" href="#SECTION008400000000000000000">
endinside</a>
</li><li><a name="tex2html466" href="#SECTION008410000000000000000">
endrepeat</a>
</li><li><a name="tex2html467" href="#SECTION008420000000000000000">
endterm</a>
</li><li><a name="tex2html468" href="#SECTION008430000000000000000">
endwhile</a>
</li><li><a name="tex2html469" href="#SECTION008440000000000000000">
exit</a>
</li><li><a name="tex2html470" href="#SECTION008450000000000000000">
extrasymbols</a>
</li><li><a name="tex2html471" href="#SECTION008460000000000000000">
factarg</a>
</li><li><a name="tex2html472" href="#SECTION008470000000000000000">
factdollar</a>
</li><li><a name="tex2html473" href="#SECTION008480000000000000000">
factorize</a>
</li><li><a name="tex2html474" href="#SECTION008490000000000000000">
fill</a>
</li><li><a name="tex2html475" href="#SECTION008500000000000000000">
fillexpression</a>
</li><li><a name="tex2html476" href="#SECTION008510000000000000000">
fixindex</a>
</li><li><a name="tex2html477" href="#SECTION008520000000000000000">
format</a>
</li><li><a name="tex2html478" href="#SECTION008530000000000000000">
frompolynomial</a>
</li><li><a name="tex2html479" href="#SECTION008540000000000000000">
functions</a>
</li><li><a name="tex2html480" href="#SECTION008550000000000000000">
funpowers</a>
</li><li><a name="tex2html481" href="#SECTION008560000000000000000">
gfactorized</a>
</li><li><a name="tex2html482" href="#SECTION008570000000000000000">
global</a>
</li><li><a name="tex2html483" href="#SECTION008580000000000000000">
goto</a>
</li><li><a name="tex2html484" href="#SECTION008590000000000000000">
hide</a>
</li><li><a name="tex2html485" href="#SECTION008600000000000000000">
identify</a>
</li><li><a name="tex2html486" href="#SECTION008610000000000000000">
idnew</a>
</li><li><a name="tex2html487" href="#SECTION008620000000000000000">
idold</a>
</li><li><a name="tex2html488" href="#SECTION008630000000000000000">
if</a>
</li><li><a name="tex2html489" href="#SECTION008640000000000000000">
ifmatch</a>
</li><li><a name="tex2html490" href="#SECTION008650000000000000000">
ifnomatch</a>
</li><li><a name="tex2html491" href="#SECTION008660000000000000000">
index, indices</a>
</li><li><a name="tex2html492" href="#SECTION008670000000000000000">
inexpression</a>
</li><li><a name="tex2html493" href="#SECTION008680000000000000000">
inparallel</a>
</li><li><a name="tex2html494" href="#SECTION008690000000000000000">
inside</a>
</li><li><a name="tex2html495" href="#SECTION008700000000000000000">
insidefirst</a>
</li><li><a name="tex2html496" href="#SECTION008710000000000000000">
intohide</a>
</li><li><a name="tex2html497" href="#SECTION008720000000000000000">
keep</a>
</li><li><a name="tex2html498" href="#SECTION008730000000000000000">
label</a>
</li><li><a name="tex2html499" href="#SECTION008740000000000000000">
lfactorized</a>
</li><li><a name="tex2html500" href="#SECTION008750000000000000000">
load</a>
</li><li><a name="tex2html501" href="#SECTION008760000000000000000">
local</a>
</li><li><a name="tex2html502" href="#SECTION008770000000000000000">
makeinteger</a>
</li><li><a name="tex2html503" href="#SECTION008780000000000000000">
many</a>
</li><li><a name="tex2html504" href="#SECTION008790000000000000000">
merge</a>
</li><li><a name="tex2html505" href="#SECTION008800000000000000000">
metric</a>
</li><li><a name="tex2html506" href="#SECTION008810000000000000000">
moduleoption</a>
</li><li><a name="tex2html507" href="#SECTION008820000000000000000">
modulus</a>
</li><li><a name="tex2html508" href="#SECTION008830000000000000000">
multi</a>
</li><li><a name="tex2html509" href="#SECTION008840000000000000000">
multiply</a>
</li><li><a name="tex2html510" href="#SECTION008850000000000000000">
ndrop</a>
</li><li><a name="tex2html511" href="#SECTION008860000000000000000">
nfactorize</a>
</li><li><a name="tex2html512" href="#SECTION008870000000000000000">
nfunctions</a>
</li><li><a name="tex2html513" href="#SECTION008880000000000000000">
nhide</a>
</li><li><a name="tex2html514" href="#SECTION008890000000000000000">
normalize</a>
</li><li><a name="tex2html515" href="#SECTION008900000000000000000">
notinparallel</a>
</li><li><a name="tex2html516" href="#SECTION008910000000000000000">
nprint</a>
</li><li><a name="tex2html517" href="#SECTION008920000000000000000">
nskip</a>
</li><li><a name="tex2html518" href="#SECTION008930000000000000000">
ntable</a>
</li><li><a name="tex2html519" href="#SECTION008940000000000000000">
ntensors</a>
</li><li><a name="tex2html520" href="#SECTION008950000000000000000">
nunfactorize</a>
</li><li><a name="tex2html521" href="#SECTION008960000000000000000">
nunhide</a>
</li><li><a name="tex2html522" href="#SECTION008970000000000000000">
nwrite</a>
</li><li><a name="tex2html523" href="#SECTION008980000000000000000">
off</a>
</li><li><a name="tex2html524" href="#SECTION008990000000000000000">
on</a>
</li><li><a name="tex2html525" href="#SECTION0081000000000000000000">
once</a>
</li><li><a name="tex2html526" href="#SECTION0081010000000000000000">
only</a>
</li><li><a name="tex2html527" href="#SECTION0081020000000000000000">
polyfun</a>
</li><li><a name="tex2html528" href="#SECTION0081030000000000000000">
polyratfun</a>
</li><li><a name="tex2html529" href="#SECTION0081040000000000000000">
pophide</a>
</li><li><a name="tex2html530" href="#SECTION0081050000000000000000">
print</a>
</li><li><a name="tex2html531" href="#SECTION0081060000000000000000">
print[]</a>
</li><li><a name="tex2html532" href="#SECTION0081070000000000000000">
printtable</a>
</li><li><a name="tex2html533" href="#SECTION0081080000000000000000">
processbucketsize</a>
</li><li><a name="tex2html534" href="#SECTION0081090000000000000000">
propercount</a>
</li><li><a name="tex2html535" href="#SECTION0081100000000000000000">
pushhide</a>
</li><li><a name="tex2html536" href="#SECTION0081110000000000000000">
putinside</a>
</li><li><a name="tex2html537" href="#SECTION0081120000000000000000">
ratio</a>
</li><li><a name="tex2html538" href="#SECTION0081130000000000000000">
rcyclesymmetrize</a>
</li><li><a name="tex2html539" href="#SECTION0081140000000000000000">
redefine</a>
</li><li><a name="tex2html540" href="#SECTION0081150000000000000000">
renumber</a>
</li><li><a name="tex2html541" href="#SECTION0081160000000000000000">
repeat</a>
</li><li><a name="tex2html542" href="#SECTION0081170000000000000000">
replaceloop</a>
</li><li><a name="tex2html543" href="#SECTION0081180000000000000000">
save</a>
</li><li><a name="tex2html544" href="#SECTION0081190000000000000000">
select</a>
</li><li><a name="tex2html545" href="#SECTION0081200000000000000000">
set</a>
</li><li><a name="tex2html546" href="#SECTION0081210000000000000000">
setexitflag</a>
</li><li><a name="tex2html547" href="#SECTION0081220000000000000000">
shuffle</a>
</li><li><a name="tex2html548" href="#SECTION0081230000000000000000">
skip</a>
</li><li><a name="tex2html549" href="#SECTION0081240000000000000000">
sort</a>
</li><li><a name="tex2html550" href="#SECTION0081250000000000000000">
splitarg</a>
</li><li><a name="tex2html551" href="#SECTION0081260000000000000000">
splitfirstarg</a>
</li><li><a name="tex2html552" href="#SECTION0081270000000000000000">
splitlastarg</a>
</li><li><a name="tex2html553" href="#SECTION0081280000000000000000">
stuffle</a>
</li><li><a name="tex2html554" href="#SECTION0081290000000000000000">
sum</a>
</li><li><a name="tex2html555" href="#SECTION0081300000000000000000">
symbols</a>
</li><li><a name="tex2html556" href="#SECTION0081310000000000000000">
symmetrize</a>
</li><li><a name="tex2html557" href="#SECTION0081320000000000000000">
table</a>
</li><li><a name="tex2html558" href="#SECTION0081330000000000000000">
tablebase</a>
</li><li><a name="tex2html559" href="#SECTION0081340000000000000000">
tensors</a>
</li><li><a name="tex2html560" href="#SECTION0081350000000000000000">
term</a>
</li><li><a name="tex2html561" href="#SECTION0081360000000000000000">
testuse</a>
</li><li><a name="tex2html562" href="#SECTION0081370000000000000000">
threadbucketsize</a>
</li><li><a name="tex2html563" href="#SECTION0081380000000000000000">
topolynomial</a>
</li><li><a name="tex2html564" href="#SECTION0081390000000000000000">
totensor</a>
</li><li><a name="tex2html565" href="#SECTION0081400000000000000000">
tovector</a>
</li><li><a name="tex2html566" href="#SECTION0081410000000000000000">
trace4</a>
</li><li><a name="tex2html567" href="#SECTION0081420000000000000000">
tracen</a>
</li><li><a name="tex2html568" href="#SECTION0081430000000000000000">
transform</a>
</li><li><a name="tex2html569" href="#SECTION0081440000000000000000">
tryreplace</a>
</li><li><a name="tex2html570" href="#SECTION0081450000000000000000">
unfactorize</a>
</li><li><a name="tex2html571" href="#SECTION0081460000000000000000">
unhide</a>
</li><li><a name="tex2html572" href="#SECTION0081470000000000000000">
unittrace</a>
</li><li><a name="tex2html573" href="#SECTION0081480000000000000000">
vectors</a>
</li><li><a name="tex2html574" href="#SECTION0081490000000000000000">
while</a>
</li><li><a name="tex2html575" href="#SECTION0081500000000000000000">write</a>
</li></ul>
<br>
</li><li><a name="tex2html576" href="#SECTION00900000000000000000">
Функции</a>
<ul>
<li><a name="tex2html577" href="#SECTION00910000000000000000">
abs_</a>
</li><li><a name="tex2html578" href="#SECTION00920000000000000000">
bernoulli_</a>
</li><li><a name="tex2html579" href="#SECTION00930000000000000000">
binom_</a>
</li><li><a name="tex2html580" href="#SECTION00940000000000000000">
conjg_</a>
</li><li><a name="tex2html581" href="#SECTION00950000000000000000">
content_</a>
</li><li><a name="tex2html582" href="#SECTION00960000000000000000">
count_</a>
</li><li><a name="tex2html583" href="#SECTION00970000000000000000">
d_</a>
</li><li><a name="tex2html584" href="#SECTION00980000000000000000">
dd_</a>
</li><li><a name="tex2html585" href="#SECTION00990000000000000000">
delta_</a>
</li><li><a name="tex2html586" href="#SECTION009100000000000000000">
deltap_</a>
</li><li><a name="tex2html587" href="#SECTION009110000000000000000">
denom_</a>
</li><li><a name="tex2html588" href="#SECTION009120000000000000000">
distrib_</a>
</li><li><a name="tex2html589" href="#SECTION009130000000000000000">
div_</a>
</li><li><a name="tex2html590" href="#SECTION009140000000000000000">
dum_</a>
</li><li><a name="tex2html591" href="#SECTION009150000000000000000">
dummy_</a>
</li><li><a name="tex2html592" href="#SECTION009160000000000000000">
dummyten_</a>
</li><li><a name="tex2html593" href="#SECTION009170000000000000000">
e_</a>
</li><li><a name="tex2html594" href="#SECTION009180000000000000000">
exp_</a>
</li><li><a name="tex2html595" href="#SECTION009190000000000000000">
exteuclidean_</a>
</li><li><a name="tex2html596" href="#SECTION009200000000000000000">
extrasymbol_</a>
</li><li><a name="tex2html597" href="#SECTION009210000000000000000">
fac_</a>
</li><li><a name="tex2html598" href="#SECTION009220000000000000000">
factorin_</a>
</li><li><a name="tex2html599" href="#SECTION009230000000000000000">
farg_</a>
</li><li><a name="tex2html600" href="#SECTION009240000000000000000">
firstbracket_</a>
</li><li><a name="tex2html601" href="#SECTION009250000000000000000">
firstterm_</a>
</li><li><a name="tex2html602" href="#SECTION009260000000000000000">
g5_</a>
</li><li><a name="tex2html603" href="#SECTION009270000000000000000">
g6_</a>
</li><li><a name="tex2html604" href="#SECTION009280000000000000000">
g7_</a>
</li><li><a name="tex2html605" href="#SECTION009290000000000000000">
g_</a>
</li><li><a name="tex2html606" href="#SECTION009300000000000000000">
gcd_</a>
</li><li><a name="tex2html607" href="#SECTION009310000000000000000">
gi_</a>
</li><li><a name="tex2html608" href="#SECTION009320000000000000000">
id_</a>
</li><li><a name="tex2html609" href="#SECTION009330000000000000000">
integer_</a>
</li><li><a name="tex2html610" href="#SECTION009340000000000000000">
inverse_</a>
</li><li><a name="tex2html611" href="#SECTION009350000000000000000">
invfac_</a>
</li><li><a name="tex2html612" href="#SECTION009360000000000000000">
makerational_</a>
</li><li><a name="tex2html613" href="#SECTION009370000000000000000">
match_</a>
</li><li><a name="tex2html614" href="#SECTION009380000000000000000">
max_</a>
</li><li><a name="tex2html615" href="#SECTION009390000000000000000">
maxpowerof_</a>
</li><li><a name="tex2html616" href="#SECTION009400000000000000000">
min_</a>
</li><li><a name="tex2html617" href="#SECTION009410000000000000000">
minpowerof_</a>
</li><li><a name="tex2html618" href="#SECTION009420000000000000000">
mod_</a>
</li><li><a name="tex2html619" href="#SECTION009430000000000000000">
mod2_</a>
</li><li><a name="tex2html620" href="#SECTION009440000000000000000">
nargs_</a>
</li><li><a name="tex2html621" href="#SECTION009450000000000000000">
nterms_</a>
</li><li><a name="tex2html622" href="#SECTION009460000000000000000">
numfactors_</a>
</li><li><a name="tex2html623" href="#SECTION009470000000000000000">
pattern_</a>
</li><li><a name="tex2html624" href="#SECTION009480000000000000000">
poly_</a>
</li><li><a name="tex2html625" href="#SECTION009490000000000000000">
prime_</a>
</li><li><a name="tex2html626" href="#SECTION009500000000000000000">
random_</a>
</li><li><a name="tex2html627" href="#SECTION009510000000000000000">
ranperm_</a>
</li><li><a name="tex2html628" href="#SECTION009520000000000000000">
rem_</a>
</li><li><a name="tex2html629" href="#SECTION009530000000000000000">
replace_</a>
</li><li><a name="tex2html630" href="#SECTION009540000000000000000">
reverse_</a>
</li><li><a name="tex2html631" href="#SECTION009550000000000000000">
root_</a>
</li><li><a name="tex2html632" href="#SECTION009560000000000000000">
setfun_</a>
</li><li><a name="tex2html633" href="#SECTION009570000000000000000">
sig_</a>
</li><li><a name="tex2html634" href="#SECTION009580000000000000000">
sign_</a>
</li><li><a name="tex2html635" href="#SECTION009590000000000000000">
sum_</a>
</li><li><a name="tex2html636" href="#SECTION009600000000000000000">
sump_</a>
</li><li><a name="tex2html637" href="#SECTION009610000000000000000">
table_</a>
</li><li><a name="tex2html638" href="#SECTION009620000000000000000">
tbl_</a>
</li><li><a name="tex2html639" href="#SECTION009630000000000000000">
term_</a>
</li><li><a name="tex2html640" href="#SECTION009640000000000000000">
termsin_</a>
</li><li><a name="tex2html641" href="#SECTION009650000000000000000">
termsinbracket_</a>
</li><li><a name="tex2html642" href="#SECTION009660000000000000000">
theta_</a>
</li><li><a name="tex2html643" href="#SECTION009670000000000000000">
thetap_</a>
</li><li><a name="tex2html644" href="#SECTION009680000000000000000">
Дополнительные зарезервированные имена</a>
</li></ul>
<br>
</li><li><a name="tex2html645" href="#SECTION001000000000000000000">
Скобки</a>
</li><li><a name="tex2html646" href="#SECTION001100000000000000000">
Многочлены и факторизация</a>
</li><li><a name="tex2html647" href="#SECTION001200000000000000000">
Выходная оптимизация</a>
<ul>
<li><a name="tex2html648" href="#SECTION001201000000000000000">
Опции оптимизации в инструкции Format</a>
</li></ul>
<br>
</li><li><a name="tex2html649" href="#SECTION001300000000000000000">
The TableBase</a>
<ul>
<li><a name="tex2html650" href="#SECTION001310000000000000000">
addto</a>
</li><li><a name="tex2html651" href="#SECTION001320000000000000000">
apply</a>
</li><li><a name="tex2html652" href="#SECTION001330000000000000000">
audit</a>
</li><li><a name="tex2html653" href="#SECTION001340000000000000000">
create</a>
</li><li><a name="tex2html654" href="#SECTION001350000000000000000">
enter</a>
</li><li><a name="tex2html655" href="#SECTION001360000000000000000">
load</a>
</li><li><a name="tex2html656" href="#SECTION001370000000000000000">
off</a>
</li><li><a name="tex2html657" href="#SECTION001380000000000000000">
on</a>
</li><li><a name="tex2html658" href="#SECTION001390000000000000000">
open</a>
</li><li><a name="tex2html659" href="#SECTION0013100000000000000000">
testuse</a>
</li><li><a name="tex2html660" href="#SECTION0013110000000000000000">
use</a>
</li></ul>
<br>
</li><li><a name="tex2html661" href="#SECTION001400000000000000000">
Словари</a>
</li><li><a name="tex2html662" href="#SECTION001500000000000000000">
Алгебра дирака</a>
</li><li><a name="tex2html663" href="#SECTION001600000000000000000">
Несколько замечаний об использовании метрики</a>
<ul>
<li><a name="tex2html664" href="#SECTION001610000000000000000">
Сортировка и статистика</a>
</li></ul>
<br>
</li><li><a name="tex2html665" href="#SECTION001700000000000000000">
Установка</a>
</li><li><a name="tex2html666" href="#SECTION001800000000000000000">
Параллельная версия</a>
<ul>
<li><a name="tex2html667" href="#SECTION001810000000000000000">
TFORM</a>
</li><li><a name="tex2html668" href="#SECTION001820000000000000000">
ParFORM</a>
</li><li><a name="tex2html669" href="#SECTION001830000000000000000">
Некоторые проблемы</a>
</li></ul>
<br>
</li><li><a name="tex2html670" href="#SECTION001900000000000000000">
External communication</a>
<ul>
<li><a name="tex2html671" href="#SECTION001910000000000000000">
#external</a>
</li><li><a name="tex2html672" href="#SECTION001920000000000000000">
#toexternal</a>
</li><li><a name="tex2html673" href="#SECTION001930000000000000000">
#fromexternal</a>
</li><li><a name="tex2html674" href="#SECTION001940000000000000000">
#prompt</a>
</li><li><a name="tex2html675" href="#SECTION001950000000000000000">
#setexternal</a>
</li><li><a name="tex2html676" href="#SECTION001960000000000000000">
#rmexternal</a>
</li><li><a name="tex2html677" href="#SECTION001970000000000000000">
#setexternalattr</a>
</li><li><a name="tex2html678" href="#SECTION001980000000000000000">
An example</a>
</li><li><a name="tex2html679" href="#SECTION001990000000000000000">
Embedding FORM in other applications</a>
</li></ul>
<br>
</li><li><a name="tex2html680" href="#SECTION002000000000000000000">
Index</a>
</li></ul>
<!--End of Table of Contents-->
<p>

</p><h1><a name="SECTION00200000000000000000"></a>
<a name="running"></a>
<br>
Запуск FORM
</h1>

<p>
Правильный способ запуска <a name="111"></a> FORM-а зависит от используемой операционной системы.
Здесь мы будем использовать операционную систему UNIX<a name="112"></a> и ее производные.
Версии компьютеров с операционной системой Windows используют Cygwin<a name="113"></a>,
который также является производным от UNIX а значит он работает аналогичным образом.
Во всех случаях правильный вызов FORM-а это:
</p><pre>     form [options] inputfile
</pre>
Входной файл<a name="116"></a> должен иметь имя, заканчивающееся расширением <code>.frm</code>. 
Тем не менее не обязательно указывать расширение. 
Если это расширение отсутствует, FORM его добавит. Например:
<pre>     form myformprogram
</pre>
и FORM будет искать файл <code>myformprogram.frm</code>. 
Опиции разделяются пробелами и начинаются со знака минус, за которым идет один или более алфавитных символов. 
Вот они:
<dl>
<dt><strong>-c</strong></dt>
<dd>Только проверка на ошибки. 
	Обрабтите внимание, что это не будет работать правильно, 
	если на фазе препроцессинга присутствуют условия,
	которые зависят от результатов, полученных на ранних стадиях программы.
</dd>
<dt><strong>-d</strong></dt>
<dd>Следующий аргумент/опция это переменная препроцессора, которая будет определена до запуска. 
	Ей может быть присвоено определенное значение следующим синтаксисом:
	<tt>-d VARIABLENAME=VALUE</tt>. Значение по умолчанию 1.
</dd>
<dt><strong>-D</strong></dt>
<dd>То же что и -d.
</dd>
<dt><strong>-f</strong></dt>
<dd>Вывод (статистики) идет только в log-файл. /выражение всё равно напечатает в stdout/
</dd>
<dt><strong>-F</strong></dt>
<dd>Вывод (статистики) только в log-файл. Дальше как -L или -ll. /выражение всё равно напечатает в stdout/
</dd>
<dt><strong>-h</strong></dt>
<dd>Wait for some key to be touched before finishing the run.
     Basically only for some old window based systems.
</dd>
<dt><strong>-I</strong></dt>
<dd>Следующий аргумент/опция к директории для include, файлов процедур и подпрограмм.
</dd>
<dt><strong>-l</strong></dt>
<dd>Сделать обычный log-файл.
</dd>
<dt><strong>-ll</strong></dt>
<dd>Создать лог-файл без промежуточной статистики.
</dd>
<dt><strong>-L</strong></dt>
<dd>То же что и -ll.
</dd>
<dt><strong>-M</strong></dt>
<dd>Добавлять PID (идентификатор процесса) в имена временных файлов. 
	Это сделано для более длинных имен, но дает лучшую гарантию уникальности. 
	Если файл с создаваемым именем уже существует, он будет перезаписан. 
	Эта опция используется когда запущены несколько экземпляров FORM-а
	примерно в одно время что может произойти от minos-а или make-а (с опцией make -j).
</dd>
<dt><strong>-p</strong></dt>
<dd>Следующий аргумент/опция это путь к директории для include, входных файлов, файлов процедур и подпрограмм.
</dd>
<dt><strong>-pipe</strong></dt>
<dd>Указывает, что FORM запущен как принимающий конец конвейера. 
	Действие будет настраивать правильные коммуникационные каналы.
</dd>
<dt><strong>-q</strong></dt>
<dd>Опция тишины. Печатаются только выходные выражения.
</dd>
<dt><strong>-R</strong></dt>
<dd>Восстановления после сбоя. См. механизм контрольных точек в
     <a href="#checkpoints">4.1</a>.
</dd>
<dt><strong>-s</strong></dt>
<dd>Следующий аргумент/опция это путь к директории с файлом настроек.
</dd>
<dt><strong>-si</strong></dt>
<dd>То же что и -q.
</dd>
<dt><strong>-S</strong></dt>
<dd>Следующий аргумент/опция это имя файла настроек.
</dd>
<dt><strong>-t</strong></dt>
<dd>Следующий аргумент/опция это путь к директории для временных файлов.
</dd>
<dt><strong>-T</strong></dt>
<dd>Переводит<a name="123"></a> FORM в режим 
	в котором измеряется максимум totalsize и печатается в конце программы. 
	Более детальную информацию см. в инструкции "On TotalSize;
	"<a href="#ontotalsize">7.99</a>.
</dd>
<dt><strong>-v</strong></dt>
<dd>Будет напечатана только версия. После этого программа завершится.
</dd>
<dt><strong>-w</strong></dt>
<dd>За ним сразу должно следовать число. 
	Число показывает количество работающих потоков TFORM. 
	Все остальные версии FORM-а игнорируют этот параметр. 
	Стоит отметить, что TFORM это отдельная программа. 
	Для более детальной информации пожалуйста проконсультируйтесь с главой&nbsp;
	<a href="#parallel">17</a>.
</dd>
<dt><strong>-y</strong></dt>
<dd>Запускает только препроцессор и выводит его вывод.
</dd>
</dl>

<p>
Лог-<a name="127"></a>файл<a name="128"></a> - файл в котором накапливается весь вывод, 
даже если вывод уже появился на экране. 
Это делает аозможным следить за прогрессом программы и иметь окончательную запись всего в одно время. 
Имя лог-файла совпадает с именем программмы без расширения <code>.frm</code> 
но с расширением <code>.log</code>.
Пример:
</p><div align="CENTER">
</div><pre>     form -t /LocalDisk/mydir -l myformprogram
</pre>
<div align="CENTER">
</div>
FORM запустит программу изщ файла <code>myformprogram.frm</code>. 
Ее вывод будет записан и на экран и в файл <code>myformprogram.log</code>. 
Временные файлы (если есть) будут сделаны в дректории <code>/LocalDisk/mydir</code>. 
Эта последняя возможность очень полезна, потому что запись временных файлов через сеть 
иногда может значительно замедлить работу.

<p>
Второй способ передачи параметров в FORM в процессе запуска 
это при помощи переменных среды<a name="133"></a>, подразумевая конечно, что система их поддерживает. 
Поддерживаются следующие переменные:
</p><dl>
<dt><strong>FORMPATH</strong></dt>
<dd><a name="135"></a> 
Директория в которой FORM будет искать процедуры и заголовочные файлы, 
предполагая, что не смог их найти в текущей директории.
</dd>
<dt><strong>FORMTMP</strong></dt>
<dd><a name="136"></a> Директория в которой FORM будет создавать временные файлы<a name="137"></a>.
</dd>
<dt><strong>FORMSETUP</strong></dt>
<dd><a name="138"></a> Полный путь и имя файла настроек<a name="139"></a>.
</dd>
</dl>
Стоит отметить, что что когда параметр задан и в хвосте программы и и в среде 
будет использоваться значение из хвоста комнды.

<p>
Третий способ передать параметры при запуске это с помощью файла настроек<a name="141"></a>. 
Одно из первых, что делает FORM это ищет такой загрузочный файл. 
Вот процедуры, которые следят за этим:

</p><ul>
<li>Если хвост программы задает файл настроек, FORM форм будет использовать этот файл, 
игнорируя все другие указания в пользу файла настроек. 
Это конечно подразумевает, что этот файл существует. 
Если он не существует FORM перейдет к следующей опции.
</li>
<li>Если хвост программы задает путь к файлу натроек, 
FORM будет пытаться открыть файл "form.set" в этой директории. 
Если это не возможно (из-за отсутствия прав или потому что файл не существует) FORM перейдет к следующей опции.
</li>
<li>Далее FORM попытается открыть файл "form.set"<a name="143"></a> в текущей директории.
</li>
<li>Если все остальное не удалось, FORM будет смотреть параметр среды FORMSETUP 
и использовать его значение как имя файла настроек.
</li>
</ul>
Если все перечисленные выше попытки не удались, FORM не будет использоват ь файл настроек. 
Более детальную информацию о файле настроек можно найти в соответствующей главе на стр. 
<a href="#setup">16</a>.

<p>

</p><h1><a name="SECTION00300000000000000000"></a>
<a name="ch-variables"></a>
<br>
Переменные
</h1>

<p>
Объектами символных вычислений являются выражения<a name="181"></a>. 
Строятся из термов<a name="182"></a> и термы состот из переменных. 
FORM знает несколько типов переменных, каждый из которых имеет свои специальные правила. 
Типы переменных есть символы, вектора, индексы, функции, множества, и выражения.
Дополнительно существуют тензора и таблицы которые явлются специальными функциями, 
переменными препроцессора<a name="184"></a> (см. главу&nbsp;<a href="#preprocessor">3</a>),
и существуют переменные с долларом<a name="186"></a> (см. главу&nbsp;<a href="#dollars">6</a>). 
Выражения также используются в определении выражения 
или в правой части выражения или подстановки. 
Когда выражение используется в правой части другого выражения или подстановки, 
оно будет заменено его содержимым при первой возможности. 
Следовательно выражения никогда не встречаются как переменные 
в выводе других выражений и мы будем игнорировать их возможное присутствие в остальной части этой главы. 
Аналогично переменные препроцессора и переменные с долларом будут заменены сразу как встретятся.

</p><p>
Правая часть выражения может содержать символы, вектора, индексы, функции и элементы множеств. 
Все эти объекты должны быть объявлены перед использованием. 
Правила, связанные с каждым типом из этих переменных описываются в разделах ниже.

</p><p>

</p><h1><a name="SECTION00310000000000000000">
Имена</a>
</h1>

<p>
Существует два типа имен<a name="189"></a>. 
Обычные имена<a name="190"></a> состоят из алфавитных и числовых символов 
с условием что первый сивол должен быть алфавитным. 
FORM регистрозависим относительно имен. 
Дополнительно имются <b>формальные имена</b>. 
Эти имена начинаются с символа <code>[</code> соответствующим символом <code>]</code>. 
Между ними могут быть любые символы, которые не интерпретируются препроцессором. 
Это позволяет использщовать переменные такие как <code>[x+a]</code>. 
Использование формальных имен может очень сильно увеличить читабельность программ, 
в то же время давая пользователю преимущества большей скорости. 
Испольщование знаменателей<a name="193"></a> которые являются составными (такие как <code>1/(x+a)</code>) 
обычно достаточно накладно по времени. 
Часто <code>1/[x+a]</code> на столько же читабельно, в то время как приводит к тем же результатам. 
Теме не менне обатите внимание, что переменная <code>[x+a]</code> должна быть объявлена должным образом. 
С другой стороны: FORM может не знать об x и a. 
Эти формальные имена могут также использоваться для имен выражений, 
но они не действительны для имен переменных с долларом и имен переменных препроцессора<a name="195"></a>.

</p><p>
Некоторые имена могут содержать специальные символы. 
Все встроенные объекты имеют последним символом подчеркивание <a name="196"></a> (_). 
Dotproducts<a name="197"></a> (скалярные произведения двух векторов) 
состоят из двух векторов, разделенных точкой или знаком доллара. 
Знак доллара используется FORM-ом, когда вывод программы должен быть совместимым с Fortran-ом<a name="199"></a>. 
Пользователь может заменить знак доллара в выводе любым символом 
определив переменную "DotChar"<a name="200"></a> в файле настроек<a name="201"></a>. 
Как это сделано объясняется в главе&nbsp;<a href="#setup">16</a>. 
Во вводе пользователь также может применить нотацию с точкой или с долларом. 
Тем не менее рекомендуется использовать точку<a name="203"></a> 
потому что в будущих версиях нотация с долларом может быть удалена.  
Перечисленные выше соглашения избегают возможности конфликтов с зарезервированными именами, 
давая пользователям полную свободу в выборе имен. 

</p><p>
Знак доллара также используется как первый символ в именых переменных с долларом<a name="204"></a>. 
Оставшаяся часть имени должна состоять из алфавитноцифровых символов первый из которых должен быть алфавитным. 
Имена переменных препроцессора<a name="205"></a> также должны состоять из алфавитно-цифровых символов
первый из которых должен быть алфавитным. 
А также имена, которые определены системой, имеют завершающий символ подчеркивания<a name="206"></a> (_).

</p><p>
По отношению к пользовательским именам FORM регистрозависим. 
Это означает, что переменные a и A - различные объекты. 
По отношению к системно-определенным объектам FORM регистронезависим. 
Т.е. d_ и D_ обозначают одну и ту же дельту кронекера.

</p><p>
В большинстве языков исвользоывание символа подчеркивания<a name="209"></a> (_) 
также разрешено в определениях пользовательских имен. 
В FORM-е это НЕ так. 
Хотя ранние мануалы `запрещали' это, 
существовал баг в ранних версиях, который разрешал это в некоторых случаях. 
И потому что люди не читают мануалы, были те кто использовал этот символ 
и даже делал этот символ важной частью своих соглашений об именовании. 
Это сломалось, когда была введена версия 3. 
Это должно быть чисто, так что символ подчеркивания зарезервирован 
для совершенно другого типа в будущем использовании и следовательно ничто не может быть так сделано. 
Запомните только: это плохая идея использовать недокументированные возможности 
без предварительных консультаций с группой разработки.

</p><p>
Комплексное сопряжение<a name="211"></a> комплексного числа показывается символом <code>#</code> 
добавленным к имени переменной. 
В текущей версии FORM-а не много сделано с этим. 
Последний подход состоит в том, что это выглядит устаревшим. 
Если возможно, пожалуйста избегайте использования этого.

</p><p>
Длина имен не ограничена <a name="213"></a> в FORM-е. 
Есть однол исключение из этого правила: имена выражений не могут быть длиннее 16 символов. 
Конечно на практике существуют физические ограничения на размер имен, 
задаваемые размером памяти используемого компьютера.

</p><p>

</p><h1><a name="SECTION00320000000000000000">
Символы</a>
</h1>

<p>
<a name="sect-symbols"></a>Символы<a name="217"></a> это простые объекты, 
которые ведут себя в основном как обычные переменные при ручных манипуляциях. 
Многие ручные вычисления касаются полиномиальных формул простых алгебраических переменных. 
FORM подразумевает, что символы коммутируют со всеми другими объектами 
и имеют степень, ассоциированную с ними. 
Эта степень ограничен при установке и зависит от минимума и максимума. 
Степень за пределами этого диапозона приведет к сообщению об ошибке. 
Пользователь может переопределить это встроенное ограничение 
своим собственным дизайном, которое будет более строгим. 
Любая степень, которая выпадет из пользовательского дипозона, 
приведет к удалению терма, который содержит переменную с этой степенью. 
Такое ограничение на степень может быть определено для каждого символа отдельно.

</p><p>
Символы также могут иметь своства комплексного сопряжения<a name="219"></a>. 
Символ может быть определен как действительный, мнимый или комплексный. 
Это свойство имеет смысл только когда используется оператор комплексного сопряжения. 
Этот оператор не реализован и пока не планов его реализхации. 

</p><p>
Синтаксис конструкции, которая объявлет символы, задается так (см. также 
<a href="#substasymbols">7.130</a>): 
</p><pre>     S[ymbols]    name[#{R|I|C}][(min:max)];
</pre>
Каждая переменная задается своим именем. 
Если добавлен символ #, дальше должен следовать символ C, I или R чтобы определить, что переменная является 
комплексной<a name="223"></a>, мнимой<a name="224"></a> или действительной<a name="225"></a>. 
На самом деле #R не является необходимым, т.к. тип `real' является типом по умолчанию. 
Не имеет значения, C, I, R в верхнем или в нижнем регистре. 
Ограничение степени<a name="226"></a> задается дипозоном между обычными скобками. 
Если одно из двух чисел отсутствует, берется значение по умолчанию. 
Это значение по умолчанию зависит от установки, но по крайней мене не меньше диапозона -10000..10000. 
Каждое объявление символов может определять более одной переменной. 
В этом случае переменные разделяются запятыми или пробелами. 
Пример:
<pre>     S    x,y,z,a#c,b#c,c#c,r(-5:5),s(:20),t#i(6:9);
</pre>
В этой конструкции x, y и z являются обычными действительными алгебраическими переменными. 
Переменные a, b и c являются комплексными. 
Это означает, что для каждой из этих переменных в списках свойств зарезервировано две записи: 
одна для переменной и одна для комплексно сопряженной к ней. 
Переменная r имеет ограничения на степень: 
Любая степень за пределами заданного диапозона приведет к тому, что терм, содержащий эту степень, будет исключен. 
Это частично полезно in power series expansions. 
Ограничения на s являются такими, что нет ограничений на минимальную степень s 
-за исключением встроенных ограничений- но термы со степенью s, которая больше чем 20 выкидываются. 
Переменная t - мнимая. 
Это значит, что при комплексном сопряжении она меняет знак. 
Ограничения ее степени достаточно необычны. 
Любая степень за пределами диапозона от 6 до 9 выбрасывается. 
Тем не менее есть одно исключение: это не влияет на термы, которые не содержат t в любой степени
(<img width="17" height="16" align="BOTTOM" border="0" src="./online_files/img1.png" alt="$t^0$">). 
<pre>    s     x(:10),y;
    L     F=y^7;
    id    y=x+x^2;
    print;
    .end

Time =       0.01 sec    Generated terms =          4
                F        Terms in output =          4
                         Bytes used      =         54

   F =
      x^7 + 7*x^8 + 21*x^9 + 35*x^10;
</pre>
Обратите внимание, что все термы со степенью больше 10 даже не будут посчитаны как сгенерированные термы. 
Они перехватываются срзу после замены, 
до того как любые дополнительные конструкции будут применены.

<p>
Есть несколько встроенных символов<a name="231"></a>. Это:

</p><p>
i_<a name="232"></a>: оно определяется как <code>i_^2 = -1</code> 
и это свойство используется FORM-ом для упрощения термов. 
Только этот смвол не может использоваться как размерность или как подстановочный.

</p><p>
pi_<a name="234"></a>: зарезервированная переменная, которая бкдет в итоге использоваться для задания переменной 
<img width="14" height="14" align="BOTTOM" border="0" src="./online_files/img2.png" alt="$\pi$">.

</p><p>
coeff_<a name="235"></a>: эта переменная автоматически заменяется 
коэффициентом текущего терма.

</p><p>
num_<a name="236"></a>: эта переменная автоматически заменяется 
числителем коэффициента текущего терма.

</p><p>
den_<a name="237"></a>: эта переменная автоматически заменяется  
знаменателем коэффициента текущего терма.

</p><p>
extrasymbols_<a name="238"></a>: этот символ представляет 
количество экстра символов (см. <a href="#sect-extrasymbols">2.11</a>).

</p><p>

</p><h1><a name="SECTION00330000000000000000">
Вектора</a>
</h1>

<p>
<a name="sect-vectors"></a>Вектор<a name="242"></a> это объект с одним индексом<a name="243"></a>. 
Этот индекс представляет число, которое показывает, который компонент вектора имеется ввиду. 
Вектора имеют резмерность<a name="244"></a>, связанную с ними, 
которая является размерностью векторного пространства в котором они определены. 
В FORM эта размерность по умолчанию установлена на 4. 
Если пользователь хочет изменить это значение, это может быть сделано при помощи конструкции `Dimension'. 
Использование этой команды влияет на размерность всех векторов и размерность по умолчанию индексов. 
Ее синтаксис: (см. также <a href="#substadimension">7.27</a>):
</p><pre>     Dimension number;
</pre>
или
<pre>     Dimension symbol;
</pre>
number должен быть числом, которое помещается в машинном слове FORM-а размер которого определяется при установке, 
но должен быть по меньшей мере 32767. 
число должно быть положительным или нулем. Отрицательные значения недопустимы. 
Если задан символ(symbol), он должен быть объявлен ранее. 
Может использоваться любой символ за исключением i_<a name="252"></a>. 

<p>
Определение векторов (см. <a href="#substavectors">7.148</a>) достаточно прямолинейно:
</p><pre>     V[ector] name [,MoreNames];
</pre>
Имена векторов могут разделяться запятыми ил пробелами. Пример: 
<pre>     V    p,q;
     I    mu,nu;
     L    F=p(mu)*q(nu);
</pre>

<p>

</p><h1><a name="SECTION00340000000000000000">
Индексы</a>
</h1>

<p>
<a name="sect-indices"></a>Индексы<a name="260"></a><a name="261"></a> 
- объекты, которые представляют чила, которые используются как целые аргументы для подсчета целей. 
Они в основном используются как аргументы векторов или многомерных массивов (или тензоров). 
Их основное свойство в том, что они имеют размерность<a name="262"></a>. 
Эта размерность определяет, какие значения может принимать индекс. 
Четырехмерный индекс обычно может принимать значения от 1 до 4. 
Очень важное свойство индекса заключено в соглашении, что 
подрузумевается суммирование по дважды встречающемуся индексу. 
Это называется соглашение Эйнштейна о <a name="263"></a> суммировании<a name="264"></a>. 
Следовательно терм 
p(mu)<img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img3.png" alt="$*$">q(mu) 
есть эквивалент скалярного произведения векторов p и q (которое также может быть записано как p.q). 

</p><p>
Также существуют индексы, по которым не происходит суммирование. 
Такие индексы мы называем нуль-мерными. 
Это просто соглашение. 
Для объявления индексов мы используем кнструкцию (см. также <a href="#substaindex">7.66</a>): 
</p><pre>     Index name[={number|symbol}]
                   [,othername[={number|symbol}]];
</pre>
Когда используются равенства, это означает задание размерности. 
Индексы, за которыми не идет знак равенства 
получают в качестве размерности текущую размерность по умолчанию (см. также <a href="#substadimension">7.27</a>)). 
Размерность также может быть числом, которое есть ноль или положительное 
(ноль означает, что соглашение о суммировании не применяется для этого индекса), 
или любым символом за исключением символа i_. 
Символ должен быть объявлен ранее. 

<p>
Наиболее вожное применение индекса - это встроенное правило, 
что <a name="269"></a> дельта<a name="270"></a> Кронекера 
с двумя одинаковыми индексами заменяется размерностью этого индекса, 
если этот индекс имеет ненулевукю размерность. 
Следовательно, когда mu - 4-мерный, d_(mu,mu) будет заменен на 4 
и когда nu - n-мерный, d_(nu,nu) будет заменено на n. 
Если rho - нуль-мерный, выражение d_(rho,rho) останется нетронутым.

</p><p>
В дополнение к символьным индексам there is a number of fixed indices<a name="271"></a> 
с числовым<a name="272"></a> значением. 
Значения этих индексов пробегаю от нуля до чила, определяемого при установке (обычно 127). 
Пользователи, которым нравятся другие максимвльные значения, 
должны проконсультироваться с главой&nbsp;<a href="#setup">16</a> о параметрах установки. 
Подразумевается, что все числовые индексы имеют размерность ноль, 
следовательно к ним не применяется суммирование. 
Это означает, что они могут использоваться для компонент вектора. 
Следовательно, абсолютно допустимо использовать:
</p><pre>     V    p,q,r;
     L    F=p(1)*q(1)*r(1)+p(2)*q(2)*r(2);
</pre>
Когда два числовых индекса встречаются в одной дельте Кронекера, 
эта дельта заменяется значением. 
Обычно это значение равно единице, когда два индекса совпадают, 
и нулю, когда они разные. 
Значение для диагональных элементов может быть заменено конструкцией `FixIndex' 
(см. также <a href="#substafixindex">7.51</a>): 
<pre>     Fi[xIndex] number:value [,number:value];
</pre>
Эта команда сопоставляет d_(number,number) заданное value. 
Это value должно умещаться в одном машинном слове FORM-а. 
Это означает, что это значение может находиться по крайней мере в диапозоне -32768 to +32767. 
Более детальную информацию о машинном слове FORM-а следует смотреть в инсталляционном мануале. 

<p>
В случае суммируемых индексов<a name="281"></a> 
использование одного индекса три раза в одном терме вызовет проблему. 
FORM будет выполнять свертку для первой пары, которую он встретил, 
после чего останется третий индекс. 
В случае четырех или более индексов разбиение на свертки 
зависит от порядка, в котором обрабатываются части терма. 
Следовательно для пользователя результат может показаться почти случайным. 
Ничто с этим не может быть сделано и пользователь должен избегать таких неоднозначных нотаций<a name="283"></a>.

</p><p>
Существует специальная версия объявления индексов 
которая используется для следов<a name="284"></a> гамма<a name="285"></a> матриц<a name="286"></a> в n измерениях. 
Если индекс объявлен как
</p><pre>    Symbols n,epsilon;
    Index m=n:epsilon;
</pre>
его размерность бдет n и подразумевается, что epsilon может использоваться для 
<img width="54" height="31" align="MIDDLE" border="0" src="./online_files/img4.png" alt="$(n-4)$"> 
в процессе вычисления следа строки гамма-матриц. 
Также возможно использовать эту нотацию в конструкции dimension. 
См. также главу&nbsp;<a href="#gammaalgebra">14</a> про гамма матрицы.

<p>

</p><h1><a name="SECTION00350000000000000000">
Функции</a>
</h1>

<p>
<a name="sect-functions"></a>Существует два класса функций<a name="292"></a>: 
<b>коммутирующие функции</b> которые автоматически коммутируют со всеми другими объектами, 
и <b>не-коммутирующие функции</b> которые не обязательно коммутируют с другими не-коммутирующими функциями. 
Объект объявляется как коммутирующая <a name="295"></a> функция<a name="296"></a> 
командй `cfunction'. 
Для этой команды обязательны первые два символа, остальные - необязательные. 
объект объявляется как некоммутирующая <a name="297"></a> функция<a name="298"></a> 
командой `function'. 
Здесь обязательно толко f. 
Объявление функции имеет одну опцию. 
Эта опция определяет комплексные свойства функции. 
Она задается # идущей после имени, 
после которой идет один из символов R, I, C, определяющих, что функция является 
действительной<a name="299"></a>, мнимой<a name="300"></a> или комплексной<a name="301"></a>. 
Объявление, что функция действительная - необязательное, т.к. это всойство задается по умолчанию. 
Пример:
</p><pre>     CF   fa,fb,fc;
     F    ga,gb,gc#c;
</pre>
В этом примере функции fa, fb, fc являются коммутирующими 
и функции ga, gb и gc не обязательно коммутируют. 
В дополнение функция gc - комплексная. 
Больше о функциях и их соглашениях изложено в главе&nbsp;<a href="#functions">8</a>.

<p>
В коммутирующем классе также присутствует несколько типов специальных функций. 
На данный момент это тензора<a name="305"></a> и таблицы<a name="306"></a>. 
Таблицы описаны в разделе&nbsp;<a href="#substatable">7.132</a> 
и в главе&nbsp;<a href="#tablebase">12</a>.

</p><p>
Тензора<a name="309"></a> являются специальными функциями. 
Их аргументами могут быть только индексы и вектора. 
Когда аргумент это вектор, подразумевается, 
что этот вектор, который находится на данной позиции, суммируется по правилу Эйнштейна<a name="310"></a><a name="311"></a>, 
т.е., как будто используется на данной позиции индекс, 
но этот индекс свертывается с индексом вектора. 
Следовательно FORM подразумевает, что что имеется свойство линейности по отношению к данному вектору. 
Тензора определяются одной из следующих конструкций 
(См. также страницы&nbsp;<a href="#substatensors">7.134</a>,
<a href="#substantensors">7.94</a>, <a href="#substactensors">7.22</a>):
</p><pre>    T[ensors] t1;
    CT[ensors] t2;
    NT[ensors] t3;
</pre>
Тип `ntensor' задает не-коммутирующий тензор, 
в то время как два других типа задают коммутирующие тензора. 
Обратите внимание, что 'T' это коммутирующий тензор, 
В то время как 'F' задает не-коммутирующую функцию. 
В дополнение к перечисленным выше объявлениям 
к ним можно добавлять такие же свойства комплексности, как и для функций. 
На данный момент это не очень полезно, т.к. на данный момент не существует оператора комплексного сопряжения. 
Внутренне тензор - это функция с внутренними свойствами. 
Следовательно, когда обсуждаются свойства функций, 
обычно эти свойства также относятся и к тензорам, 
до тех пор пока типы аргументов would not allow the operations or arguments specified.

<p>

</p><h1><a name="SECTION00360000000000000000">
Множества</a>
</h1>

<p>
<a name="sect-sets"></a>Множество<a name="320"></a> 
- (не пустая) коллекция переменных, которые должны быть одного типа. 
Этим типом могут быть символы, векторы, индексы или функции. 
Множество имеет имя, которое может использоваться для ссылки на него, 
и это имя может не совпадать с любыми другими именами в программе. 
Множество объявляется имененм, за которым следует двоеточие<a name="321"></a>, 
после чего перечисляются элементы множества. 
Первый элемент определяет тип всех элементов множества. 
Все элементы дожны быть объявлены как переменные перед объявлением множества. 
Возможно только одно множество на объявление. 
Пример (см. также <a href="#substaset">7.120</a>): 
</p><pre>     s    xa, xb, xc, xd, ya, x, y;
     i    mu, nu, rho;
     set exxes: xa, xb, xc, xd;
     set yyy: xc, xd, xb, ya;
     set indi:  mu, nu, rho, 1, 2, 3;
     set xandy: xa, ya;
</pre>
Мы здесь видим, что отдельный символ (xa) может принадлежать более чем одному множеству. 
Также фиксированные индексы (1, 2 и 3) могут быть элементами множества индексов и чисел, 
которые могут быть степенями, могут также быть членами множества символов (обычно от -9999 до + 9999). 
Если это может привести к путанице, FORM выдаст предупреждение 
и будет интерпретировать множество как множество символов.

<p>
В дополнение к пользовательским множествам 
существует несколько встроенных множеств со специальным значением:
</p><dl>
<dt><strong>int_</strong></dt>
<dd><a name="327"></a> Это множество символов. 
	Оно ссылается на все целые числа, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>pos_</strong></dt>
<dd><a name="329"></a> Это множество символов. 
	Это положительные целые, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>pos0_</strong></dt>
<dd><a name="331"></a> Множество символов. 
Это все неотрицательные числа, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>neg_</strong></dt>
<dd><a name="333"></a>  Множество символов. 
Это все отрицательные целые, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>neg0_</strong></dt>
<dd><a name="335"></a>  Множество символов. 
Это все неположительные целые, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>symbol_</strong></dt>
<dd><a name="337"></a> Множество всех формальных символов. 
Это исключает целые, числа и все аргументы функций.
</dd>
<dt><strong>fixed_</strong></dt>
<dd><a name="338"></a> Множество всех фиксированных индексов.
</dd>
<dt><strong>index_</strong></dt>
<dd><a name="339"></a> Множество всех индексов.
</dd>
<dt><strong>number_</strong></dt>
<dd><a name="340"></a> Множество всех рациональных чисел.
</dd>
<dt><strong>even_</strong></dt>
<dd><a name="341"></a> Это множество символов. 
Оно ссылается на все четные целые числа, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>odd_</strong></dt>
<dd><a name="343"></a> Это множество символов. 
Оно ссылается на все нечетные целые числа, которые могут поместиться в машинном слове FORM-а.
</dd>
<dt><strong>dummyindices_</strong></dt>
<dd><a name="345"></a> Это множество индексов. 
	Оно ссылается на все индексы типа Nm_? (m - положительное целое), 
	которое получается при помощи суммирования по индексам 
	при помощи конструкции суммирования<a name="346"></a> <a href="#substasum">7.129</a>.
</dd>
</dl>

<p>
Множества могут использоваться ссимволами подстановки<a name="349"></a>. 
Когда x - символ, нотация x? означает `любой символ'. 
Иногда это больше чем мы хотим. 
В случае, когда мы хотим `любой символ, который принадлежит множеству exxes' 
мы должны написать x?exxes, что является уникальным обозначением, 
т.к. обычно знак вопроса не может следовать за именем. 
Не должно быть пробелов между знаком вопроса и именем множества. 
Объект x?indi может привести к ошибке "не совпадение типов", 
если x будет символом, а indi - множеством индексов. 

</p><p>
Такое использование подстановочных символов по отношению к множествам может быть расширено еще больше: 
Нотация x?exxes?yyy означает, что x должен принадлежать множеству exxes, 
и его замена должна быть соответствующим элементом yyy. 
Во первых эта нотация выглядит излишне сложной. Конструкция 
</p><pre>     id   x?exxes?yyy = x;
</pre>
должна иметь более простой синтаксис
<pre>     id   exxes = yyy;
</pre>
Последнюю нотацию невозможно осуществить, когда паттерны более сложные, 
следовательно она, в общем, была пропущена.

<p>
Когда вещи становятся понастоящему сложными<a name="354"></a>, множества могут использоваться как массивы. 
Они могут использоваться с фиксированным индексом массива (1 - для первого элемента массива). 
Когда они имеют символьный аргумент (должен быть символом), 
они либо находятся в правой части конструкции id и этот символ должен быть заменен номером, 
по замене по подстановочному символу, либо находится в левой части 
и символ автоматически рассматривается как подстановочный. 
За множеством по прежнему следует знак вопроса в паттерне. 
Вот пример, проясняющий это:
</p><pre>    s a1,a2,a3,b1,b2,b3,x,n;
    f g1,g2,g3,g;
    set aa:a1,a2,a3;
    set bb:b1,b2,b3;
    set gg:g1,g2,g3;
   
    id  g(x?aa[n]) = gg[n](bb[n]) + bb[2]*n;
</pre>
n в левой части автоматически является подстановочным символом. 
x должен соответствовать элементу в aa и n становится равным его номеру. 
В правой части <code>gg[n]</code> становится элементом массива, когда в него подставляется n. 
То же самое происходит в <code>bb[n]</code>. 
Элемент <code>bb[2]</code> сразу заменяется на b2, так что использование этого способа редко приносит пользу, 
если только препроцессор не сделает что-нибудь с конструкцией этой величины. 
Следует прояснить: элементы массивов обозначаются прмыми скобками<a name="357"></a>. 

<p>
Другое использование множеств проявляется в опции select <a name="358"></a> конструкции id. 
Это обсуждается в главе&nbsp;<a href="#pattern">5</a> в соответствии шаблонам<a name="360"></a>. 

</p><p>
Ни свойства множеств как массивов ни опция select конструкции id 
не могут использоваться вместе со встроенными множествами. 
Эти множества не имеют конечного количества индексов.

</p><p>
Помио вышеперечисленных множеств, которые формально определены и используются по имени, 
есть второй способ использования множеств. 
Эти множества называются <b>неявно объевленными множествами<a name="361"></a></b>. 
Они объявляются в том месте, где они используются и их использование определяет их содержимое. 
Элементы множества должны быть заключены в фигурные скобки<a name="362"></a> 
И множество располагается в том месте, где должно находится имя множества:
</p><pre>    Symbols a1,a2,a3,b1,b2,b3,x,n;
    CFunctions g1,g2,g3,g;
    Local expr =
        g(a1)+g(a2)+g(a3)+g(x);
    id,g(x?{a1,a2,a3}[n]) = {g1,g2,g3}[n]({b1,b2,b3}[n]);
    print;
    .end

   expr =
      g1(b1) + g2(b2) + g3(b3) + g(x);
</pre>
Такое множество внутренне существует до конца модуля, в котором оно используется. 
Оно может использоваться во всех местах, где может использоваться именованное множество. 
Следовательно, оно также может использоваться, когда множество рассматривыается как массив.

<p>
Препроцессор должен быть в состоянии отличать такие множества от с трок в своем калькуляторе<a name="365"></a> 
(см. главу&nbsp;<a href="#preprocessor">3</a>). 
Обычно это не вызывает проблем, потому что любое обычное имя содержит по крайней мере один символ, 
который не воспринимается калькулятором. 
Если все эелементы множества числовые, запятая<a name="367"></a> скажет препроцессору, 
что это множество и калькулятор не будет использоваться. 
Сюда не попадает множество с одним числовым аргументом. 
Если поместить запятую до или после него, использование калькулятора будет запрещено. 
Это не внесет изменений в интерпретацию множества.

</p><p>
Когда возможно потребовать, чтобы объект находился во множестве<a name="368"></a>, 
также возможно потребовать, чтобы объект находился вне множества<a name="369"></a>. 
Это делается при помощи оператора `?!' вместо оператора `?'. 
Дополнительный восклицательный знак<a name="370"></a> похож на оператор `не'. 
Он может использоваться только когда имеет смысл. 
Следовательно он не может использоваться совместно с использованием множества как массива 
и вместе с опцией select конструкции id. 
Так что это может использоваться только в паттернах типа</p>
<pre>    x?!setname
    x?!{a,b,c}
</pre>
как это делается в
<pre>    id  x^n?!{,-1} = x^(n+1)/(n+1);
</pre>
У второго типа существует вариация, которая невозможна с именованными множествами<a name="375"></a>:
<pre>    Symbols a,b,x,y,z;
    CFunction f;
    
    id  f(x?!{a,y?,z?})*f(y?!{b,x?,z?})*f(z?!{x?,y?})
            =  .........
</pre>
В этом паттерне самое простое это z: 
Ей запрещено быть равной объектам, которые будут подставляться вместо символов x и y. 
Символ x не может быть равным подстановочным символам y и z, но дополнительно он не должен быть равен a. 
Такое же условие и для y. 
Можно поспорить, что по крайней мере одно из этих условий лишнее с чисто логической точки зрения. 
тем не менее она зависит от порядка объявлений, в котором FORM проходит по паттерну, 
так что это требует некоторых попыток увидеть, которое из утверждений `не' является излишним. 
Если например первая функция сопоставляется первой, то к этому моменту z не получила значение. 
Это значит, что z? в множестве пока не может использоваться, 
это место не накладывает ограничений на x. 
Следовательно x? в последней функции делает разными x и z. 
Если, с другой стороны, последняя функция должна сопоставляться первой, 
нам потребуется z? в множестве первой функции. 
С первой точки зрения, FORM может вернуться по паттерну и все-таки провести соответствующие исключения, 
но это будет стоить много дополнительного времени. 
Как видно, безопаснее задать обе.

<p>

</p><h1><a name="SECTION00370000000000000000">
Соглашения об автообъявлении (autodeclare)</a>
</h1>

<p>
Как мы видели выше, все переменные, вводимые пользователем должны быть объявлены. 
По этому FORM это строго<a name="382"></a> типизированный язык. 
Это не всегда удобно. Следовательно можно ввести некоторые правила 
об автоматическом объявлении классов переменных. 
Это делается конструкцией AutoDeclare<a name="383"></a> (см. также <a href="#substaautodeclare">7.9</a>). 
если мы используем конструкции
</p><pre>     AutoDeclare Symbol x,tt;
     AutoDeclare CFunction f,t;
</pre>
любой объект, встреченный компилятором, чье имя начинается с символа x 
автоматически будет объявлен как символ. 
также объекты, чье имя начинается с символов tt будут объявлены как символы. 
Объекты, чье имя начинается с символов f или t, но не со строки tt, 
и которые еще не объявлены будут объявлены автоматически как коммутирующие функции. 
Как можно видеть, в случае потенцтального конфликта<a name="387"></a> 
(такого как с t и tt), более ограничивающее объявление имеет преимущество. 
Это не зависит от порядка конструкций AutoDeclare. 
Один недостаток конструкции AutoDeclare состоит в том, 
оно теряет определенное количество контроля над порядком объявлений переменных, 
так что сейчас они объявляются в том порядке, в котором встречаются в конструкциях. 
Порядок объявлений определяет порядок объектов при выводе.

<p>

</p><h1><a name="SECTION00380000000000000000">
Списки имен</a>
</h1>

<p>
<a name="sect-namelists"></a>Иногда необходимо увидеть, как FORM интерпретирует множество объявлений. 
Может оказаться, что объявления производятся в непечатаемом include-файле 
и что пользователь хочет узнать, какие переменные были объявлены. 
Список<a name="391"></a> активных переменных<a name="392"></a> 
может быть напечатан при конструкции
</p><pre>     On names;
</pre>
Эта конструкция устанавливает флаг, который вызывает 
вывод всех таблиц имен и свойств по умолчанию, 
которые активны на момент окончания компиляции текущего модуля и модулей после. 
Печать как раз происходит перед тем как алгебраический процессор берет на себы исполнение модуля 
- подразумевая, что нет состояния ошибки. 
Если задан `On names' в модуле, который заканчивается на инструкцию .global, 
списки имен будут печататься в конце каждого модуля, 
т.к. печать списков имен после этого будет опцией по умолчанию. 
Если потребуется выключить флаг, 
это можно сделать при помощи конструкции
<pre>     Off names;
</pre>
которая запрещает печать списков имен в текущем модуле и во всех последующих.

<p>

</p><h1><a name="SECTION00390000000000000000">
Фиктивные индексы</a>
</h1>

<p>
<a name="sect-dummies"></a>Иногда по индексам<a name="399"></a> происходит суммирование 
but due to the evaluation procedures some terms contain the index mu and other terms 
contain the index nu. There is a command to sum over indices in such a way 
that FORM recognizes that the exact name of the index is irrelevant. 
This is the `sum'-statement (see also <a href="#substasum">7.129</a>):</p><pre>   i  mu,nu;
   f  f1,f2;
   L  F=f1(mu)*f2(mu)+f1(nu)*f2(nu);
   sum  mu;
   sum  nu;
   print;
   .end
</pre>
At first the expression contains two terms. After the summations FORM 
recognizes the terms as identical. In the output we see the term: 
<pre>   2*f1(N1_?)*f2(N1_?)
</pre>
The <code>N1_?</code> are dummy indices. 
The dimension of these dummy indices is the current 
default dimension<a name="407"></a> as set with the last 
dimension-statement. This may look like it is a restriction, but in 
practice it is possible to declare the default dimension to have one 
value in one module, take some sums, and do some more operations, and 
then give the default dimension another value in the next module. It should 
be realized however that then the dimension of the already existing dummy 
indices may change with it.

<p>
The scheme that is used to renumber<a name="408"></a> the 
indices<a name="409"></a> in a term is quite 
involved. It will catch nearly all possibilities, but in order to avoid 
to try all <img width="18" height="14" align="BOTTOM" border="0" src="./online_files/img5.png" alt="$n!$"> permutations, when there are n pairs of dummy indices, 
FORM does not try everything. It is possible to come up with examples 
in which the scheme is not perfect. It is left as a 
challenge for the reader to find such an example. In the case that the 
scheme isn't sufficient one can use the Renumber statement (see 
<a href="#substarenumber">7.115</a>) to force a complete renumbering. As this involves 
n! attempts in which n is the number of different dummy indices, this can 
become time consuming.

</p><p>
These dummy indices can be used to solve a well known problem in the 
automatic summation of indices. This problem occurs, when summed indices 
are found inside a subexpression that is raised to a power:
</p><pre>    Index mu,nu;
    CFunctions f,g;
    Vectors p,q;
    Local F = (f(mu)*g(mu))^2;
    sum mu;
    id f(nu?) = p(nu);
    id g(nu?) = q(nu);
    print;
    .end

   F =
      p.p*q.q;
</pre>
Clearly the answer is not what we had in mind, when we made the program. 
There is an easy way out:
<pre>    Index mu,nu;
    Symbol x;
    CFunctions f,g;
    Vectors p,q;
    Local F = x^2;
    repeat;
        id,once,x = f(mu)*g(mu);
        sum mu;
    endrepeat;
    id f(nu?) = p(nu);
    id g(nu?) = q(nu);
    print;
    .end

   F =
      p.q^2;
</pre>
This time things went better, because each sum-statement moves an index 
mu to a new dummy index.

<p>
There are some extra problems connected to dummy indices. Assume that we 
have the expression F which contains
</p><pre>     F = f(N1_?,N2_?)*f(N2_?,N1_?);
</pre>
and next we have the module
<pre>     Indices mu,nu,rho,si;
     Vectors p1,p2,p3,v;
     Tensor g;
     Local G = e_(mu,nu,rho,si)*g(mu,nu,p1,v)*g(rho,si,p2,v);
     sum mu,nu,rho,si;
     Multiply F^3;
     id  v = e_(p1,p2,p3,?);
     print;
     .end

   G =
      f(N1_?,N2_?)*f(N2_?,N1_?)*f(N3_?,N4_?)*f(N4_?,N3_?)*
      f(N5_?,N6_?)*f(N6_?,N5_?)*g(N7_?,N8_?,p1,N9_?)*
      g(N10_?,N11_?,p2,N12_?)*e_(p1,p2,p3,N9_?)*
      e_(p1,p2,p3,N12_?)*e_(N7_?,N8_?,N10_?,N11_?);
</pre>
Here the situation with the dummy indices becomes rather messy, and all 
earlier versions of FORM were not prepared for this. Their answer could be:
<pre>    G =
      f(N1_?,N2_?)*f(N1_?,N2_?)*f(N1_?,N2_?)*f(N2_?,N1_?)*
      f(N2_?,N1_?)*f(N2_?,N1_?)*g(N1_?,N2_?,p2,N3_?)*
      g(N4_?,N5_?,p1,N6_?)*e_(p1,p2,p3,N3_?)*
      e_(p1,p2,p3,N6_?)*e_(N1_?,N2_?,N4_?,N5_?);
</pre>
which is clearly not what the program is supposed to give. In the current 
version we have made the tracing of the dummy indices and the renumbering 
of them at the proper moment a lot better. It is however not complete as a 
complete implementation might severely influence the speed of execution at 
some points. The scheme is complete for the inclusion of local and global 
expressions. On the other hand it doesn't work for the contents of dollar 
variables<a name="423"></a>. Neither does it work for dummy indices 
introduced in user defined code as in
<pre>     id  x^n? = (f(N1_?)*g(N1_?))^n;
</pre>
For the latter case we showed a workaround above. Anyway there is a certain 
ambiguity here. Just imagine we write
<pre>     id  x^n? = f(N1_?)^n*g(N1_?)^n;
</pre>
Formally it is exactly the same, but what we mean is far from clear. For 
the dollar variables we considered the contracted dummy indices rare enough 
that it doesn't merit sacrificing speed. And then there is one more little 
caveat<a name="428"></a>. Global expressions that were stored with older 
versions of FORM than version 3.2, but are read with version 3.2 or later 
would have a problem if the expression were to contain dummy indices. The 
newer version of the .sav files<a name="430"></a> will contain information 
about the dummy indices. FORM can still read the old versions but will 
have to `invent' information by assuming that there are no dummy indices. 
If there are expressions with such dummy indices the best is to copy the 
expressions to a new expression and let the copying be followed by a .sort. 
That should set things straight. A final remark: if an elegant solution is 
found with which the above cases could be made to work without the penalty 
in execution time, it will be built in in the future.

<p>

</p><h1><a name="SECTION003100000000000000000">
Kronecker delta's</a>
</h1>

<p>
<a name="sect-kroneckerdelta"></a>The built in object d_ represents the Kronecker<a name="434"></a> 
delta<a name="435"></a>. Even though this 
object looks a little bit like a tensor, internally it isn't treated as 
such. Actually it has its own data type. It must have exactly two arguments 
and these arguments should be either indices or vectors. A d_ with at 
least one vector is immediately replaced, either by a vector with an index 
(if there is one vector and one index) or by a dotproduct (when there are 
two vectors). If a Kronecker delta contains an index that occurs also at 
another position in the same term, and if that index is summable, and if 
the index occurs as the index of a vector, inside a tensor, inside another 
d_ or as the argument of a function, and the object inside which it occurs 
is not inside the argument of a function itself (unless the d_ is inside 
the same argument) then the Einstein<a name="436"></a> 
summation<a name="437"></a> convention is used and the 
d_ is eliminated, while the second occurrence of the index is replaced by 
the other index in the d_ (Are you still with us?). When a 
Kronecker delta has two identical indices and these indices are summable, 
the d_ is replaced by the dimension of the index. If they are fixed 
indices, the d_ is replaced by one, unless this value has been altered 
with the fixindex-statement. Some examples of Kronecker delta's are given 
in section&nbsp;<a href="#fund">8.7</a>.

</p><p>

</p><h1><a name="SECTION003110000000000000000">
Extra Symbols</a>
</h1>

<p>
<a name="sect-extrasymbols"></a><a name="extrasymbols"></a>Starting with version 4.0 FORM is equipped with a mechanism to replace
non-symbol objects by internally generated symbols. These are called the 
extra symbols. Their numbering starts at maximum number allowed for 
internal objects and then counts down. Hence their ordering will be 
opposite to what might otherwise be expected. It is possible to control 
their representation when they are to be printed in the output. For this 
there is the ExtraSymbols (<a href="#substaextrasymbols">7.45</a>) statement. The 
definitions of the extra symbols can be made visible with the %X option in 
the #write preprocessor instruction.

</p><p>
Extra symbols can be introduced by the user with the ToPolynomial statement 
(<a href="#substatopolynomial">7.138</a>). This statement replaces all objects that are 
not numbers or symbols to positive powers by extra symbols. This may be 
needed for some new manipulations and can also be very handy for output 
that is to be treated by for instance a FORTRAN or C compiler. The 
FromPolynomial statement replaces the extra symbols again by their original 
meaning.

</p><p>
</p><pre>    Vector p,q,p1,p2;
    CFunction f;
    CFunction Dot,InvDot;
    Symbol x,x1,x2;
    Set pdot:p,q;
    Off Statistics;
    Local F = x+x^2+1/x+1/x^2+f(x1)+f(x2)*p.q*x+f(x2)/p.q^2;
    id  p1?pdot.p2?pdot = Dot(p1,p2);
    id  1/p1?pdot.p2?pdot = InvDot(p1,p2);
    Print;
    .sort

   F =
      x^-2 + x^-1 + x + x^2 + f(x1) + f(x2)*Dot(p,q)*x + f(x2)*InvDot(p,q)^2;

    ExtraSymbols,array,Y;
    Format DOUBLEFORTRAN;
    ToPolynomial;
    Print;
    .sort

      F =
     &amp; Y(1) + Y(1)**2 + Y(2) + Y(5)**2*Y(3) + x + x*Y(4)*Y(3) + x**2

    #write &lt;sub.f&gt; "      SUBROUTINE sub(Y)"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "*      Compute the extra symbols. Generated on `DATE_'"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "      REAL*8 Y(`EXTRASYMBOLS_')"
    #write &lt;sub.f&gt; "      REAL*8 Dot,InvDot"
    #write &lt;sub.f&gt; "      Dot(p1,p2)=p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)\
                                                              -p1(4)*p2(4)"
    #write &lt;sub.f&gt; "      InvDot(p1,p2)=1.D0/(Dot(p1,p2))"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "*        We still have to add definitions here."
    #write &lt;sub.f&gt; "*        And we have to import all the variables."
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "%X"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "      RETURN"
    #write &lt;sub.f&gt; "      END"
    ExtraSymbols,underscore,Z;
    Format Normal;
    Format 80;
    Print;
    .end

   F =
      Z1_ + Z1_^2 + Z2_ + Z5_^2*Z3_ + x + x*Z4_*Z3_ + x^2;

    FromPolynomial;
    Print;
    .end

   F =
      x^-2 + x^-1 + x + x^2 + f(x1) + f(x2)*Dot(p,q)*x + f(x2)*InvDot(p,q)^2;
</pre>
In the ExtraSymbols statement we say that we want the extra symbols to be 
presented as an array with the name Y. The alternative is a set of symbols 
with names ending in an underscore, but that would not make the FORTRAN 
compiler very happy. Then we convert the expression to symbols. As one can 
see, everything got converted to elements of an array Y which are treated 
as symbols. After we have written the file sub.f (notice that 
EXTRASYMBOLS_ is a built in symbol indicating the number of extra symbols) 
we change the representation to the (default) notation with an underscore 
and the character Z. The contents of the file sub.f are:
<pre>      SUBROUTINE sub(Y)
*
*      Compute the extra symbols. Generated on Sat Apr  2 20:40:33 2011
*
      REAL*8 Y(5)
      REAL*8 Dot,InvDot
      Dot(p1,p2)=p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)-p1(4)*p2(4)
      InvDot(p1,p2)=1.D0/(Dot(p1,p2))
*
*        We still have to add definitions here.
*        And we have to import all the variables.
*
      Y(1)=x**(-1)
      Y(2)=f(x1)
      Y(3)=f(x2)
      Y(4)=Dot(p,q)
      Y(5)=InvDot(p,q)

*
      RETURN
      END
</pre>
As one can see, with very little effort this routine can be made into a 
proper subroutine that computes all elements of the array Y which can then 
be used for computing the expression F.

<p>

</p><h1><a name="SECTION003120000000000000000">
Restrictions</a>
</h1>

<p>
There is a restriction<a name="450"></a> on the total number of 
variables<a name="451"></a> that FORM can handle. For the 
number of symbols, vectors, indices, functions and sets together the exact 
number depends on the type of computer. For a computer with a 32-bits 
processor this number is 32768. This includes the built in objects. 
Individual types of variables (like symbols) are usually restricted to 
about 8000. For a 
computer with a 64-bits processor the maximum has been set arbitrarily at 
2000000000. In addition there are restrictions on the total amount of 
memory<a name="453"></a> needed by FORM to maintain an 
administration of all these variables. These restrictions are set by the 
memory allocator of the computer on which FORM is running.

</p><p>

</p><h1><a name="SECTION003130000000000000000">
Some common bugs</a>
</h1>

<p>
There is a type of error<a name="457"></a><a name="458"></a> by the user (including at 
times the author) that is so common that it deserves mentioning here. 
Consider the code:
</p><pre>     Symbol x1,x2
     Index m1,m2;
</pre>
As a statement it is perfectly legal<a name="461"></a>, but it may produce 
rather funny errors at a later stage when we try to use m1 or m2. 
Inspection with the `On names;' statement shows that we have the symbols 
x1,x2,Index,m1,m2. This is most likely not what the user wanted. Closer 
inspection shows that we forgot the semicolon at the end of the symbol 
statement. We should have had:
<pre>     Symbol x1,x2;
     Index m1,m2;
</pre>
This is the most common error for which FORM cannot give a direct error 
message (it is after all a legal statement). Hence when faced with 
mysterious errors or error messages, one could have a good look by using 
the `On names' statement. Maybe it shows something, and if not, one has to 
look for other causes.

<p>

</p><h1><a name="SECTION00400000000000000000"></a>
<a name="preprocessor"></a>
<br>
Препроцессор
</h1>

<p>
Препроцессор<a name="658"></a> это фрагмент программы, которая читает и редактирует <a name="659"></a> ввод, 
после чего обработанный ввод направляется в компиляторную<a name="660"></a> часть FORM-а. 
Когда препроцессор встретит инструкцию модуля<a name="661"></a>, 
компиляция прерывается и модуль выполняется. 
Буферы компилятора очищаются и FORM продолжает со следующим модулем. 
Препроцессор работает только с символьными строками. 
Следовательно он не знает об алгебраических свойствах обрабатываеемых объектов. 
Дополнительно препроцессор отфильтровывает комментарии<a name="662"></a>.

</p><p>
Команды для препроцессора называются инструкциями. 
Инструкции препроцессора начинаются с символа # как первого непробельного символа в строке. 
После чего есть несколько возможностей.
</p><dl>
<dt><strong>#:</strong></dt>
<dd><a name="664"></a> Специальный синтаксис для настроечных параметров в начале программы. 
См. главу о настроечных параметрах.
</dd>
<dt><strong>#<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$">, #<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"></strong></dt>
<dd><a name="665"></a><a name="666"></a> Включает или выключает вывод ввода.
</dd>
<dt><strong>#name</strong></dt>
<dd><a name="667"></a> команда препроцессора. 
Синтаксис различных команд обсуждается ниже.
</dd>
<dt><strong>#$name</strong></dt>
<dd><a name="668"></a> Задание значения долларовой переменной в препроцессоре. 
См. главу <a href="#dollars">6</a> о долларовых переменных.
</dd>
</dl>

<p>

</p><h1><a name="SECTION00410000000000000000"></a>
<a name="preprovariables"></a>
<br>
Переменные препроцессора
</h1>

<p>
In order to help in the edit<a name="673"></a> function the preprocessor is 
equipped with variables<a name="674"></a> that can be defined 
or redefined by the user or by other preprocessor actions. Preprocessor 
variables have regular names that are composed of strings of alphanumeric 
characters of which the first one must be alphabetic. When they are defined 
one just uses this name. When they are used the name should be enclosed 
between a backquote<a name="675"></a> and a quote<a name="676"></a> as if these 
were some type of brackets. Hence `a2r' is the reference to a regular 
preprocessor variable. Preprocessor variables contain strings of 
characters. No interpretation is given to these strings. The 
backquote/quote pairs can be nested. Hence `a`i'r' will result in the 
preprocessor variable `i' to be substituted first. If this happens to be 
the string "2", the result after the first substitution would be `a2r' and 
then FORM would look for its string value.

</p><p>
The use of the backquotes is different from the earlier versions of FORM. 
There the preprocessor variables would be enclosed in a pair of quotes and 
no nesting<a name="677"></a> was possible. FORM still understands this old 
notation because it does not lead to ambiguities. The user is however 
strongly advised to use the new notation with the backquotes, because in 
future versions the old<a name="678"></a> notation may not be recognized 
any longer.

</p><p>
FORM has a number of built in preprocessor variables. They are:

</p><p>
</p><dl>
<dt><strong>VERSION_</strong></dt>
<dd>The current version<a name="680"></a> as the 4 in 4.1.
</dd>
<dt><strong>SUBVERSION_</strong></dt>
<dd>The sub-version<a name="681"></a> as the 1 in 4.1.
</dd>
<dt><strong>NAME_</strong></dt>
<dd>The name<a name="682"></a> of the program file.
</dd>
<dt><strong>DATE_</strong></dt>
<dd>The date<a name="683"></a> of the current run.
</dd>
<dt><strong>CMODULE_</strong></dt>
<dd>The number<a name="684"></a> of the current module.
</dd>
<dt><strong>SHOWINPUT_</strong></dt>
<dd>If input listing<a name="685"></a> is on: 1, if off: 0.
</dd>
<dt><strong>EXTRASYMBOLS_</strong></dt>
<dd>The current number of extra symbols<a name="686"></a>
       (see <a href="#substaextrasymbols">7.45</a>).
</dd>
<dt><strong>OLDNUMEXTRASYMBOLS_</strong></dt>
<dd>The number of extra symbols<a name="688"></a>
            before the current optimization started (see chapter <a href="#optimization">11</a>).
</dd>
<dt><strong>OPTIMMINVAR_</strong></dt>
<dd>The number of the first extra symbol<a name="690"></a> needed
               for the current optimization (see chapter <a href="#optimization">11</a>).
</dd>
<dt><strong>OPTIMMAXVAR_</strong></dt>
<dd>The number of the last extra symbol<a name="692"></a> needed
               for the current optimization (see chapter <a href="#optimization">11</a>).
</dd>
<dt><strong>PID_</strong></dt>
<dd>The process identifier (PID) <a name="694"></a> <a name="695"></a> of
               the running process. In P<small>AR</small>FORM (<a href="#parform">17.2</a>), it represents
               the PID of the master process in order to ensure that all the
               processes in a job use the same number. A recovered session from
               a checkpoint (<a href="#checkpoints">4.1</a>) keeps using the PID of the
               crushed session.
</dd>
<dt><strong>STOPWATCH_</strong></dt>
<dd>Same as `TIMER_'.
</dd>
<dt><strong>TIME_</strong></dt>
<dd>The running time<a name="699"></a> till the moment of call in the string format
               with a decimal point and two digits after the decimal point. 
               This is the same format as in the statistics.
</dd>
<dt><strong>TIMER_</strong></dt>
<dd>The running time<a name="700"></a> since the last reset in milliseconds. Hence, 
               unlike `time_' this value can be used in the preprocessor 
               calculator and in numerical compares in #if instructions.
               See also the #reset (see <a href="#prereset">3.46</a>) instruction.
</dd>
</dl>

<p>
If FORM cannot find a preprocessor variable, because it has 
neither been defined by the user, nor is it one of the built in variables, 
it will look in the systems environment<a name="703"></a> to see whether 
there is an environment variable by that name. If this is the case its 
string value will be substituted.

</p><p>
Preprocessor variables can have arguments and thereby become 
macro's. One should consult the description of the #define<a href="#predefine">3.17</a> 
instruction about the delayed substitution feature to avoid the value of 
the preprocessor variables in the macro would be substituted immediately 
during the definition. Hence proper use is
</p><pre>    #define EXCHANGE(x,y) "Multiply replace_(`~x',`~y',`~y',`~x');"
</pre>

<p>
FORM has the following built in macro's:
</p><dl>
<dt><strong>TOLOWER_(string)</strong></dt>
<dd>in which the character string in the argument is 
converted to lower case. After this it will become input.
</dd>
<dt><strong>TOUPPER_(string)</strong></dt>
<dd>in which the character string in the argument is 
converted to upper case. After this it will become input.
</dd>
</dl>
It is anticipated that some more macro's will become available to allow for 
the editing of names of variables.

<p>

</p><h1><a name="SECTION00420000000000000000"></a>
<a name="calculator"></a>
<br>
The preprocessor calculator
</h1>

<p>
Sometimes a preprocessor<a name="712"></a> variable 
should be interpreted as a number and some arithmetic<a name="713"></a> 
should be done with it. For this FORM is equipped with what is called the 
preprocessor calculator<a name="714"></a>. When the input reading device 
encounters a left curly<a name="715"></a> bracket<a name="716"></a> 
<code>{</code>, it will read till the matching right curly bracket <code>}</code> and 
then test whether the characters (after substitution of preprocessor 
variables) can be interpreted as a numerical expression. If it is not a 
valid numerical expression the whole string, including the curly brackets, 
will be passed on to the later stages of the program. If it is a numerical 
expression, it will be evaluated, and the whole string, including the curly 
brackets, will be replaced by a textual representation of the result. 
Example:
</p><pre>    Local F`i' = F{`i'-1}+F{`i'-2};
</pre>
If the preprocessor variable i has the value 11, the calculator makes this 
into
<pre>    Local F11 = F10+F9;
</pre>
Valid numerical expressions can contain the characters
<pre>   0 1 2 3 4 5 6 7 8 9 + - * / % ( ) { } &amp; | ^ !
</pre>
The use of parentheses is as in regular arithmetic. The curly 
brackets fulfil the same role, as one can nest these brackets of course. 
Operators are:
<dl>
<dt><strong><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"></strong></dt>
<dd>Regular addition<a name="724"></a>.
</dd>
<dt><strong><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"></strong></dt>
<dd>Regular subtraction<a name="725"></a>.
</dd>
<dt><strong><img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img8.png" alt="$\ast$"></strong></dt>
<dd>Regular multiplication<a name="726"></a>.
</dd>
<dt><strong><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img9.png" alt="$/$"></strong></dt>
<dd>Regular (integer) division<a name="727"></a>.
</dd>
<dt><strong><img width="18" height="31" align="MIDDLE" border="0" src="./online_files/img10.png" alt="$\%$"></strong></dt>
<dd>The remainder<a name="728"></a> after (integer) division as in 
the language C<a name="729"></a>.
</dd>
<dt><strong><img width="17" height="14" align="BOTTOM" border="0" src="./online_files/img11.png" alt="$\&amp;$"></strong></dt>
<dd>And<a name="730"></a> operator. This is a bitwise operator.
</dd>
<dt><strong><img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"></strong></dt>
<dd>Or<a name="731"></a> operator. This is a bitwise or.
</dd>
<dt><strong><img width="15" height="14" align="BOTTOM" border="0" src="./online_files/img13.png" alt="$\wedge$"></strong></dt>
<dd>Exponent<a name="732"></a> operator.
</dd>
<dt><strong><img width="8" height="14" align="BOTTOM" border="0" src="./online_files/img14.png" alt="$!$"></strong></dt>
<dd>Factorial<a name="733"></a>. This is a postfix operator.
</dd>
<dt><strong><img width="28" height="31" align="MIDDLE" border="0" src="./online_files/img15.png" alt="$\wedge\%$"></strong></dt>
<dd>A postfix <img width="32" height="33" align="MIDDLE" border="0" src="./online_files/img16.png" alt="${}^2\!\log$">. This means that it 
takes<a name="735"></a> the <img width="32" height="33" align="MIDDLE" border="0" src="./online_files/img16.png" alt="${}^2\!\log$"> of the object to the left of it.
</dd>
<dt><strong><img width="23" height="31" align="MIDDLE" border="0" src="./online_files/img17.png" alt="$\wedge/$"></strong></dt>
<dd>A postfix square<a name="737"></a> root. This means that 
it takes the square root of the object to the left of it.
</dd>
</dl>
Note that all arithmetic<a name="739"></a> is done over the integers and 
that there is a finite range. On 32<a name="740"></a> bit systems this range 
will be <img width="53" height="33" align="MIDDLE" border="0" src="./online_files/img18.png" alt="$2^{31}-1$"> to <img width="38" height="33" align="MIDDLE" border="0" src="./online_files/img19.png" alt="$-2^{31}$">, while on 64<a name="743"></a> bit systems 
this will be  <img width="53" height="33" align="MIDDLE" border="0" src="./online_files/img20.png" alt="$2^{63}-1$"> to <img width="38" height="33" align="MIDDLE" border="0" src="./online_files/img21.png" alt="$-2^{63}$">. In particular this means that 
<code>{13^/}</code> becomes <code>3</code>. The preprocessor calculator is only meant 
for some simple counting and organization of the program flow. Hence there 
is no large degree of sophistication. Very important is that the 
comma<a name="746"></a> character is not a legal character for the preprocessor 
calculator. This can be used to avoid some problems. Suppose one needs to 
make a substitution of the type:
<pre>    id f(x?!{0}) = 1/x;
</pre>
in which the value zero should be excluded from the pattern matching (see 
dynamical<a name="749"></a> sets in chapter <a href="#pattern">5</a> on pattern 
matching). This would not work, because the preprocessor would make this 
into
<pre>    id f(x?!0) = 1/x;
</pre>
which is illegal syntax. Hence the proper trick is to write
<pre>    id f(x?!{,0}) = 1/x;
</pre>
With the comma the preprocessor will leave this untouched, and hence now 
the set is passed properly.

<p>
Good use of the preprocessor calculator can make life much easier for 
FORM. For example the following statements
</p><pre>    id  f(`i') = 1/(`i'+1);
    id  f(`i') = 1/{`i'+1};
</pre>
are quite different in nature. In the first statement the compiler gets an 
expression with a composite denominator. The compiler never tries to 
simplify expressions by doing algebra on them. Sometimes this may not be 
optimal, but there are cases in which it would cause wrong results (in 
particular when noncommuting and commuting functions are mixed and 
wildcards are used). Hence the composite denominator has to be worked out 
during run time for each term separately. The second statement has the 
preprocessor work out the sum and hence the compiler gets a simple fraction 
and less time will be needed during running. Note that
<pre>    id  f(`i') = {1/(`i'+1)};
</pre>
would most likely not produce the desired result, because the preprocessor 
calculator works only over the integers. Hence, unless i is equal to zero 
or -2, the result would be zero (excluding of course the fatal error when i 
is equal to -1).

<p>

</p><h1><a name="SECTION00430000000000000000"></a>
<a name="tripledot"></a>
<br>
The triple dot operator
</h1>

<p>
The last<a name="761"></a> stage of the actions of the preprocessor involves the 
triple dot operator. It indicates a repeated pattern as in <code>a1+...+a4</code> 
which would expand into <code>a1+a2+a3+a4</code>. This operator is used in two 
different ways. First the most general way:
</p><pre>    &lt;pattern1&gt;operator1...operator2&lt;pattern2&gt;
</pre>
in which the less<a name="764"></a> than and greater<a name="765"></a> 
than signs serve as boundaries for the patterns. The operators can be any 
pair of the following:
<dl>
<dt><strong>+ +</strong></dt>
<dd><a name="767"></a> Repetitions will be separated by plus signs.
</dd>
<dt><strong>- -</strong></dt>
<dd><a name="768"></a> Repetitions will be separated by minus signs.
</dd>
<dt><strong>+ -</strong></dt>
<dd><a name="769"></a> Repetitions will be separated by alternating signs. 
First will be plus.
</dd>
<dt><strong>- +</strong></dt>
<dd><a name="770"></a> Repetitions will be separated by alternating signs. 
First will be minus.
</dd>
<dt><strong><img width="25" height="13" align="BOTTOM" border="0" src="./online_files/img22.png" alt="$\ast \ast$"></strong></dt>
<dd><a name="771"></a> Repetitions will be separated by <img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img8.png" alt="$\ast$">.
</dd>
<dt><strong>/ /</strong></dt>
<dd><a name="772"></a> Repetitions will be separated by /.
</dd>
<dt><strong>, ,</strong></dt>
<dd><a name="773"></a> Repetitions will be separated by comma's.
</dd>
<dt><strong>: :</strong></dt>
<dd><a name="774"></a> Repetitions will be separated by <i>single</i> dots.
</dd>
</dl>
For such a pair of operators FORM will inspect the patterns<a name="777"></a> 
and see whether the differences between the two patterns are just numbers. 
If the differences are numbers and the absolute value of the difference of 
each matching pair is always the same (a difference of zero is allowed too; 
it leads to no action for the pair), then FORM will expand the pattern, 
running from the first to the last in increments of one. For each pair the 
counter can either run up or run down, depending on whether the number in 
the first pattern is greater or less than the number in the second pattern. 
Example:
<pre>    Local F = &lt;a1b6(c3)&gt;-...+&lt;a4b3(c6)&gt;;
</pre>
leads to
<pre>    Local F = a1b6(c3)-a2b5(c4)+a3b4(c5)-a4b3(c6);
</pre>
The second form is a bit simpler. It recognizes that there are special 
cases that can be written in a more intuitive way. If there is only a 
single number to be varied, and it is the end of the pattern, and the rest 
of the patterns consists only of alphanumeric characters of which the first 
is an alphabetic character, we do not need the less than/greater than 
combination. This is shown in
<pre>    Symbol a1,...,a12;
</pre>
There is one extra exception. The variables used this way may have a 
question mark after them to indicate that they are wildcards:
<pre>    id  f(a1?,...,a4?) = g(a1,...,a4,a1+...+a4);
</pre>
This construction did not exist in earlier versions of FORM (version 1 and 
version 2). There one needed the #do<a name="786"></a> instruction for many of 
the above constructions, creating code that was very hard to read. The 
<code>...</code> operator should improve the readability of the programs very 
much.

<p>

</p><h1><a name="SECTION00440000000000000000"></a>
<a name="preadd"></a>
<br>
#add
</h1>

<p>
Syntax:

</p><p>
#add object: "string"

</p><p>
See chapter <a href="#dictionaries">13</a> on dictionaries.

</p><p>
Adds words to an open dictionary.

</p><p>

</p><h1><a name="SECTION00450000000000000000"></a>
<a name="preaddseparator"></a>
<br>
#addseparator
</h1>

<p>
Syntax:

</p><p>
#addseparator character

</p><p>
See also #rmseparator (<a href="#prermseparator">3.49</a>),
            #call (<a href="#precall">3.9</a>), #do (<a href="#predo">3.18</a>)

</p><p>
Adds a character<a name="795"></a> to the list of permissible 
separator characters for arguments of #call or #do instructions. By 
default the two characters that are permitted are the comma and the 
character <code>|</code>. Blanks, tabs and double quotes are ignored. Note that 
the comma must be specified between double quotes as in
</p><pre>  #addseparator ","
</pre>

<p>

</p><h1><a name="SECTION00460000000000000000"></a>
<a name="preappend"></a>
<br>
#append
</h1>

<p>
Syntax:

</p><p>
#append <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">filename<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">

</p><p>
See also write (<a href="#prewrite">3.61</a>),
            close (<a href="#preclose">3.12</a>), create (<a href="#precreate">3.15</a>),
            remove (<a href="#preremove">3.45</a>)

</p><p>
Opens<a name="804"></a> the named file for writing. The file will 
be positioned at the end. The next #write<a name="805"></a> instruction will 
add to it.

</p><p>

</p><h1><a name="SECTION00470000000000000000"></a>
<a name="prebreak"></a>
<br>
#break
</h1>

<p>
Syntax:

</p><p>
#break

</p><p>
See also switch (<a href="#preswitch">3.55</a>),
        endswitch (<a href="#preendswitch">3.25</a>),
        case (<a href="#precase">3.10</a>),
        default (<a href="#predefault">3.16</a>)

</p><p>
If the<a name="812"></a> lines before were not part of the control 
flow (<i>i.e.</i> these lines are used for the later stages of the program), 
this instruction is ignored. If they are part of the control flow, the flow 
will continue after the matching #endswitch<a name="814"></a> 
instruction. The #break instruction must of course be inside the range of 
a #switch<a name="815"></a>/#endswitch construction.

</p><p>

</p><h1><a name="SECTION00480000000000000000"></a>
<a name="prebreakdo"></a>
<br>
#breakdo
</h1>

<p>
Syntax:

</p><p>
#breakdo [<tt>&lt;</tt>number<tt>&gt;</tt>]

</p><p>
See also #do (<a href="#predo">3.18</a>) and #enddo (<a href="#preenddo">3.21</a>)

</p><p>
The #breakdo<a name="822"></a> instruction allows one to jump out 
of a #do loop. If a (nonzero integer) number is specified it indicates the 
number of loops the program should terminate. Control will continue after 
the #enddo instruction of the number of loops indicated by `number'. 
The default value is one. If the value is zero the statement has no effect.

</p><p>

</p><h1><a name="SECTION00490000000000000000"></a>
<a name="precall"></a>
<br>
#call
</h1>

<p>
Syntax:

</p><p>
#call procname(var1,...,varn)

</p><p>
See also procedure (<a href="#preprocedure">3.41</a>), endprocedure
(<a href="#preendprocedure">3.24</a>)

</p><p>
This instruction<a name="827"></a> calls the 
procedure<a name="828"></a> with the name procname. The result is that FORM 
looks for this procedure, first in its procedure 
buffers<a name="829"></a> (for procedures that were defined in the 
regular text stream as explained under the #procedure<a name="830"></a> 
instruction), then it looks for a file by the name procname.prc in the 
current directory, and if it still has not found the procedure, it looks in 
the directories indicated by the path<a name="831"></a> variable in either the setup 
file or at the start of the program (see chapter <a href="#setup">16</a> on the setup 
file). Next it looks for the -p option in the command that started FORM 
(see the chapter on running FORM). If this -p option has not been used FORM 
will see whether there is an environment variable by the name 
FORMPATH<a name="833"></a>. The directories indicated there will be searched 
for the file procname.prc. If FORM cannot find the file, there will be an 
error message and execution will be stopped immediately.

</p><p>
Once the procedure has been located, FORM reads the whole file and then 
determines whether the number of parameters is identical in the 
#call<a name="834"></a> instruction and the #procedure<a name="835"></a> 
instruction. A difference is a fatal error.

</p><p>
The parameter field consists of strings, separated by commas. If a string 
contains a comma, this comma should be preceded by a 
backslash<a name="836"></a> character (<code>\</code>). If a string should contain 
a linefeed<a name="837"></a>, one should `escape' this linefeed by putting a 
backslash and continue on the next line.

</p><p>
Before version 3 of FORM the syntax was different. The parentheses 
were curly brackets and the separators the symbol <code>|</code>. This was made 
to facilitate the use of strings that might contain commas. In practise 
however, this turned out to be far from handy. In addition the new 
preprocessor calculator is a bit more active and hence an instruction of 
the type
</p><pre>    #call test{1}
</pre>
will now be intercepted by the preprocessor calculator<a name="840"></a> 
and changed into
<pre>    #call test1
</pre>
Because there are many advantages to the preprocessor calculator treating 
the parameters of the procedures before they are called (in the older 
versions it did not do this), the notation has been changed. FORM still 
understands the old notation, provided that there is no conflict with the 
preprocessor calculator. Hence
<pre>    #call test{1|a}
    #call test{1,a}
    #call test(1|a)
    #call test(1,a)
</pre>
are all legal and give the same result, but only the last notation will 
work in future versions of FORM.

<p>
Nowadays also the use of the argument field wildcard (see chapter 
<a href="#pattern">5</a> on pattern matching) is allowed as in the 
regular functions:
</p><pre>    #define a "1"
    #define bc2 "x"
    #define bc3 "y"
    #define b "c`~a'"
    #procedure hop(c,?d);
    #redefine a "3"
    #message This is the call: `c',`?d'
    #endprocedure
    
    #redefine a "2"
    #message This is b: `b'
~~~This is b: c2
    
    #call hop(`b`!b''`!b'`b'`!b'`b',`~a',`b',`a')
~~~This is the call: xc2c3c2c3,3,c3,2
    
    .end
</pre>
We also see here that the rules about delayed substitution (see also the 
#define<a name="848"></a> instruction in section <a href="#predefine">3.17</a>) apply. The 
use of `!b' cancels the delayed substitution that is asked for in the 
definition of b.

<p>
The default extension for procedure files is .prc<a name="850"></a>, but it is 
possible to change this. There are two different ways: One is with the 
#procedureExtension<a name="851"></a> instruction in section 
<a href="#preprocedureextension">3.42</a>. The other is via the setup (see the chapter on 
the setup file, chapter <a href="#setup">16</a>).

</p><p>

</p><h1><a name="SECTION004100000000000000000"></a>
<a name="precase"></a>
<br>
#case
</h1>

<p>
Syntax:

</p><p>
#case string

</p><p>
See also switch (<a href="#preswitch">3.55</a>),
        endswitch (<a href="#preendswitch">3.25</a>),
        break (<a href="#prebreak">3.7</a>),
        default (<a href="#predefault">3.16</a>)

</p><p>
The lines after the #case<a name="860"></a> instruction will be used 
if either this is the first #case<a name="861"></a> instruction of which the 
string matches the string in the #switch<a name="862"></a> instruction, or 
the control flow was already using the lines before this #case instruction 
and there was no #break<a name="863"></a> instruction (this is called 
fall-through). The control flow will include lines either until the next 
matching #break instruction, or until the matching 
#endswitch<a name="864"></a> instruction.

</p><p>

</p><h1><a name="SECTION004110000000000000000"></a>
<a name="preclearoptimize"></a>
<br>
#clearoptimize
</h1>

<p>
Syntax:

</p><p>
#clearoptimize

</p><p>
See the chapter about optimization <a href="#optimization">11</a>

</p><p>

</p><h1><a name="SECTION004120000000000000000"></a>
<a name="preclose"></a>
<br>
#close
</h1>

<p>
Syntax:

</p><p>
#close <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">filename<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">

</p><p>
See also write (<a href="#prewrite">3.61</a>), append (<a href="#preappend">3.6</a>),
            create (<a href="#precreate">3.15</a>), remove (<a href="#preremove">3.45</a>)

</p><p>
This instruction closes<a name="874"></a> the file<a name="875"></a> 
by the given name, if such a file had been opened by the previous 
#write<a name="876"></a> instruction. Normally FORM closes all such files at 
the end of execution. Hence the user would not have to worry about this. 
The use of a subsequent #write instruction with the same file name will 
remove the old contents and hence start basically a new file. There are 
times that this is useful.

</p><p>

</p><h1><a name="SECTION004130000000000000000"></a>
<a name="preclosedictionary"></a>
<br>
#closedictionary
</h1>

<p>
Syntax:

</p><p>
#closedictionary

</p><p>
See chapter <a href="#dictionaries">13</a> on dictionaries.

</p><p>
Either closes an open dictionary (<a href="#preopendictionary">3.36</a>) or stops 
using the dictionary (<a href="#preusedictionary">3.60</a>) that is currently used for output 
translation.

</p><p>

</p><h1><a name="SECTION004140000000000000000"></a>
<a name="precommentchar"></a>
<br>
#commentchar
</h1>

<p>
Syntax:

</p><p>
#commentchar character

</p><p>
Заданный символ<a name="884"></a> должен быть одним непробельным символом. 
Перед ним  и после него могут присутствовать пробельные символы (пробелы и/или табуляции). 
Этот символ берет на себя роль символа комментария. 
<i>т.е.</i> любая строка, которая начинается с этого символа в первой колонке, 
будет считаться комментарием<a name="886"></a>. 
Эта фичя сделана по тому, что в выводе некоторых других алгебраических программ 
знак умножения в колонке 1 в длинных выражениях.

</p><p>
По умолчанию символ комментария это <img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img8.png" alt="$\ast$">.

</p><p>

</p><h1><a name="SECTION004150000000000000000"></a>
<a name="precreate"></a>
<br>
#create
</h1>

<p>
Syntax:

</p><p>
#append <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">filename<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">

</p><p>
See also write (<a href="#prewrite">3.61</a>),
            close (<a href="#preclose">3.12</a>), append (<a href="#preappend">3.6</a>),
            remove (<a href="#preremove">3.45</a>)

</p><p>
Opens the named<a name="893"></a> file for writing. If the file 
existed already, its previous contents will be lost. The next 
#write<a name="894"></a> instruction will add to it. In principle this 
instruction is not needed, because the #write instruction would create the 
file if it had not been opened yet at the moment of writing.

</p><p>

</p><h1><a name="SECTION004160000000000000000"></a>
<a name="predefault"></a>
<br>
#default
</h1>

<p>
Syntax:

</p><p>
#default

</p><p>
See also switch (<a href="#preswitch">3.55</a>),
        endswitch (<a href="#preendswitch">3.25</a>),
        case (<a href="#precase">3.10</a>),
        break (<a href="#prebreak">3.7</a>)

</p><p>
Control<a name="901"></a> flow continues after this instruction if 
there is no #case<a name="902"></a> instruction of which the string matches 
the string in the #switch<a name="903"></a> instruction. Control flow also 
continues after this instruction, if the lines before were included and 
there was no #break<a name="904"></a> instruction to stop the control flow 
(fall-through). Control flow will stop either when a matching #break 
instruction is reached, or when a matching #endswitch<a name="905"></a> 
is encountered. In the last case of course control flow will continue after 
the #endswitch instruction.

</p><p>

</p><h1><a name="SECTION004170000000000000000"></a>
<a name="predefine"></a>
<br>
#define
</h1>

<p>
Syntax:

</p><p>
#define name "string"

</p><p>
See also redefine (<a href="#preredefine">3.44</a>), undefine 
(<a href="#preundefine">3.59</a>)

</p><p>
in which name<a name="910"></a> refers to the name of the 
preprocessor<a name="911"></a> 
variable<a name="912"></a> to be defined and the contents of the 
string will form the value of the variable. The double quotes are mandatory 
delimiters of the string.

</p><p>
The use of the #define<a name="913"></a> instruction creates a new instance 
of the preprocessor variable with the given name. This means that the old 
instance<a name="914"></a> remains. If for some reason the later instance 
becomes undefined (see for instance #undefine), the older instance will be 
the one that is active. If the old definition is to be overwritten, one 
should use the #redefine<a name="915"></a> instruction.

</p><p>
As of version 3.2 preprocessor variables can also have arguments as in the 
C<a name="916"></a> language. Hence

</p><p>
#define var(a,b) "(`<code>~</code>a'+`<code>~</code>b'+`c')"

</p><p>
is allowed. The parameters should be referred to inside a pair of `' as 
with all preprocessor variables. A special feature is the socalled 
delayed<a name="917"></a> 
substitution<a name="918"></a>. With macro's like the above the 
question is always <i>when</i> a preprocessor variable will be substituted. 
Take for instance
</p><pre>    #define c "3"
    #define var1(a,b) "(`~a'+`~b'+`c')"
    #define var2(a,b) "(`~a'+`~b'+`~c')"
    #redefine c "4"
    Local F1 = `var1(1,2)';
    Local F2 = `var2(1,2)';
    Print;
    .end

   F1 =
      6;

   F2 =
      7;
</pre>
The parameter c will be substituted immediately when var1 is defined. In 
var2 it will be only substituted when var2 is used. It should be clear that 
a and b should also be used in the delayed fashion because they do not 
exist yet at the moment of the definition of var1 and var2. Notice also 
that the whole macro<a name="922"></a>, with its arguments should be placed 
between the backquote and the quote. Another example can be found with the 
#call<a name="923"></a> instruction. See section <a href="#precall">3.9</a>

<p>

</p><h1><a name="SECTION004180000000000000000"></a>
<a name="predo"></a>
<br>
#do
</h1>

<p>
Syntax:

</p><p>
#do lvar = i1,i2

</p><p>
#do lvar = i1,i2,i3

</p><p>
#do lvar = <img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img25.png" alt="$\{$">string1<img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$">...<img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$">stringn<img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img26.png" alt="$\}$">

</p><p>
#do lvar = <img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img25.png" alt="$\{$">string1,...,stringn<img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img26.png" alt="$\}$">

</p><p>
#do lvar = nameofexpression

</p><p>
See also enddo (<a href="#preenddo">3.21</a>)

</p><p>
The #do<a name="928"></a> instruction<a name="929"></a> needs a matching 
#enddo<a name="930"></a> instruction. All code in-between these two 
instructions will be read as many times as indicated in the parameter field 
of the #do instruction. The parameter lvar is a preprocessor variable of 
which the value is determined by the other parameters. Inside the loop it 
should be referred to by enclosing its name between a backquote/quote pair 
as is usual for preprocessor variables. The various possible parameter 
fields have the following meaning:
</p><dl>
<dt><strong>#do lvar = i1,i2</strong></dt>
<dd>The parameters i1 and i2 should be integers or 
names of dollar expressions that evaluate into integers. The 
first time in the loop lvar will get the value of i1 (as a string) and each 
next time its value will be one greater (translated into a string again). 
The last time in the loop the value of lvar will be the greatest integer 
that is less or equal to i2. If i2 is less than i1, the loop is skipped 
completely. If i2 is the name of a dollar variable, each time the control 
reaches the end of the loop the dollar variable is evaluated and the 
current value is used.
</dd>
<dt><strong>#do lvar = i1,i2,i3</strong></dt>
<dd>The parameters i1,i2 and i3 should be integers 
or names of dollar expressions that evaluate into integers. 
The first time in the loop lvar will get the value of i1 (as a string) and 
each next time its value will be incremented by adding i3 (translated into 
a string again). If i3 is positive, the last value of lvar will be the one 
for which lvar+i3 is greater than i2. If i2 is less than i1, the loop is 
skipped completely. If i3 is negative the last value of lvar will be the 
one for which lvar+i3 is less than i2. If i3 is zero there will be an 
error. If i2 or i3 are the names of a dollar variable, each time the control 
reaches the end of the loop the dollar variable(s) is/are evaluated and the 
current value is used.
</dd>
<dt><strong>#do lvar = <img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img25.png" alt="$\{$">string1<img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$">...<img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$">stringn<img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img26.png" alt="$\}$"></strong></dt>
<dd>The first time in the 
loop the value of lvar is the string indicated by string1, the next time 
will be string2 etc till the last time when it will be stringn. This is 
called a listed<a name="932"></a> loop<a name="933"></a>. The notation 
with the <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> is an old notation which is still accepted. The new notation 
uses a comma instead.
</dd>
<dt><strong>#do lvar = <img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img25.png" alt="$\{$">string1,...,stringn<img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img26.png" alt="$\}$"></strong></dt>
<dd>The first time in the loop 
the value of lvar is the string indicated by string1, the next time will be 
string2 etc till the last time when it will be stringn. This is called a 
listed<a name="934"></a> loop<a name="935"></a>.
</dd>
<dt><strong>#do lvar = expression</strong></dt>
<dd>The loop variable will take one by one for 
its value all the terms of the given expression. This is protected against 
changing the expression inside the loop by making a copy of the expression 
inside the memory. Hence one should be careful with very big expressions. 
An expression that is zero gives a loop over zero terms, hence the loop is 
never executed.
</dd>
</dl>
The first two types of #do instructions are called 
numerical<a name="937"></a> loops<a name="938"></a>. In the 
parameters of numerical loops the preprocessor calculator<a name="939"></a> 
is invoked automatically. One should make sure not to use a leading <img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img25.png" alt="$\{$"> 
for the first numerical parameter in such a loop. This would be interpreted 
as belonging to a listed loop.

<p>
After a loop has been finished, the corresponding preprocessor variable 
will be undefined. This means that if there is a previous preprocessor 
variable by the same name, the value of the #do instruction will be used 
inside the loop, and afterwards the old value will be active again.

</p><p>
It is allowed to overwrite the value of a preprocessor #do instruction 
variable. This can be very useful to create the equivalent of a repeat loop 
that contains .sort instructions as in
</p><pre>    #do i = 1,1
        id,once,x = y+2;
        if ( count(x,1) &gt; 0 ) redefine i "0";
        .sort
    #enddo
</pre>
A few remarks are necessary here. The redefine<a name="942"></a> statement 
(see section <a href="#substaredefine">7.114</a>) should be before the last 
.sort<a name="944"></a> inside the loop, because the #do instruction is part of 
the preprocessor. Hence the value of i is considered before the module is 
executed. This means that if the redefine would be after the .sort, two 
things would go wrong: First the loop would be terminated before the 
redefine would ever make a chance of being executed. Second the statement 
would be compiled in the expectation that there is a variable i, but then 
the loop would be terminated. Afterwards, when the statement is being 
executed it would refer to a variable that does not exist any longer. 

<p>
If one wants to make a loop over the externals of the brackets of an 
expression only, one needs to do some work. Assume we have the expression F 
and we want to loop over the brackets in x and y:
</p><pre>    L   FF = F;
    Bracket x,y;
    .sort
    CF acc,acc2;
    Skip F;
    Collect acc,acc2;
    id  acc(x?) = 1;
    id  acc2(x?)= 1;
    B   x,y;
    .sort
    Skip F;
    Collect acc;
    id  acc(x?) = 1;
    .sort
    #do i = FF
    L   G = F[`i'];
        .
        .
    #enddo
</pre>
Notice that we have to do the collect<a name="947"></a> trick twice because 
the first time the bracket could be too long for one term. The second time 
that restriction doesn't exist because besides the x and the y there are 
only integer coefficients.

<p>

</p><h1><a name="SECTION004190000000000000000"></a>
<a name="preelse"></a>
<br>
#else
</h1>

<p>
Syntax:

</p><p>
#else

</p><p>
See also if (<a href="#preif">3.30</a>),
            endif (<a href="#preendif">3.22</a>),
            elseif (<a href="#preelseif">3.20</a>),
            ifdef (<a href="#preifdef">3.31</a>),
            ifndef (<a href="#preifndef">3.32</a>)

</p><p>
This instruction<a name="955"></a> is used inside a 
#if<a name="956"></a>/#endif<a name="957"></a> construction. The code that follows 
it until the #endif instruction will be read if the condition of the #if 
instruction (and of none of the corresponding #elseif<a name="958"></a> 
instructions) is not true. If any of these conditions is true, this code is 
skipped. The reading is stopped after the matching #endif is encountered 
and continued after this matching #endif instruction.

</p><p>

</p><h1><a name="SECTION004200000000000000000"></a>
<a name="preelseif"></a>
<br>
#elseif
</h1>

<p>
Syntax:

</p><p>
#elseif ( condition )

</p><p>
See also if (<a href="#preif">3.30</a>),
            endif (<a href="#preendif">3.22</a>),
            else (<a href="#preelse">3.19</a>)

</p><p>
The syntax<a name="964"></a> of the condition is identical to the 
syntax for the condition in the #if<a name="965"></a> instruction. The #elseif 
instruction can occur between an #if and an #endif<a name="966"></a> 
instruction, before a possible matching #else<a name="967"></a> instruction. 
The code after this condition till the next #elseif instruction, or till a 
#else instruction or till a #endif instruction, whatever comes first, 
will be read if the condition in the #elseif instruction is true and none 
of the conditions in matching previous #if or #elseif instructions were 
true. The reading is stopped after the matching #elseif/#else/#endif is 
encountered and continued after the matching #endif instruction.

</p><p>
Example
</p><pre>    #if ( `i' == 2 )
        some code
    #elseif ( `i' == 3 )
        more code
    #elseif ( `j' &gt;= "x2y" )
        more code
    #else
        more code
    #endif
</pre>

<p>

</p><h1><a name="SECTION004210000000000000000"></a>
<a name="preenddo"></a>
<br>
#enddo
</h1>

<p>
Syntax:

</p><p>
#enddo

</p><p>
See also do (<a href="#predo">3.18</a>)

</p><p>
Used to<a name="973"></a> terminate<a name="974"></a> a preprocessor 
do<a name="975"></a> loop. See the #do<a name="976"></a> instruction.

</p><p>

</p><h1><a name="SECTION004220000000000000000"></a>
<a name="preendif"></a>
<br>
#endif
</h1>

<p>
Syntax:

</p><p>
#endif

</p><p>
See also if (<a href="#preif">3.30</a>),
            else (<a href="#preelse">3.19</a>),
            elseif (<a href="#preelseif">3.20</a>),
            ifdef (<a href="#preifdef">3.31</a>),
            ifndef (<a href="#preifndef">3.32</a>)

</p><p>
Used to terminate<a name="984"></a> a #if<a name="985"></a>, 
#ifdef<a name="986"></a> or #ifndef<a name="987"></a> construction. 
Reading will continue after it.

</p><p>

</p><h1><a name="SECTION004230000000000000000"></a>
<a name="preendinside"></a>
<br>
#endinside
</h1>

<p>
Syntax:

</p><p>
#endinside

</p><p>
See also #inside (<a href="#preinside">3.34</a>)

</p><p>
Used to<a name="991"></a> terminate a #inside construction in 
the preprocessor. For more details, see the #inside<a name="992"></a> 
instruction.

</p><p>

</p><h1><a name="SECTION004240000000000000000"></a>
<a name="preendprocedure"></a>
<br>
#endprocedure
</h1>

<p>
Syntax:

</p><p>
#endprocedure

</p><p>
See also procedure (<a href="#preprocedure">3.41</a>), call
(<a href="#precall">3.9</a>)

</p><p>
Each procedure<a name="997"></a> must be terminated by an 
#endprocedure<a name="998"></a> instruction. If the procedure resides 
in its own file, the #endprocedure will cause the closing of the file. 
Hence any text that is in the file after the #endprocedure instruction 
will be ignored.

</p><p>
When control reaches the #endprocedure instruction, all (local) 
preprocessor variables<a name="999"></a> that were defined 
inside the procedure and all parameters of the call of the procedure will 
become undefined.

</p><p>

</p><h1><a name="SECTION004250000000000000000"></a>
<a name="preendswitch"></a>
<br>
#endswitch
</h1>

<p>
Syntax:

</p><p>
#endswitch

</p><p>
See also switch (<a href="#preswitch">3.55</a>),
        case (<a href="#precase">3.10</a>),
        break (<a href="#prebreak">3.7</a>),
        default (<a href="#predefault">3.16</a>)

</p><p>
This instruction marks the end<a name="1006"></a> of a 
#switch<a name="1007"></a> construction. After none or one of the cases of 
the #switch construction has been included in the control flow, reading 
will continue after the matching #endswitch instruction. Each #switch 
needs a #endswitch, unless a .end instruction is encountered first.

</p><p>

</p><h1><a name="SECTION004260000000000000000"></a>
<a name="preexchange"></a>
<br>
#exchange
</h1>

<p>
Syntax:

</p><p>
#exchange expr1,expr2

</p><p>
#exchange $var1,$var2

</p><p>
Exchanges<a name="1010"></a> the names of two 
expressions<a name="1011"></a>. This means that the contents of the 
expressions remain where they are. Hence the order in which the expressions 
are processed remains the same, but the name under which one has to refer 
to them has been changed.

</p><p>
In the variety with the dollar variables<a name="1012"></a> the contents of 
the variables are exchanged. This is not much work, because dollar 
variables reside in memory and hence only two pointers to the contents have 
to be exchanged (and some extra information about the contents).

</p><p>
This instruction can be very useful when sorting expressions or dollar 
variables by their contents.

</p><p>

</p><h1><a name="SECTION004270000000000000000"></a>
<a name="preexternal"></a>
<br>
#external
</h1>

<p>
Syntax:

</p><p>
#external ["prevar"] systemcommand

</p><p>
Starts the command<a name="1015"></a> in the background, 
connecting to its standard<a name="1016"></a><a name="1017"></a> 
input<a name="1018"></a> and output<a name="1019"></a>. By default, 
the #external command has no controlling terminal, the standard error stream 
is redirected to <code>/dev/null</code> and the command is run in a subshell in a 
new session and in a new process group (see the preprocessor instruction 
<code>#setexternalattr</code>).

</p><p>
The optional parameter ``prevar'' is the name of a preprocessor variable 
placed between double quotes. If it is present, the ``descriptor'' (small 
positive integer number) of the external command is stored into this 
variable and can be used for references to this external command (if there 
is more than one external command running simultaneously).

</p><p>
The external command that is started last becomes the ``current'' (active) 
external command.  All further instructions 
#fromexternal<a name="1020"></a> and #toexternal<a name="1021"></a> 
deal with the current external command.

</p><p>

</p><h1><a name="SECTION004280000000000000000"></a>
<a name="prefactdollar"></a>
<br>
#factdollar
</h1>

<p>
Syntax:

</p><p>
#factdollar $-variable

</p><p>
See also the chapters on polynomials <a href="#polynomials">10</a> and 
$-variables <a href="#dollars">6</a>

</p><p>
The #factdollar<a name="1026"></a> instruction causes the 
factorization of the indicated $-variable. After this instruction and 
until the $-variable is redefined there will be two versions of the 
variable: one is the original unfactorized version and the other is a list 
of factors. If the name of the variable is $a the factors can be accessed 
as <!-- MATH
 $\$a[1],\cdots,\$a[n]$
 -->
<img width="107" height="31" align="MIDDLE" border="0" src="./online_files/img27.png" alt="$\$a[1],\cdots,\$a[n]$">. The total number of factors is given by 
<img width="37" height="31" align="MIDDLE" border="0" src="./online_files/img28.png" alt="$\$a[0]$">. These factors can also be treated as preprocessor variables by 
putting them between quotes as in `<img width="37" height="31" align="MIDDLE" border="0" src="./online_files/img29.png" alt="$\$a[2]$">'.

</p><p>

</p><h1><a name="SECTION004290000000000000000"></a>
<a name="prefromexternal"></a>
<br>
#fromexternal
</h1>

<p>
Syntax:

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">] ["[$]varname" [maxlength]]

</p><p>
Appends<a name="1029"></a> the output of the current external 
command to the FORM program. The semantics differ depending on the optional 
arguments. After the external command sends the prompt<a name="1030"></a>, FORM 
will continue with a next line after the line containing the #fromexternal 
instruction. The prompt string is not appended. The optional <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"> or <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"> sign 
after the name has influence on the listing of the content. The varieties 
are:

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">]

</p><p>
The semantics is similar to the #include<a name="1031"></a> 
instruction but folders are not supported. 

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">] "[$]varname"

</p><p>
is used to read the text from the running external command into 
the preprocessor variable varname, or into the dollar variable $varname if 
the name of the variable starts with the dollar sign ``$''.

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">] "[$]varname" maxlength

</p><p>
is used to read the text from the running external command into 
the preprocessor (or dollar) variable varname. Only the first maxlength 
characters are stored.

</p><p>

</p><h1><a name="SECTION004300000000000000000"></a>
<a name="preif"></a>
<br>
#if
</h1>

<p>
Syntax:

</p><p>
#if ( condition )

</p><p>
See also endif (<a href="#preendif">3.22</a>),
            else (<a href="#preelse">3.19</a>),
            elseif (<a href="#preelseif">3.20</a>),
            ifdef (<a href="#preifdef">3.31</a>),
            ifndef (<a href="#preifndef">3.32</a>)

</p><p>
The #if<a name="1039"></a> instruction should be accompanied by a 
matching #endif<a name="1040"></a> instruction. In addition there can be 
between the #if and the #endif some #elseif<a name="1041"></a> instructions 
and/or a single #else<a name="1042"></a> instruction. The condition is a 
logical variable that is true if its value is not equal to zero, and false 
if its value is zero. Hence it is allowed to use
</p><pre>    #if `i'
        statements
    #endif
</pre>
provided that i has a value which can be interpreted as a number. If there 
is just a string that cannot be seen as a logical<a name="1045"></a> condition 
or a number it will be interpreted as false. The regular syntax of the 
simple condition is
<pre>    #if `i' == st2x
        statements
    #endif
</pre>
or
<pre>    #if ( `i' == st2x )
        statements
    #endif
</pre>
in which the compare is a numerical compare if both strings can be seen as 
numbers, while it will be a string compare if at least one of the two 
cannot be seen as a numerical object. One can also use more complicated 
conditions as in
<pre>    #if ( ( `i' &gt; 5 ) &amp;&amp; ( `j' &gt; `i' ) )
</pre>
These are referred to as composite conditions. The possible operators are
<dl>
<dt><strong><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>Greater than, either in numerical or in lexicographical sense.
</dd>
<dt><strong><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"></strong></dt>
<dd>Less than, either in numerical or in lexicographical sense.
</dd>
<dt><strong><img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img31.png" alt="$&gt;=$"></strong></dt>
<dd>Greater than or equal to, either in numerical or in 
lexicographical sense.
</dd>
<dt><strong><img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img32.png" alt="$&lt;=$"></strong></dt>
<dd>Less than or equal to, either in numerical or in 
lexicographical sense.
</dd>
<dt><strong><img width="29" height="15" align="BOTTOM" border="0" src="./online_files/img33.png" alt="$==$"> or <img width="17" height="15" align="BOTTOM" border="0" src="./online_files/img34.png" alt="$=$"></strong></dt>
<dd>Equal to.
</dd>
<dt><strong><img width="25" height="14" align="BOTTOM" border="0" src="./online_files/img35.png" alt="$!=$"></strong></dt>
<dd>Not equal to.
</dd>
<dt><strong><img width="29" height="14" align="BOTTOM" border="0" src="./online_files/img36.png" alt="$\&amp;\&amp;$"></strong></dt>
<dd>Logical and operator to combine conditions.
</dd>
<dt><strong><img width="13" height="31" align="MIDDLE" border="0" src="./online_files/img37.png" alt="$\vert\vert$"></strong></dt>
<dd>Logical or operator to combine conditions.
</dd>
</dl>

<p>
If the condition evaluates to true, the lines after the #if instruction 
will be read until the first matching #elseif instruction, or a #else 
instruction or a #endif instruction, whatever comes first. After such an 
instruction is encountered input reading stops and continues after the 
matching #endif instruction.

</p><p>
Like with the regular if-statement (see <a href="#substaif">7.63</a>), there are some special 
functions that allow the asking of questions about objects. These are

</p><p>
<table width="136">
<tbody><tr><td>exists()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of exists<a name="1427"></a> is the name of an 
expression or a $-variable. This function then returns one if this object 
exists, cq. has been defined. Otherwise it returns zero. </td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>isdefined()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of isdefined<a name="1440"></a> is the name of a 
preprocessor variable. This function then returns one if this object 
has been defined. Otherwise it returns zero. Technically <tt>#ifdef `VAR'</tt> 
and 
<tt>#if ( isdefined(VAR) )</tt> are the same. The isdefined function 
allows for greater flexibility in composite conditions.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>isfactorized()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of isfactorized<a name="1455"></a> is the 
name of an expression or a $-variable. This function then returns one if 
the object has been factorized. Otherwise it returns zero. </td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>isnumerical()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of isnumerical<a name="1468"></a> is the 
name of an expression or a $-variable. This function then returns one if 
the object contains a single term that is purely numerical in nature. 
Otherwise it returns zero. </td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>maxpowerof()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of maxpowerof<a name="1481"></a> is the name 
of a symbol. This function then evaluates into the maximum power of that 
symbol as it has been declared. If no maximum power has been set in the 
declaration of the symbol, the general maximum power for symbols is 
returned (see <a href="#substasymbols">7.130</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>minpowerof()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of minpowerof<a name="1495"></a> is the name 
of a symbol. This function then evaluates into the minimum power of that 
symbol as it has been declared. If no minimum power has been set in the 
declaration of the symbol, the general minimum power for symbols is 
returned (see <a href="#substasymbols">7.130</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>termsin()
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of termsin<a name="1509"></a> is the name of an 
expression or a $-variable. This function then evaluates into the number 
of terms in that expression.</td></tr>
</tbody></table>
    <br>

</p><p>

</p><h1><a name="SECTION004310000000000000000"></a>
<a name="preifdef"></a>
<br>
#ifdef
</h1>

<p>
Syntax:

</p><p>
#ifdef `prevar'

</p><p>
See also if (<a href="#preif">3.30</a>),
            endif (<a href="#preendif">3.22</a>),
            else (<a href="#preelse">3.19</a>),
            ifndef (<a href="#preifndef">3.32</a>)

</p><p>
If the named<a name="1093"></a> preprocessor variable has been 
defined the condition is true, else it is false. For the rest the 
instruction behaves like the #if<a name="1094"></a> instruction.

</p><p>
An alternative is to use the isdefined object inside the #if instruction.

</p><p>

</p><h1><a name="SECTION004320000000000000000"></a>
<a name="preifndef"></a>
<br>
#ifndef
</h1>

<p>
Syntax:

</p><p>
#ifndef `prevar'

</p><p>
See also if (<a href="#preif">3.30</a>),
            endif (<a href="#preendif">3.22</a>),
            else (<a href="#preelse">3.19</a>),
            ifdef (<a href="#preifdef">3.31</a>)

</p><p>
If the named<a name="1101"></a> preprocessor variable has been 
defined the condition is false, else it is true. For the rest the 
instruction behaves like the #if<a name="1102"></a> instruction.

</p><p>

</p><h1><a name="SECTION004330000000000000000"></a>
<a name="preinclude"></a>
<br>
#include
</h1>

<p>
Syntax:

</p><p>
#include[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img38.png" alt="$-+$">] filename

</p><p>
#include[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img38.png" alt="$-+$">] filename # foldname

</p><p>
The named<a name="1105"></a> file is searched for and opened. 
Reading<a name="1106"></a> continues from this file until its end. Then the 
file will be closed and reading continues after the #include instruction. 
If a foldname<a name="1107"></a> is specified, FORM will only read the 
contents of the first fold<a name="1108"></a> it encounters in the given file that 
has the specified name.

</p><p>
The file is searched for in the current directory, then in the path 
specified in the path<a name="1109"></a> variable in the setup file or at the 
beginning of the program (see chapter <a href="#setup">16</a> on the setup file). Next 
it will look in the path specified in the -p option when FORM is started 
(see the chapter on running FORM). If this option has not been used, FORM 
will look for the environment variable FORMPATH<a name="1111"></a>. If this 
variable exists it will be interpreted as a path and FORM will search the 
indicated directories for the given file. If none is found there will be an 
error message and execution will be halted.

</p><p>
The optional <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"> or <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"> sign after the name has influence on the listing of the 
contents of the file. A <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"> sign will have the effect of a #<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"> instruction 
during the reading of the file. A plus sign will have the effect of a #<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"> 
instruction during the reading of the file.

</p><p>
A fold is defined by a starting line of the format:
</p><pre>    *--#[ name :
</pre>
and a closing line of the format
<pre>    *--#] name :
</pre>
in which the first character is actually the current 
commentary<a name="1116"></a> character (see the #commentchar instruction). 
All lines between two such lines are considered to be the contents of the 
fold. If FORM decides that it needs this fold, it will read these contents 
and put them in its input stream. More about folds is explained in the 
manual of the STedi editor which is also provided in the FORM 
distribution.

<p>

</p><h1><a name="SECTION004340000000000000000"></a>
<a name="preinside"></a>
<br>
#inside
</h1>

<p>
Syntax:

</p><p>
#inside $var1 [more $variables]

</p><p>
See also #endinside (<a href="#preendinside">3.23</a>)

</p><p>
Used to<a name="1120"></a> execute a few statements on the contents 
of one or more dollar variables (see <a href="#dollars">6</a>) during compilation time.
Although this is a preprocessor instruction one can use the 
triple dot operator provided one uses the generic version with the <img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img39.png" alt="$&lt;&gt;$">.

</p><p>
The statements in the scope of the #inside / #endinside 
construction must be regular executable statements. They may not contain 
end-of-module instructions like the .sort instruction. It is allowed to use 
dollar variables, procedures and preprocessor do loops and if's, but it is 
not allowed to nest the #inside / #endinside constructions.

</p><p>

</p><h1><a name="SECTION004350000000000000000"></a>
<a name="premessage"></a>
<br>
#message
</h1>

<p>
Syntax:

</p><p>
#message themessagestring

</p><p>
This instruction places a message<a name="1124"></a> in the output 
that is clearly marked as such. It is printed with an initial three 
characters in front as in
</p><pre>    Symbols a,b,c;
    #message Simple example;
~~~Simple example;
    Local F = (a+b+c)^10;
    .end

Time =       0.00 sec    Generated terms =         66
                F        Terms in output =         66
                         Bytes used      =       1138
</pre>
Note that the semicolon<a name="1127"></a> is not needed and if present is 
printed as well. If one needs messages without this clear marking, one 
should use the #write<a name="1128"></a> instruction.

<p>

</p><h1><a name="SECTION004360000000000000000"></a>
<a name="preopendictionary"></a>
<br>
#opendictionary
</h1>

<p>
Syntax:

</p><p>
#opendictionary name

</p><p>
See chapter <a href="#dictionaries">13</a> on dictionaries.

</p><p>
Opens a dictionary and makes it ready for adding words to it. If 
the dictionary does not exist yet, it will be created.

</p><p>

</p><h1><a name="SECTION004370000000000000000"></a>
<a name="preoptimize"></a>
<br>
#optimize
</h1>

<p>
Syntax:

</p><p>
#optimize nameofoneexpression

</p><p>
See the chapter about optimization <a href="#optimization">11</a>

</p><p>

</p><h1><a name="SECTION004380000000000000000"></a>
<a name="prepipe"></a>
<br>
#pipe
</h1>

<p>
Syntax:

</p><p>
#pipe systemcommand

</p><p>
See also system (<a href="#presystem">3.56</a>)

</p><p>
This<a name="1138"></a> forces a system command to be executed by the 
operating system. The complete string (excluding initial blanks or tabs) is 
passed to the operating system. Next FORM will intercept the output of 
whatever is produced and read that as input. Hence, whenever output is 
produced FORM will take action, and it will wait when no output is ready. 
After the command has been finished, FORM will continue with the next line. 
This instruction has only been implemented on systems that support 
pipes<a name="1139"></a>. This is mainly UNIX<a name="1140"></a> and derived systems. 
Note that this instruction also introduces operating system dependent code. 
Hence it should be used with great care.

</p><p>

</p><h1><a name="SECTION004390000000000000000"></a>
<a name="prepreout"></a>
<br>
#preout
</h1>

<p>
Syntax:

</p><p>
#preout ON

</p><p>
#preout OFF

</p><p>
Turns<a name="1143"></a> listing of the output of the preprocessor 
to the compiler on or off. Example:
</p><pre>    #PreOut ON
    S   a1,...,a4;
 S,a1,a2,a3,a4
    L   F = (a1+...+a4)^2;
 L,F=(a1+a2+a3+a4)^2
    id  a4 = -a1;
 id,a4=-a1
    .end

Time =       0.00 sec    Generated terms =         10
                F        Terms in output =          3
                         Bytes used      =         52
</pre>

<p>

</p><h1><a name="SECTION004400000000000000000"></a>
<a name="preprinttimes"></a>
<br>
#printtimes
</h1>

<p>
Syntax:

</p><p>
#printtimes

</p><p>
Prints<a name="1148"></a> the current execution time and real 
time in the same way as done at the end of the program. Helps in monitoring 
the real time passed in TFORM jobs.
Example:
</p><pre>    #Printtimes
  423.59 sec + 5815.88 sec: 6239.47 sec out of 1215.29 sec
</pre>

<p>

</p><h1><a name="SECTION004410000000000000000"></a>
<a name="preprocedure"></a>
<br>
#procedure
</h1>

<p>
Syntax:

</p><p>
#procedure name(var1,...,varn)

</p><p>
See also endprocedure (<a href="#preendprocedure">3.24</a>), call
(<a href="#precall">3.9</a>)

</p><p>
Name<a name="1155"></a> is the name of the 
procedure<a name="1156"></a>. It will be referred to by this name. If the 
procedure resides in a separate file the name of the file should be 
name.prc and the #procedure instruction should form the first line of the 
file. The # should be the first character of the file. The parameter field 
is optional. If there are no parameters, the procedure should also be 
called without parameters (see the #call instruction). The parameters 
(here called var1 to varn) are preprocessor variables and hence they should 
be referred to between a backquote<a name="1157"></a>/quote<a name="1158"></a> pair 
as in `var1' to `varn'. If there exist already variables with such names 
when the procedure is called, the new definition comes on top of the old 
one. Hence in the procedure (and procedures called from it, unless the same 
problems occurs there too, as would be the case with recursions) the new 
definition is used, and it is released again when control returns from the 
procedure. After that the old definition will be in effect again.

</p><p>
If the procedure is included in the regular input stream, FORM will read 
the text of the procedure until the #endprocedure<a name="1159"></a> 
instruction and store it in a special buffer. When the procedure is called, 
FORM will read the procedure from this buffer, rather than from a file. In 
systems where file transfer is slow (very busy server with a slow network) 
this may be faster, especially when many small procedures are called.

</p><p>
One way to make libraries<a name="1160"></a><a name="1161"></a> that 
contain many procedures and maybe more code is to put all procedures into 
one header (.h) file and include this file at the beginning of the program 
with a #include<a name="1162"></a> instruction. This way one has all 
procedures load and one knows for sure that it are the proper procedures as 
it guards against the inadvertently picking up of procedures from other 
directories. It also makes for fewer files and hence makes for better 
housekeeping.

</p><p>

</p><h1><a name="SECTION004420000000000000000"></a>
<a name="preprocedureextension"></a>
<br>
#procedureextension
</h1>

<p>
Syntax:

</p><p>
#procedureextension string

</p><p>
See also #call (<a href="#precall">3.9</a>)

</p><p>
The default<a name="1166"></a> extension of procedures 
is .prc<a name="1167"></a> in FORM. It is however possible that this clashes with 
the extensions used by other programs like the Grace<a name="1168"></a> system 
(Yuasa et al, Prog. Theor. Phys. Suppl. 138(2000)18 ). In that case it is 
possible to change the extension of the procedures in the current program. 
This is either done via the setup (page <a href="#setup">16</a>) or by the 
#procedureextension instruction of the preprocessor. The new string 
replaces the string prc, used by default. For the new string the following 
restrictions hold:

</p><ol>
<li>The first character must be alphabetic
</li>
<li>No whitespace characters (blanks and/or tabs) are allowed
</li>
</ol>
For the rest any characters can be used.

<p>
The new extension will remain valid either till the next 
#procedureextension instruction or to the next .clear<a name="1172"></a> 
instruction (page <a href="#instrclear">4</a>), whatever comes first.

</p><p>

</p><h1><a name="SECTION004430000000000000000"></a>
<a name="preprompt"></a>
<br>
#prompt
</h1>

<p>
Syntax:

</p><p>
#prompt [newprompt]

</p><p>
Sets a new prompt<a name="1176"></a> for the current external 
command (if present) and all further (newly started) external commands.

</p><p>
If newprompt is an empty string, the default prompt (an empty line) will be 
used.

</p><p>
The prompt<a name="1177"></a> is a line consisting of a single prompt string. By 
default, this is an empty string.

</p><p>

</p><h1><a name="SECTION004440000000000000000"></a>
<a name="preredefine"></a>
<br>
#redefine
</h1>

<p>
Syntax:

</p><p>
#redefine name "string"

</p><p>
See also define (<a href="#predefine">3.17</a>), undefine 
(<a href="#preundefine">3.59</a>)

</p><p>
in which<a name="1182"></a> name refers to the name of the 
preprocessor<a name="1183"></a> 
variable<a name="1184"></a> to be redefined. The contents of the 
string will be its new value. If no variable of the given name exists yet, 
the instruction will be equivalent to the #define<a name="1185"></a> 
instruction.

</p><p>

</p><h1><a name="SECTION004450000000000000000"></a>
<a name="preremove"></a>
<br>
#remove
</h1>

<p>
Syntax:

</p><p>
#remove <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">filename<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">

</p><p>
See also write (<a href="#prewrite">3.61</a>), append (<a href="#preappend">3.6</a>),
            create (<a href="#precreate">3.15</a>), close (<a href="#preclose">3.12</a>)

</p><p>
Deletes<a name="1192"></a> the named file from the system. Under 
UNIX<a name="1193"></a> this would be equivalent to the instruction
</p><pre>    #system rm filename
</pre>
and under MS-DOS<a name="1196"></a> oriented systems like Windows<a name="1197"></a> 
it would be equivalent to
<pre>    #system del filename
</pre>
The difference with the #system<a name="1200"></a> instruction is that the 
#remove<a name="1201"></a> instruction does not depend on the particular 
syntax of the operating system. Hence the #remove instruction can always 
be used.

<p>

</p><h1><a name="SECTION004460000000000000000"></a>
<a name="prereset"></a>
<br>
#reset
</h1>

<p>
Syntax:

</p><p>
#reset [<tt>&lt;</tt>keyword<tt>&gt;</tt>]

</p><p>
See also `TIMER_' preprocessor variable.

</p><p>
Currently the only keywords that are allowed are timer and 
stopwatch. They have the same effect, which is to reset the timer for the 
`timer_' (or `stopwatch_) preprocessor variable (see <a href="#preprovariables">3.1</a>).

</p><p>

</p><h1><a name="SECTION004470000000000000000"></a>
<a name="prereverseinclude"></a>
<br>
#reverseinclude
</h1>

<p>
Syntax:

</p><p>
#reverseinclude[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img38.png" alt="$-+$">] filename

</p><p>
#reverseinclude[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img38.png" alt="$-+$">] filename # foldname

</p><p>
This instruction is identical to the #include <a href="#preinclude">3.33</a> 
instruction, with the exception that the statements and instructions in the 
file are read in reverse order. This can be useful at times when code is 
generated in a particular order in a file and one would like to 'undo' this 
code. It is somewhat related to the effects of the debugflag option 
(<a href="#optimdebugflag">11.0.1</a>) in the optimization options of the format statement 
<a href="#optimization">11</a>.

</p><p>
There are a few limitations. If, for instance, linefeeds or semicolons 
occur inside preprocessor variables, the reading routines cannot see this. 
Additionally unfinished strings (unmatched double quotes) will result in 
a fatal error. On the other hand the fold structure remains preserved.

</p><p>

</p><h1><a name="SECTION004480000000000000000"></a>
<a name="prermexternal"></a>
<br>
#rmexternal
</h1>

<p>
Syntax:

</p><p>
#rmexternal [n]

</p><p>
Terminates<a name="1214"></a> an external command. The integer 
number n must be either the descriptor of a running external command, or 0.

</p><p>
If n is 0, then all external programs will be terminated.

</p><p>
If n is not specified, the current external command will be terminated.

</p><p>
The action of this instruction depends on the attributes of the external 
channel (see the #setexternalattr<a name="1215"></a> (section 
<a href="#setexternalcommunication">18.5</a>) instruction). By default, the instruction 
closes the commands' IO channels, sends a KILL<a name="1217"></a> signal to 
every process in its process group and waits for the external command to be 
finished.

</p><p>

</p><h1><a name="SECTION004490000000000000000"></a>
<a name="prermseparator"></a>
<br>
#rmseparator
</h1>

<p>
Syntax:

</p><p>
#rmseparator character

</p><p>
See also #addseparator (<a href="#preaddseparator">3.5</a>),
            #call (<a href="#precall">3.9</a>), #do (<a href="#predo">3.18</a>)

</p><p>
Removes a character<a name="1223"></a> from the list of permissible 
separator characters for arguments of #call or #do instructions. By 
default the two characters that are permitted are the comma and the 
character <code>|</code>. Blanks, tabs and double quotes are ignored. Note that 
the comma must be specified between double quotes as in
</p><pre>  #rmseparator ","
</pre>

<p>

</p><h1><a name="SECTION004500000000000000000"></a>
<a name="presetexternal"></a>
<br>
#setexternal
</h1>

<p>
Syntax:

</p><p>
#setexternal n

</p><p>
Sets<a name="1228"></a> the ``current'' external command. The 
instructions #toexternal<a name="1229"></a> and 
#fromexternal<a name="1230"></a> deal with the current external 
command.  The integer number n must be the descriptor of a running external 
command.

</p><p>

</p><h1><a name="SECTION004510000000000000000"></a>
<a name="presetexternalattr"></a>
<br>
#setexternalattr
</h1>

<p>
Syntax:

</p><p>
#setexternalattr list_of_attributes

</p><p>
sets<a name="1233"></a> attributes for <em>newly started</em> 
external commands. Already running external commands are not affected. The 
list of attributes is a comma separated list of pairs attribute=value, 
e.g.:
</p><pre>   #setexternalattr shell=noshell,kill=9,killall=false
</pre>
Possible attributes are:
<dl>
<dt><strong>kill<a name="1238"></a></strong></dt>
<dd>specifies the signal to be sent to the external command 
either before the termination of the FORM program or by the preprocessor 
instruction <code>#rmexternal</code>. By default this is 9 (
SIGKILL<a name="1239"></a>). Number 0 means that no signal will be sent.
</dd>
<dt><strong>killall<a name="1240"></a></strong></dt>
<dd>Indicates whether the kill signal will be sent to the whole 
group or only to the initial process. Possible values are ``<code>true</code>'' 
and ``<code>false</code>''. By default, the kill signal will be sent to the
whole group.
</dd>
<dt><strong>daemon<a name="1241"></a></strong></dt>
<dd>Indicates whether the command should be ``daemonized'', i.e. 
the initial process will be passed to the init process and will belong
to the new process group in the new session.  
Possible values are ``<code>true</code>'' and ``<code>false</code>''. By default, 
``<code>true</code>''.
</dd>
<dt><strong>shell<a name="1242"></a></strong></dt>
<dd>specifies which shell<a name="1243"></a> is used to run a
command. (Starting an external command in a subshell permits to
start not only executable files but also scripts<a name="1244"></a> and 
pipelined<a name="1245"></a> jobs. The disadvantage is that there is no 
way to detect failure upon startup since usually the shell is started 
successfully.) By default this is ``<code>/bin/sh -c</code>''.  If set 
<code>shell=noshell</code>, the command will be stared by the instruction 
#external<a name="1246"></a> directly but not in a subshell, so the command 
should be a name of the executable file rather than a system command. The 
instruction #external will duplicate the actions of the shell in searching 
for an executable file if the specified file name does not contain a slash 
(/) character.  The search path is the path specified in the environment by 
the PATH<a name="1247"></a> variable.  If this variable isn't specified, the 
default path ``<code>:/bin:/usr/bin</code>''
is used.
</dd>
<dt><strong>stderr<a name="1248"></a></strong></dt>
<dd>specifies a file to redirect the standard<a name="1249"></a> error 
stream to. By default it is ``<code>/dev/null</code>''. If set 
<code>stderr=terminal</code>, no redirection occurs.
</dd>
</dl>
Only attributes that are explicitly mentioned are changed, all others remain 
unchanged. Note, changing attributes should be done with care. For example,
<pre>   #setexternalattr daemon=false
</pre>
starts a command in the subshell within the current process group with
default attributes kill=9 and killall=true.
The instruction #rmexternal<a name="1253"></a> sends the
KILL<a name="1254"></a> signal to the wholegroup, which means that also 
FORM itself will be killed.

<p>

</p><h1><a name="SECTION004520000000000000000"></a>
<a name="presetrandom"></a>
<br>
#setrandom
</h1>

<p>
Syntax:

</p><p>
#setrandom number

</p><p>
See also random_ (<a href="#funrandom">8.50</a>) and ranperm_ (<a href="#funranperm">8.51</a>)

</p><p>
The #setrandom<a name="1259"></a> instruction initializes the 
random number generator 
random_<a href="#funrandom" name="1261">8.50</a><a name="1262"></a>. The 
number that is used as a seed can have the length of two words in FORM. 
This means that on a 32-bits computer it can be an (unsigned) 32-bits 
integer and on a 64-bits computer it can be an (unsigned) 64 bits integer. 
If there is no #setrandom instruction the random number generator is 
initialized in a built in standard way. The #setrandom instruction also 
initializes the random number generators of the workers when one uses TFORM 
or ParFORM. They are initialized with different seeds that are derived in a 
non-trivial way from the seed given by the user and the number of the 
worker.

</p><p>

</p><h1><a name="SECTION004530000000000000000"></a>
<a name="preshow"></a>
<br>
#show
</h1>

<p>
Syntax:

</p><p>
#show [preprocessorvariablename[s]]

</p><p>
If no names<a name="1265"></a> are present, the contents of all 
preprocessor variables<a name="1266"></a> will be printed to the 
regular output. If one or more preprocessor variables are specified 
(separated by comma's), only their contents will be printed. The 
preprocessor variables should be represented by their name only. No 
enclosing backquote/quote should be used, because that would force a 
substitution of the preprocessor variable before the instruction gets to 
see the name. Example:
</p><pre>    #define MAX "3"
    Symbols a1,...,a`MAX';
    L F = (a1+...+a`MAX')^2;
    #show
#The preprocessor variables:
0: VERSION_ = "3"
1: SUBVERSION_ = "2"
2: NAMEVERSION_ = ""
3: DATE_ = "Wed Feb 28 08:43:20 2007"
4: NAME_ = "testpre.frm"
5: CMODULE_ = "1"
6: MAX = "3"
    .end

Time =       0.00 sec    Generated terms =          6
                F        Terms in output =          6
                         Bytes used      =        102
</pre>
We see that the variable MAX has indeed the value 3. There are six 
additional variables which have been defined by FORM itself. Hence the 
trailing underscore which cannot be used in user defined names. The current 
version of FORM is shown in the variable VERSION_<a name="1269"></a> and the 
name of the current program is given in the variable NAME_<a name="1270"></a>. 
For more about the system defined preprocessor variables see 
<a href="#preprovariables">3.1</a>.

<p>
There is another preprocessor variable that does not show in the listings. 
Its name is SHOWINPUT_<a name="1272"></a>. This variable has the value one 
if the listing of the input is on and the value zero if the listing of the 
input is off.

</p><p>

</p><h1><a name="SECTION004540000000000000000"></a>
<a name="preskipextrasymbols"></a>
<br>
#skipextrasymbols
</h1>

<p>
Syntax:

</p><p>
#skipextrasymbols positivenumber

</p><p>
See also ExtraSymbols(<a href="#substaextrasymbols">7.45</a>) and the chapter 
on optimization(<a href="#optimization">11</a>).

</p><p>
This instructions adds a number of dummy extra 
symbols<a name="1277"></a> to the list of extra 
symbols(<a href="#substaextrasymbols">7.45</a>). This can be used when several 
optimizations are done on an expression in such a way that the extra 
symbols of previous optimizations are still present. Normally the number 
space for them is erased in a #clearoptimize instruction. This can be 
avoided with a sequence like
</p><pre>	#skipextrasymbols,{`optimmaxvar_'-`optimminvar_'+1}
</pre>
In this case the numbering of the next optimization will start after the 
last extra symbol of the previous optimization.
One should realize however that the definitions of the extra symbols are 
not kept once the new optimization is started or once a #clearoptimize 
instruction is issued. Example:
<pre>   #-
   S   a,b,c,d,e;
   L   F = (a+b+c+d+3*e)^3;
   B   b;
   .sort
   ExtraSymbols,array,w;
   Format O3,stats=ON;
   #optimize F
   #write &lt;&gt; "  %4O"
   .sort
   #SkipExtraSymbols,{`optimmaxvar_'-`optimminvar_'+1}
   id  b = b+1;
   Print +f;
   B   b;
   .end
</pre>
Because the O3 format is still active, the final printing uses the 
optimization as well. If the #SkipExtraSymbols instruction would have been 
omitted, the numbering would start again from one, while the rhs. of their 
definitions would contain the old extra symbols. The result would be 
incorrect.

<p>

</p><h1><a name="SECTION004550000000000000000"></a>
<a name="preswitch"></a>
<br>
#switch
</h1>

<p>
Syntax:

</p><p>
#switch string

</p><p>
See also endswitch (<a href="#preendswitch">3.25</a>),
        case (<a href="#precase">3.10</a>),
        break (<a href="#prebreak">3.7</a>),
        default (<a href="#predefault">3.16</a>)

</p><p>
the<a name="1289"></a> string could for instance be a preprocessor 
variable as in
</p><pre>    #switch `i'
</pre>
The #switch<a name="1292"></a> instruction, together with 
#case<a name="1293"></a>, #break<a name="1294"></a>, #default<a name="1295"></a> 
and #endswitch<a name="1296"></a>, allows the user to conveniently make 
code for a number of cases that are distinguished by the value of a 
preprocessor variable. In the past this was only possible with the use of 
folds<a name="1297"></a> in the #include<a name="1298"></a> instruction and the 
corresponding include file<a name="1299"></a> (see <a href="#preinclude">3.33</a>). 
Because few people have an editor like STedi (see the FORM distribution 
site) that can handle the folds in a proper way, it was judged that the 
more common switch mechanism might be friendlier. The proper syntax of a 
complete construction would be
<pre>    #switch `par'
    #case 1
       some statements
    #break
    #case ax2
       other statements
    #break
    #default
       more statements
    #break
    #endswitch
</pre>
The number of cases is not limited. The compare between the strings in the 
#switch instruction and in the #case instructions is as a text string. 
Hence numerical strings have no special meaning. If a #break instruction 
is omitted, control may go into another case. This is called 
fall-through<a name="1303"></a>. 
This is a way in which one can have the same statements for several cases. 
The #default instruction is not mandatory.

<p>
FORM will look for the first case of which the string matches the string 
in the #switch instruction. Input reading (control flow) starts after this 
#case instruction, and continues till either a #break instruction is 
encountered, or the #endswitch is met. After that input reading continues 
after the #endswitch instruction. If no case has a matching string, input 
reading starts after the #default instruction. If no #default instruction 
is found, input reading continues after the matching #endswitch 
instruction.

</p><p>
#switch constructions can be nested<a name="1304"></a>. They can be combined 
with #if<a name="1305"></a> constructions, #do<a name="1306"></a> instructions, etc. 
but they should obey normal nesting rules (as with nesting of 
brackets<a name="1307"></a> of different types).

</p><p>

</p><h1><a name="SECTION004560000000000000000"></a>
<a name="presystem"></a>
<br>
#system
</h1>

<p>
Syntax:

</p><p>
#system systemcommand

</p><p>
See also pipe (<a href="#prepipe">3.38</a>)

</p><p>
This forces a system<a name="1311"></a> command to be executed by 
the operating system. The complete string (excluding initial blanks or 
tabs) is passed to the operating system. FORM will then wait until control 
is returned. Note that this instruction introduces operating system 
dependent code. Hence it should be used with great care.

</p><p>

</p><h1><a name="SECTION004570000000000000000"></a>
<a name="preterminate"></a>
<br>
#terminate
</h1>

<p>
Syntax:

</p><p>
#terminate [exitcode]

</p><p>
This forces FORM to terminate<a name="1314"></a> execution 
immediately. If an exit code is given (an integer number), this will be the 
return value that FORM gives to the shell program from which it was run. If 
no return value is specified, the value -1 will be returned.

</p><p>

</p><h1><a name="SECTION004580000000000000000"></a>
<a name="pretoexternal"></a>
<br>
#toexternal
</h1>

<p>
Syntax:

</p><p>
#toexternal "formatstring" <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">,variables<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">

</p><p>
Sends<a name="1317"></a> the output to the current external 
command. The semantics of the <code>"formatstring"</code> and the
<code>[,variables]</code> is the same as for the #write<a name="1318"></a> 
instruction, except for the trailing end-of-line symbol. In contrast to the 
#write instruction, the #toexternal instruction does not append any new 
line symbol to the end of its output.

</p><p>

</p><h1><a name="SECTION004590000000000000000"></a>
<a name="preundefine"></a>
<br>
#undefine
</h1>

<p>
Syntax:

</p><p>
#undefine name

</p><p>
See also define (<a href="#predefine">3.17</a>), redefine 
(<a href="#preredefine">3.44</a>)

</p><p>
<a name="1323"></a> Name refers to the name of the 
preprocessor variable<a name="1324"></a> to be undefined. This 
statement causes the given preprocessor variable to be removed from the 
stack of preprocessor variables. If an earlier instance of this variable 
existed (other variable with the same name), it will become active again. 
There are various other ways by which preprocessor variables can become 
undefined. All variables belonging to a procedure are undefined at the end 
of a procedure, and so are all other preprocessor variables that were 
defined inside this procedure. The same holds for the preprocessor variable 
that is used as a loop parameter in the #do<a name="1325"></a> instruction.

</p><p>

</p><h1><a name="SECTION004600000000000000000"></a>
<a name="preusedictionary"></a>
<br>
#usedictionary
</h1>

<p>
Syntax:

</p><p>
#usedictionary name
#usedictionary name (options)

</p><p>
See chapter <a href="#dictionaries">13</a> on dictionaries.

</p><p>
Starts using a dictionary for output translation.

</p><p>

</p><h1><a name="SECTION004610000000000000000"></a>
<a name="prewrite"></a>
<br>
#write
</h1>

<p>
Syntax:

</p><p>
#write [<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">filename<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">] "formatstring" [,variables]

</p><p>
See also append (<a href="#preappend">3.6</a>),
            create (<a href="#precreate">3.15</a>), remove (<a href="#preremove">3.45</a>),
            close (<a href="#preclose">3.12</a>)

</p><p>
If there<a name="1335"></a> is no file specified, the output will be 
to the regular output<a name="1336"></a> channel. If a file is 
specified, FORM will look whether this file is open already. If it is open 
already, the specified output will be added to the file. If it is not open 
yet it will be opened. Any previous contents will be lost. This would be 
equivalent to using the #create<a name="1337"></a> instruction first. If 
output has to be added to an existing file, the #append<a name="1338"></a> 
instruction should be used first.

</p><p>
The format<a name="1339"></a> string is like a format string in the 
language C<a name="1340"></a>. This means 
that it is placed between double quotes. It will contain text that will be 
printed, and it will contain special character sequences for special 
actions. These sequences and the corresponding actions are:
</p><dl>
<dt><strong><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img40.png" alt="$\backslash$">n</strong></dt>
<dd>A newline<a name="1342"></a> character.
</dd>
<dt><strong><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img40.png" alt="$\backslash$">t</strong></dt>
<dd>A tab<a name="1343"></a> character.
</dd>
<dt><strong><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img40.png" alt="$\backslash$">"</strong></dt>
<dd>A double<a name="1344"></a> quote character.
</dd>
<dt><strong><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img40.png" alt="$\backslash$">b</strong></dt>
<dd>A backslash<a name="1345"></a> character.
</dd>
<dt><strong>%%</strong></dt>
<dd>The character %<a name="1346"></a>.
</dd>
<dt><strong>%</strong></dt>
<dd>If the last character in the string, it causes the omission of a 
linefeed<a name="1347"></a> at the end of the printing. Note that if this 
happens in the regular output (as opposed to a file) there may be 
interference with the listing of the input.
</dd>
<dt><strong>%$</strong></dt>
<dd>A dollar variable<a name="1348"></a>. The variable should be 
indicated in the list of variables. Each occurrence of %$ will look for 
the next variable.
</dd>
<dt><strong>%e</strong></dt>
<dd>An active expression<a name="1349"></a>. The expression should be 
indicated in the list of variables. Each occurrence of %e will look for 
the next variable. Unlike the output caused by the print statement the 
expression will be printed without its name and there will also be no 
<code>=</code> sign unless there is one in the format string of course. If the 
current output format is fortran<a name="1350"></a> output there is an extra option. After the 
name of the expression one should put between parentheses the name to be 
used when there are too many continuation cards.
</dd>
<dt><strong>%E</strong></dt>
<dd>Like %e, but whereas the %e terminates the expression with a 
;, the %E does not give this trailing semicolon<a name="1351"></a>.
</dd>
<dt><strong>%s</strong></dt>
<dd>A string<a name="1352"></a>. The string should be 
given in the list of variables and be enclosed between double quotes. Each 
occurrence of %s will look for the next variable in the list.
</dd>
<dt><strong>%f</strong></dt>
<dd>A file<a name="1353"></a>. The name of the file will be expected in the 
list of variables. The file is searched for in the current directory, then 
in path indicated by the path variable in the setup file or at the 
beginning of the file (see chapter <a href="#setup">16</a> on the setup file), then in 
the path specified in the -p option when FORM is started (see the chapter 
on running FORM). If this option has not been used, FORM will look for the 
environment variable FORMPATH<a name="1355"></a>. If this variable exists it 
will be interpreted as a path and FORM will search the indicated 
directories for the given file. If none is found there will be an error 
message and execution will be halted.
</dd>
<dt><strong>%X</strong></dt>
<dd>Forces the printing of the list of extra symbols 
(<a href="#sect-extrasymbols">2.11</a>) and their definitions<a name="1357"></a>.
</dd>
<dt><strong>%O</strong></dt>
<dd>Forces the printing of the definitions of the extra symbols in 
the buffer with the temporary variables from the previous optimization (see 
the chapter on optimizations <a href="#optimization">11</a>). 
</dd>
</dl>
If no special variables are asked for (by means of %$, %e, %E or %s) 
the list of variables will be ignored (if present). Example:
<pre>    Symbols a,b;
    L   F = a+b;
    #$a1 = a+b;
    #$a2 = (a+b)^2;
    #$a3 = $a1^3;
    #write " One power: %$\n Two powers: %$\n Three powers: %$\n%s"\
           ,$a1,$a2,$a3," The end"
 One power: b+a
 Two powers: b^2+2*a*b+a^2
 Three powers: b^3+3*a*b^2+3*a^2*b+a^3
 The end
    .end

Time =       0.00 sec    Generated terms =          2
                F        Terms in output =          2
                         Bytes used      =         32
</pre>
We see that the writing occurs immediately after the #write<a name="1362"></a> 
instruction, because it is done by the preprocessor. Hence the output comes 
before the execution of the expression F.
<pre>    S   x1,...,x10;
    L   MyExpression = (x1+...+x10)^4;
    .sort
    Format Fortran;
    #write &lt;fun.f&gt; "      FUNCTION fun(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)"
    #write &lt;fun.f&gt; "      REAL x1,x2,x3,x4,x5,x6,x7,x8,x9,x10"
    #write &lt;fun.f&gt; "      fun = %e",MyExpression(fun)
    #write &lt;fun.f&gt; "      RETURN"
    #write &lt;fun.f&gt; "      END"
    .end
</pre>
Some remarks are necessary here. Because the #write is a preprocessor 
instruction, the .sort<a name="1365"></a> is essential. Without it, the 
expression has not been worked out at the moment we want to write. The name 
of the expression is too long for fortran<a name="1366"></a>, and hence the 
output file will use a different name (in this case the name `fun' was 
selected). The output file looks like
<pre>      FUNCTION fun(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
      REAL x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
      fun = 24*x1*x2*x3*x4 + 24*x1*x2*x3*x5 + 24*x1*x2*x3*x6 + 24*x1*x2
     &amp; *x3*x7 + 24*x1*x2*x3*x8 + 24*x1*x2*x3*x9 + 24*x1*x2*x3*x10 + 12*
          .....
     &amp; x8 + 4*x6**3*x9 + 4*x6**3*x10 + x6**4 + 24*x7*x8*x9*x10 + 12*x7*
     &amp; x8*x9**2
      fun = fun + 12*x7*x8*x10**2 + 12*x7*x8**2*x9 + 12*x7*x8**2*x10 + 
     &amp; 4*x7*x8**3 + 12*x7*x9*x10**2 + 12*x7*x9**2*x10 + 4*x7*x9**3 + 4*
     &amp; x7*x10**3 + 12*x7**2*x8*x9 + 12*x7**2*x8*x10 + 6*x7**2*x8**2 + 
     &amp; 12*x7**2*x9*x10 + 6*x7**2*x9**2 + 6*x7**2*x10**2 + 4*x7**3*x8 + 
     &amp; 4*x7**3*x9 + 4*x7**3*x10 + x7**4 + 12*x8*x9*x10**2 + 12*x8*x9**2
     &amp; *x10 + 4*x8*x9**3 + 4*x8*x10**3 + 12*x8**2*x9*x10 + 6*x8**2*
     &amp; x9**2 + 6*x8**2*x10**2 + 4*x8**3*x9 + 4*x8**3*x10 + x8**4 + 4*x9
     &amp; *x10**3 + 6*x9**2*x10**2 + 4*x9**3*x10 + x9**4 + x10**4

      RETURN
      END
</pre>
and each time after 19 continuation lines we have to break the expression 
and use the <code>fun = fun +</code> trick to continue.

<p>

</p><h1><a name="SECTION004620000000000000000">
Some remarks</a>
</h1>
It should be noted that the various constructions like 
#do<a name="1370"></a>/#enddo<a name="1371"></a>, 
#procedure<a name="1372"></a>/#endprocedure<a name="1373"></a>, 
#switch<a name="1374"></a>/#endswitch<a name="1375"></a> and 
#if<a name="1376"></a>/#endif<a name="1377"></a> all 
create a certain environment. These environments cannot be interweaved. This 
means that one cannot make code of the type
<pre>     #do i = 1,5
      #if ( `MAX' &gt; `i' )
         id f(`i') = g`i'(x);
     #enddo
      some statements
     #do i = 1,5
      #endif
     #enddo
</pre>
whether this could be considered useful or not. Similarly one cannot make a 
construction that might be very useful:
<pre>     #do i = 1,5
       #do j`i' = 1,3
     #enddo
       some statements
     #do i = 1,5
       #enddo
     #enddo
</pre>
Currently the syntax does not allow this. This may change in the future.

<p>

</p><p>

</p><h1><a name="SECTION00500000000000000000"></a>
<a name="modules"></a>
<br>
Модули
</h1>

<p>
Модули<a name="2421"></a> это базовые блоки выполнения<a name="2422"></a>. 
Конструкции всегда являются частью модуля<a name="2423"></a>, 
и они будут выполняться только когда будет выполняться модуль. 
Это рпямо противоположно инструкциям препроцессора, 
которые выполняются сразу, как только встречаются во входном потоке.

</p><p>
Модули заканчиваются строкой, которая начинается с точки<a name="2424"></a>. 
Эта строка называется инструкцией модуля<a name="2425"></a>. 
Как только будет распознана инструкция модуля, 
будет прервана компиляция модуля и модуль начнет выполняться. 
Все активные выражения будут обрабатываться одна за другой, терм за термом. 
Когда каждый терм выражения пройдет через все конструкции модуля, 
скомбинированные результаты всех операций на всех термах выражения 
будут отсортированы и результирующее выражение будет послано на вывод. 
Это может быть некоторый временный файл<a name="2426"></a>, 
или это может быть некоторая память<a name="2427"></a>, 
в зависимости от размера вывода. 
Если скомбинированный вывод всех активных выражений меньше, 
чем параметр ``ScratchSize''<a name="2428"></a>, результаты остануться в памяти. 
ScratchSize это один из настроечных параметров (см. главу <a href="#setup">16</a>).

</p><p>
Содуль состоит в общем из различных типов конструкций:
</p><dl>
<dt><strong>Объявления<a name="2431"></a></strong></dt>
<dd>Это объявления переменных.
</dd>
<dt><strong>Спецификации<a name="2432"></a></strong></dt>
<dd>Это говорит, что наде сделать с существующими выражениями в целом.
</dd>
<dt><strong>Определения<a name="2433"></a></strong></dt>
<dd>Здесь определяются новые выражения.
</dd>
<dt><strong>Исполняемые<a name="2434"></a> конструкции</strong></dt>
<dd>Операции на всех активных выражениях.
</dd>
<dt><strong>Спецификации вывода<a name="2435"></a></strong></dt>
<dd>Задают представление вывода.
</dd>
<dt><strong>Спецификации конца модуля<a name="2436"></a></strong></dt>
<dd>Дополнительные настройки, которые предназначены только для этого модуля.
</dd>
<dt><strong>Смешанные конструкции<a name="2437"></a></strong></dt>
<dd>Они могут появляться в различных классах. Особенно в конструкциях печати.
</dd>
</dl>
Конструкции обязаны появаляться в таком порядке, 
что нет конструкций, следующих за конструкцией последующей категории. 
Существуют исключения только для смешанных конструкций, которые могут появляться везде. 
Это отличается от ранних версий FORM-а, в которых порядок конструкций не был фиксированным. 
Это вызывает некоторое количество смущения при работе с FORM-ом.

<p>
Существует несколько типов модулей.
</p><dl>
<dt><strong>.sort<a name="2440"></a></strong></dt>
<dd><a name="instrsort"></a> The general end-of-module. 
Вызывает выполнение всех активных выражений, и подготавливает их для следующего модуля.
</dd>
<dt><strong>.end<a name="2442"></a></strong></dt>
<dd><a name="instrend"></a> Выполняются все активные выражения и программа останавливается.
</dd>
<dt><strong>.store<a name="2444"></a></strong></dt>
<dd><a name="instrstore"></a> Выполняются все активные выражения. 
Затем записываются все активные глобальные выражения в промежуточный накопительный файл<a name="2446"></a> 
и удаляются все другие не глобальные выражения. 
Удаляется вся память объявлений, за исключением тех, которые были сделаны перед инструкцией .global.
</dd>
<dt><strong>.global<a name="2447"></a></strong></dt>
<dd><a name="instrglobal"></a> Выражения не выполняются. 
Просто сохраняются объявления, сделанные до сих пор от стирания инструкцией .store.
</dd>
<dt><strong>.clear<a name="2449"></a></strong></dt>
<dd><a name="instrclear"></a> Выполняет все активные выражения. 
Затем он очищает все буферы, за исключением основного потока ввода. 
Выполнение главного потока ввода продолжается, как если бы программа начала выполняться с этой точки. 
Параметры, которые не могут измениться в этой точке - это только настроечные параметры. Они остаются. 
По умолчанию часы также<a name="2451"></a> обнуляются. 
Если это не нужно, может быть изменео значение настроечной переменной ResetTimeOnClear<a name="2452"></a> 
(см. главу <a href="#setup">16</a>).
</dd>
</dl>
Каждая программа должна завершаться инструкцией .end. 
Если такая инструкция отсутствует и FORM встретил конец файла, 
он выдаст предупреждение и сгенерирует инструкцию .end.

<p>
Инструкции модуля могут содержать специальные комментарии, 
которые будут напечатаны во всей статистике, которая ненерируется в процессе выполнения модуля. 
Этот специальный комментарий ограничен 24-мя символами 
(статистика имеет фиксированный формат, и следовательно доступно только ограниченное количество пространства). 
Этот комментарий начинается с двоеточия и заканчивается точкой с запятой. 
Символы между двоеточием и точкой с запятой это специальное сообщение, также называемое рекламой. 
Пример
</p><pre>	.sort:Eliminate x;
</pre>
даст статистику наподобие
<pre>Time =       0.46 sec    Generated terms =        360
                F        Terms in output =        360
            Eliminate x  Bytes used      =       4506
</pre>
Если статистика выключена, эта реклама также не будет выводиться.

<p>
Для обратной совместимости по прежнему остается устаревший механизм<a name="2459"></a> 
передачи настроек модуля через инструкции модуля. 
This is a feature which will probably disappear in future versions of FORM. We do 
give the syntax to allow the user to identify the option properly and 
enable proper translation into the moduleoption<a name="2460"></a> 
statement (see <a href="#substamoduleoption">7.81</a>).
</p><pre>    .sort(PolyFun=functionname);
    .sort(PolyFun=functionname):advertisement;
</pre>
causes the given function to be treated as a polynomial<a name="2464"></a> 
function. This means that its (single) argument would be treated as the 
coefficient of the terms. The action of FORM on individual terms is

<ol>
<li>Ignore polynomial functions with more than one argument.
</li>
<li>If there is no polynomial function with a single argument, generate 
one with the argument 1.
</li>
<li>If there is more than one polynomial function 
with a single argument, multiply the arguments and replace these functions 
with a single polynomial function with the product of the arguments for a 
single argument.
</li>
<li>Multiply the argument of the polynomial function with the coefficient 
of the term. Replace the coefficient itself by one.
</li>
</ol>
If, after this, two terms differ only in the argument of their polynomial 
function FORM will add the arguments and replace the two terms by a single 
term which is identical to the two previous terms except for that the 
argument of its polynomial function is the sum of their two arguments.

<p>
It should be noted that the proper placement of .sort<a name="2467"></a> 
instructions in a FORM program is an art by itself. Too many .sort 
instructions cause too much sorting, which can slow execution down 
considerably. It can also cause the writing of intermediate expressions 
which are much larger than necessary, if the next statements would cause 
great simplifications. Not enough .sort instructions can make that 
cancellations are postponed unnecessarily and hence much work will be done 
double. This can slow down execution by a big factor. First an example of a 
superfluous .sort:
</p><pre>    S	a1,...,a7;
    L	F = (a1+...+a7)^16;
    .sort

Time =      31.98 sec    Generated terms =      74613
                F        Terms in output =      74613
                         Bytes used      =    1904316
    id	a7 = a1+a2+a3;
    .end

Time =     290.34 sec
                F        Terms active    =      87027
                         Bytes used      =    2253572

Time =     295.20 sec    Generated terms =     735471
                F        Terms in output =      20349
                         Bytes used      =     538884
</pre>
Without the sort the same program gives:
<pre>    S	a1,...,a7;
    L	F = (a1+...+a7)^16;
    id	a7 = a1+a2+a3;
    .end

Time =     262.79 sec
                F        Terms active    =      94372
                         Bytes used      =    2643640

Time =     267.81 sec    Generated terms =     735471
                F        Terms in output =      20349
                         Bytes used      =     538884
</pre>
and we see that the sorting in the beginning is nearly completely wasted. 
Now a clear example of not enough .sort instructions. A common problem is 
the substitution of one power<a name="2472"></a> series into another. If 
one does this in one step one could have:
<pre>    #define MAX "36"
    S  j,x(:`MAX'),y(:`MAX');
    *
    *	Power series expansion of ln_(1+x)
    *
    L	F = -sum_(j,1,`MAX',sign_(j)*x^j/j);
    *
    *	Substitute the expansion of x = exp_(y)-1
    *
    id	x = x*y;
    #do j = 2,`MAX'+1
    id	x = 1+x*y/`j';
    #enddo
    Print;
    .end

Time =      76.84 sec    Generated terms =      99132
                F        Terms in output =          1
                         Bytes used      =         18

   F =
      y;
</pre>
With an extra .sort inside the loop one obtains for the same program (after 
suppressing some of the statistics:
<pre>    #define MAX "36"
    S  j,x(:`MAX'),y(:`MAX');
    *
    *	Power series expansion of ln_(1+x)
    *
    L	F = -sum_(j,1,`MAX',sign_(j)*x^j/j);
    *
    *	Substitute the expansion of x = exp_(y)-1
    *
    id	x = x*y;
    #do j = 2,`MAX'+1
    id	x = 1+x*y/`j';
    .sort: step `j';

Time =       0.46 sec    Generated terms =        360
                F        Terms in output =        360
                 step 2  Bytes used      =       4506
    #enddo
           .
           .
           .
Time =       3.07 sec    Generated terms =          3
                F        Terms in output =          1
                step 37  Bytes used      =         18
    Print;
    .end

Time =       3.07 sec    Generated terms =          1
                F        Terms in output =          1
                         Bytes used      =         18

   F =
      y;
</pre>
It is very hard to give general rules that are more specific than what has 
been said above. The user should experiment with the placements of the .sort 
before making a very large run. 

<p>

</p><h1><a name="SECTION00510000000000000000"></a>
<a name="checkpoints"></a>
<br>
Checkpoints
</h1>

<p>
If<a name="2479"></a> FORM programs have to run for a long time, the 
reliability of the hardware(computer system or network) or of the software 
infrastructure becomes a critical issue. Program 
termination<a name="2480"></a> due to unforeseen failures may waste days or 
weeks of invested execution time. The checkpoint mechanism was introduced 
to protect long running FORM programs as good as possible from such 
accidental interruptions. With activated checkpoints FORM will save its 
internal state and data from time to time on the hard disk. This data then 
allows a recovery from a crash<a name="2481"></a>.

</p><p>
The checkpoint mechanism can be activated or deactivated by <tt>On</tt><a name="2483"></a> and <tt>Off</tt><a name="2485"></a> statements. If the user has 
activated checkpoints, recovery<a name="2486"></a> data will be written to disk 
at the end of a module execution. Options allow to influence the details of 
the saving mechanism. If a program is terminated during execution, FORM can 
be restarted with the <tt>-R</tt> option and it will continue its execution at 
the last saved recovery point.

</p><p>
The syntax of the checkpoint activation and deactivation is
</p><pre>    On checkpoint [&lt;OPTIONS&gt;];
    Off checkpoint;
</pre>

<p>
If no options are given, the recovery data will be saved at the end of every
module<a name="2490"></a>. If one gives a time<a name="2491"></a>
</p><pre>    On checkpoint &lt;NUMBER&gt;[&lt;UNIT&gt;];
</pre>
the saving will only be done if the given time has passed after the last 
saving. Possible unit specifiers are <tt>s, m, h, d</tt> and the number will 
then be interpreted as seconds, minutes, hours, or days, respectively. The 
default unit is seconds.

<p>
If one needs to run a script<a name="2495"></a> before or after the saving,
one can specify a script filename.
</p><pre>    On checkpoint runbefore="&lt;SCRIPTFILENAME&gt;";
    On checkpoint runafter="&lt;SCRIPTFILENAME&gt;";
    On checkpoint run="&lt;SCRIPTFILENAME&gt;";
</pre>
The option <tt>run</tt><a name="2499"></a> sets both the scripts to be run before and 
after saving.The scripts must have the executable flag set and they must 
reside in the execution path of the shell<a name="2500"></a> (unless the filename 
already contains the proper path).

<p>
The scripts receive the module number<a name="2501"></a> as an argument 
(accessible as $1 inside the script). The return value of the script 
running before the saving will be interpreted. If the script returns an 
error (non-zero return value), a message will be issued and the saving will 
be skipped. 

</p><p>
The recovery data will be written to files named <tt>FORMrecv.*</tt> with 
various name extensions. If a file <tt>FORMrecv.tmp</tt> exists, FORM will not 
run unless one gives it the recovery option<a name="2504"></a>
<tt>-R</tt>. This is to prevent the unintentional loss of recovery data. If 
FORM terminates successfully, all the additional data files will be removed.

</p><p>
The additional recovery files will be created in the directory containing 
the scratch files.  The extra files will occupy roughly as much space as 
the scratch files<a name="2506"></a> and the save<a name="2507"></a> and 
hide files<a name="2508"></a> combined. This extra space must be made 
available, of course.

</p><p>
If recovery data exists and FORM is started with the <tt>-R</tt> option, FORM 
will continue execution after the last module that successfully wrote the 
recovery data. All the command line parameters that have been given to the 
crashed FORM program<a name="2510"></a> must also be given to the 
recovering FORM program. The input files are not part of the recovery data 
and will be read in anew when recovering. Therefore it is strongly 
discouraged to change any of these files between saving and recovery.

</p><h1><a name="SECTION00600000000000000000"></a>
<a name="pattern"></a>
<br>
Сопоставление с образцом
</h1>

<p>
Замены,<a name="2585"></a><a name="2586"></a> производятся в FORM-е 
при помощи задания универсального объекта, который должен быть заменен выражением. 
Этот универсальный объект называется паттерном<a name="2587"></a>. 
Паттерны, с кооторыми пользователь уже может быть знаком, это регулярные выражения во множестве 
UNIX<a name="2588"></a>-подобных систем или просто конструкции наподобие <code>ls *.frm</code> 
для перечисления файлов, чье имя заканчивается на <code>.frm</code>. 
В этом случае <code>*</code> называется подстановочным символом<a name="2589"></a>, 
который может принимать любое строковое значение. 
В символных манипуляциях также существуют подстановочные символы, 
но их природа отличается. Они также отображаются другим способом.

</p><p>
В FORM-е подстановочные переменные обозначаются добавлением знака вопроса<a name="2590"></a> (?) 
к имени переменной. Тип переменной показывает, какой тип объекта мы ищем. 
Предположим следующую конструкцию id<a name="2591"></a>:
</p><pre>    Functions f,g;
    Symbol x;

    id f(g?,x) = g(x,x);
</pre>
В этой конструкции g будет соответствовать любой функции, 
и следовательно все появления f, в которых первый аргумент является функцией, 
и второй аргумент является символом x, будет подходящим. 
В правой части подстановки функция g будет заменено на 
то, чему равно g, предполагая, что левая часть имеет соответствие. 
Следовательно <code>f(f,x)</code> будет заменена на <code>f(x,x)</code>.

<p>
В общем, функциональный символ подстановки<a name="2594"></a> может соответствовать ттолько функциям. 
Даже если тензоры являются специальными фуункциями, 
обычный шаблонный символ функции не может соответствовать тензору, 
и шаблонный символ тензора не может соответствовать функции. 
Тем не менее шаблонные символы коммутирующих функций<a name="2595"></a> 
могут соответствовать некоммутирующим<a name="2596"></a> функциям <i>и наоборот</i>.

</p><p>
Индексный символ подстановки<a name="2598"></a> может соответствовать только индексам. 
Размерность индексов не имеет значения. Следовательно:
</p><pre>    id f(mu?,mu?) = 4;
</pre>
будет соответствовать и <code>f(ka,ka)</code> и <code>f(2,2)</code>. 
Мы увидим далее насколько более выборочными могут быть паттерны.

<p>
Когда подстановочный символ встречается более одного раза в паттерне, 
ему должен соответствовать один и тот же объект во всех местах. 
Следовательно предыдущий паттерн не будет соответствовать <code>f(mu,nu)</code>.

</p><p>
Существует одна сложность касательно последнего правила для индексных подстановочных символов only matching indices. 
FORM записывает свертки с веторами в специальной укороченной нотации, 
называемой Schoonschip<a name="2601"></a> нотайией. 
Следовательно <code>f(mu)*p(mu)</code> становится <code>f(p)</code>. 
Это означает, что подстановка
</p><pre>    id f(mu?)*g(nu?) = fg(mu,nu);
</pre>
также должна заменить терм <code>f(p)*g(q)</code> на <code>fg(p,q)</code>. 
В этом коде это выглядит какбуд-то индексный шаблонный символ соответствует вектору. 
Тем не менее это не так, потому что если мы возьмем предыдущий паттерн 
(с <code>f(mu?,mu?)</code>), он не подойдет для терма <code>f(p,p)</code>, 
потому что этот терм должен читаться как <code>f(mu,nu)*p(mu)*p(nu)</code>
а этот терм не подходит под паттерн <code>f(mu?,mu?)</code>.

<p>
Векторные<a name="2604"></a> подстановочные символы могут соответствочать векторам, 
но также они могут соответствовать вектороподобным выражениям в аргументах функций. 
without indices, possibly multiplied by other objects like coefficients, 
Векторно-подобное выражепие - это такое выражение, 
в котором все термы содержат одну единственную векторную функцию или символ. Следовательно
</p><pre>    id f(p?) = p.p;
</pre>
будет соответствовать <code>f(q)</code>, <code>f(2*q-r)</code> и <code>f(a*q+f(x)*r)</code>, 
если p, q и r являются веторами, a и x являются символами, и f - функция. 
Он не будет соответствовать ни <code>f(x)</code>, ни <code>f(q*r)</code>, ни 
<code>f(a*q+x)</code>.

<p>
Символьные одстановочные<a name="2607"></a> символы являются более гибкими объевтами. 
Они могут соответствоввть символам, числам и выражениям, 
которые не содержат свободных индексов или векторов без индексов. 
Такие последние объекты называются скалярными<a name="2608"></a> объектами. 
Следовательно символьные подстановочные символы могут соответствовать любым скалярным объектам. В 
</p><pre>    id x^n? = x^(n+1)/(n+1);
</pre>
символьный подстановочный символ n будет нормально сопоставляться с численными целыми степенями. В
<pre>    id f(x?) = x^2;
</pre>
будет сопоставляться с <code>f(y)</code>, с <code>f(1+2*y)</code> и с <code>f(p.p)</code>, 
но не будет сопоставляться с <code>f(p)</code>, если p - это вектор.

<p>
Существует один дополнительный тип подстановочных символов. 
Этот тип достаточно специфичный. 
он ссылается на группу аргументов функции<a name="2613"></a><a name="2614"></a>. 
Количество вргументов не задано. 
Такие переменные обозначаются знаком вопроса, за которым идет имя 
(в противоположность тому как у других подстановочных переменных), 
и в правой части они должны также записываться с ведущим знаком вопроса:
</p><pre>    id f(?name) = g(1,?name);
</pre>
В этой конструкции<a name="2617"></a> все экземпляры f с любым количеством аргументов (включая отсутствие аргументов) будут подходящими. 
Следовательно <code>f(mu,nu)</code> будет заменено на <code>g(1,mu,nu)</code>. 
В случае когда f является обычной функцией и g - тензором, 
думается, что аргументы в <code>?name</code> не подойдут для тензора. 
Например <code>f(x)</code>, с символом x, не подойдет, 
и FORM поаытается связать символ с тензором g. 
Это приведет к ошибке времени выполнения. 
В общем FORM будет принимать для подстановки в тензор аргументы, которые являются индексами или отдельными векторами. 
Объект <code>?name</code> называется <b>подстановочное поле аргументов(argument field wildcard)</b>.

<p>
Следует понимать, что использование подстановочных полей аргументов 
может замедлить сопоставление с шаблоном.
</p><pre>    id f(?a,p1?,?b,p2?,?c,p3?,?d)*g(?e,p3?,?f,p1?,?g,p2?,?h) = ....
</pre>
может вызвать значительное количество попыток, 
особенно когда f и g много раз встречаются в терме. 
Надо быть очень осторожным с этим.

<p>
Сложность состоит в сопоставлении с функциями, имеющими свойства симметрии. 
В принципе FORM должен попробовать все возможные перестановки 
перед тем как сможет заключить, что соответствия нет. 
Это может привести к большому потреблению времени, когда вызывается много подстановочных символов. 
FORM имеет достаточное количество встроенных трюков для попыток ускорить это, 
но понятно, что для многих случаев этих трюков недостаточно. 
Этот тип сопоставления с образцом - слабейший аспект `искусственного интеллекта' в общем. 
Возможно в следующих версиях это будет улучшено. 
На данный момент практическое следствие в том, 
что подстановочные поля аргументов не могут использоваться с симметричными и антисимметричными функциями. 
Если требуется сделать общую замену в симметричной функции, это не может использоваться
</p><pre>    CFunction f(symmetric),g(symmetric);
    id  f(?a) = ....;
</pre>
но можно попробовать что-то вроде
<pre>    CFunction f(symmetric),ff,g(symmetric);
    id  f(x1?,...,x5?) = ff(x1,...,x5);
    id  ff(?a) = ...;
    id  ff(?a) = f(?a);
</pre>
если f имеет например 5 аргументов. 
Если используется различное количество аргументов, 
может потребоваться больше одной конструкции, 
или конструкция с функцией replace_<a name="2625"></a>:
<pre>    Multiply replace_(f,ff);
</pre>
Это показывает, что иногда следует быть более осторожным при чрезмерном использовании (анти)симметричных функций. 
Циклические функции не имеют этих ограничений.

<p>
Когда существует несколько способов соответствия, 
FORM просто возьмет первое попавшееся. 
Потому что не зафиксировано, как FORM ищет соответствия 
(в будущих версиях порядок перебора может быть изменен без уведомлений об этом), 
следует избегать неоднозначностей<a name="2628"></a>, таких как
</p><pre>    id f(?a,?b) = g(?a)*h(?b);
</pre>
Конечно текущий метод поиска полностью последовательный 
(и стартует со всех аргументов в <code>?a</code> и ниодного в <code>?b</code> и т.д., 
но будущий поисковик паттернов может работать в другом порядке.

<p>
Когда два символа полей аргументов в левой части имеют одно и то же имя, 
совпадение произойдет только когда они будут сопоставлены с одними и теми же аргументами. Следовательно
</p><pre>    id f(?a,?a) = g(?a);
</pre>
будет соответствовать <code>f(a,b,a,b)</code> или даже <code>f</code> 
(в этом случае <code>?a</code> будет иметь ноль аргументов), 
но не будет соответствовать <code>f(b,b,b)</code>.

<p>
Иногда полезно, когда поиск может быть ограничен ограниченным множеством объектов. 
Для этого в FORM-е существует концепция множеств<a name="2633"></a>. 
Если имя множества добавлено после знака вопроса, 
это говорит FORM-у о том, что надо искать соответствия в которых 
подстановочный символ может быть равен одному из членов множества:
</p><pre>    Symbols a,a1,a2,a3,b,c;
    Set aa:a1,a2,a3;

    id f(a?aa) = ...
</pre>
будет соответствовать <code>f(a1)</code> но не <code>f(b)</code>. 
Множества также могут быть определены динамически<a name="2636"></a>, 
путем заключения элементов между фигурными скобками<a name="2637"></a> как в:
<pre>    Symbols a,a1,a2,a3,b,c;

    id f(a?{a1,a2,a3}) = ...
</pre>
Множества символов<a name="2640"></a> могут также содержать (небольшие целые) числа. 
Аналогично мнодества<a name="2641"></a> индексов могут содержать фиксированные индексы 
(положительные числа, меньшие чем значение fixindex<a name="2642"></a> 
(См. главу о настройке <a href="#setup">16</a>). 
Это означает, что некоторые множества могут быть неоднозначны<a name="2644"></a> по своей природе.

<p>
Иногда множества могут использоваться<a name="2645"></a> как некоторый тип массива<a name="2646"></a>. 
В случае с
</p><pre>    Symbols a,a1,a2,a3,b,c,n;
    Set aa:a1,a2,a3;

    id f(a?aa[n]) = ...
</pre>
не только `a' будет равно жлементу множества aa, 
но если оно равно элементу этого множества, 
n будет равно номеру этого элемента. 
Следовательно для <code>f(a2)</code> подстановочный символ будет равен <code>a2</code> 
и подстановочный символ n будет равен 2. 
Эти объекты можно использовать в правой части. 
Также в правой части можно использовать множества с индексами, 
такими как n в предыдущем примере:
<pre>    Symbols a,a1,a2,a3,b1,b2,b3,c,n;
    Functions f,g1,g2,g3;
    Set aa:a1,a2,a3;
    Set bb:b1,b2,b3;
    Set gg:g1,g2,g3;

    id f(a?aa[n]) = gg[n](bb[n]);
</pre>
который будет заменять <code>f(a2)</code> на <code>g2(b2)</code>. 
Однако запрещена арифметика <a name="2651"></a> с номерами элементов массива. 
Конструкции в роде <code>bb[n+1]</code> - запрещены.

<p>
Существует еще один механизм, позволяющий использовать множества как массивы. 
В следующей конструкции (объявления такие же как и раньше)
</p><pre>    id f(a?aa?bb) = a*f(a);
</pre>
a будет равно элементу из множества aa, но после того, как оно будет найдено, 
оно будет равно соответствующему<a name="2654"></a> элементу множества bb. 
Следовательно <code>f(a2)</code> превратится в <code>b2*f(b2)</code>.

<p>
Подстановочные символы также могут передавать свое значение напрямую в $-variables<a name="2655"></a><a name="2656"></a> 
(см. главу <a href="#dollars">6</a> про $-переменные). 
Если $-переменная присоединена к подстановочному символу 
(если на нее наложены ограничения множества, она должна быть после множества) 
$-переменная получит то же содержимое, что и подстановочный символ. 
Если имеется больше одного совпадения, $-переменная получит последнее совпадение.
</p><pre>    id f(a?$w) = f(a);
</pre>
присвоит совпадение в <code>$w</code>. 
Следовательно в случае <code>f(a2)</code> $-переменная будет иметь значение <code>a2</code>. 
В случае <code>f(a2)*f(a3)</code> конечное значение <code>$w</code> зависит от порядка в которм FORM ищет совпадения. 
Это не определено, и будет прохой стратегией, делать программы, зависящие от этого. 
Следующие паттерны могут делать это по разному! 
Но это можно делать например так
<pre>    while ( match(f(a?$w)) );
        id f($w) = ....
        id g($w) = ....
    endwhile;
</pre>
Только убедитесь, с которым совпадением вы работаете.

<p>

</p><h1><a name="SECTION00700000000000000000"></a>
<a name="dollars"></a>
<br>
Доллар-переменные
</h1>

<p>
В старых версиях FORM-а было два типа переменных: 
переменные препроцессора<a name="2714"></a> и алгебраические переменные<a name="2715"></a>. 
Переменные препроцессора - это строковые переменные, 
которые сипользуются редакторскими возможностями препроцессора для обработки ввода для компиляторной части FORM-а. 
Алгебраические объекты - это выражения и раздичные алгебраические переменные, 
такие как символы, функции, вектора и т.д..
Тем не менее существовало чень мало возможностей для связи от алгебраического уровня 
к решению, принимаемому на уровне препроцессора. 
Это драматически изменилось в версии 3 при введении доллар-переменных<a name="2716"></a>.

</p><p>
Доллар-переменные - это в основном (небольшие) выражения, которые могут использоваться для хранения различных типов информации. 
Они могут использоваться и как объекты препроцессора и как алгебраические объекты. 
Они могут определяться и получать значение и препроцессором и в процссе вычисления на терме by term basis. 
Доллар-переменные остаются в памяти. 
Следовательно важно не делать их слижком большими, потому что в этом случае может пострадать производительность.

</p><p>
Какое имя допустимо для доллар-переменной?
Доллар-переменные имеют имена, которые состоят из знака (<code>$</code>), 
за которым идет один алфавитный символ и за тем возможны еще алфавитно-цифровые символы. 
Следовательно <code>$a</code> и <code>$var</code> и <code>$r4t78y0</code> - допустимые имена, 
а <code>$1a</code> - недопустимое. 
Переменные не обязаны объявляться. 
Тем не менее FORM будет жаловаться, если доллар-переменная используется перед тем как 
встретится конструкция или инструкция, в которой этой переменной будет присвоено значение. 
Следовательно присваивание переменной значения считается в то же время как объявление.

</p><p>
Что можно хранить в доллар-переменной?

</p><ul>
<li>Алгебраические выражения такие как <code>$var = (a+b)^2;</code>
</li>
<li>Отдельные объекты такие как индексы, числа, сиволы.
</li>
<li>Ноль.
</li>
<li>Части терма.
</li>
<li>Поля аргументов<a name="2718"></a>, которые содержат ноль, один или более аргументов.
</li>
</ul>
На самом деле, части терма обрабатываются как целый терм, 
и следовательно как специальный случай алгебраического выражэения. 
Внутренне они сохраняются немного по другому для скорости, но на пользовательском уровне это не заметно. 
На самом деле, за исключением полей аргументов, FORM может преобразовывоть один тип в другой 
и будет пытаться жэто делать, в зависимости от использования конкретной доллар переменной. 
В сслучае, когда переменная используется способом, который не возмежен 
(Например когда содержимое переменной это символ, но она используется в том месте, где ожидается индекс) 
произойдет ошибка времени выполнения<a name="2720"></a><a name="2721"></a>.

<p>
Как переменные используются?

</p><ul>
<li>Как переменные препроцессора<a name="2723"></a>. 
Это делается при помощи помещения переменной между `' как в <code>`$var'</code>. 
В этом случае обычная подпрограмма печати FORM-а производит текстовое представление<a name="2724"></a> переменной 
какой она есть на момент, когда препроцессор встретил этот объект, 
и эта строка после этого подставляется препроцессором как если бы это было содержимым переменной препроцессора.
</li>
<li>Как выражение во время выполнения. Это произойдет в случае конструкции
<pre>    id x = y + $var;
</pre>
где <code>$var</code> подставляется таким же способом 
как подставление локального выражения <code>F</code> в конструкции
<pre>    id x = y + F;
</pre>
за исключением того, что доллар-переменная всегда хранится в памяти процессора.
</li>
<li>Как алгебраический объект во время выполнения. 
Это может быть случацй с любым значением переменной, которая не является выражением. 
примером может быть 
<pre>    id f(?a) = f(?a,$var);
</pre>
в которой доллар-переменная содержит поле аргументов.
</li>
<li>Как алгебраический объект в задержанной подстановке паттерна или специальной конструкции. 
Это может потребовать некоторого пояснения. Если мы имеем конструкцию
<pre>    id f($var) = anything;
</pre>
компилятор не будет подставлять текущее значение <code>$var</code>. 
Смысл в том, что <code>$var</code> будет принимать различное значение для кажддого терма, 
который запускается в этой конструкции, в то время как компилятор компилирует конструкцию только один раз. 
Следовательно FORM будет подставлять значение в <code>$var</code> только в момент, когда происходит сопоставление. 
Это называется отложенная подстановка<a name="2733"></a><a name="2734"></a>. 
Если хотите, компилятор подставит значение, это можно сделать, написав
<pre>    id f(`$var') = anything;
</pre>
Аналогичная задержанная подстановка имеет место в конструкции типа <code>Trace,$var;</code>.
</li>
</ul>

<p>
Как можно задать значение доллар-переменной?

</p><ul>
<li>В препроцессоре. This is done with an instruction of the type 
<code>#$var = 0;</code>. This is an instruction that can run over more than one 
line. The r.h.s. can be any algebraic expression. Specifically it can 
contain dollar variables or local/global expressions. Such 
expressions are worked out during the preprocessing. Hence this variable 
acquires a value immediately.
</li>
<li>During execution when control reaches a statement of the form 
<code>$var = expression;</code>. Again the r.h.s. can contain any normal 
algebraic expression including dollar variables and local/global 
expressions. The r.h.s. will be evaluated and the value will be assigned to 
<code>$var</code>. In the case that <code>$var</code> had already a value, the old 
value will be deleted and the new value will be `installed'.
</li>
<li>During execution when the dollar variable is assigned the value of a 
wildcard as in
<pre>    id f(x?$var) = whatever;
</pre>
If the function <code>f</code> 
occurs more than once in a term, <code>$var</code> will have the value of the 
last match. In the case that the value of the first match is needed one can 
use the option `once' in the id-statement as in
<pre>    id,once,f(x?$var) = whatever;
</pre>
In general one can paste the dollar variable to the end of any 
wildcard description. Hence one can use <code>id f(x?{1,2,3}$var) = ...;</code> 
and
<pre>    id f(x?set[n?$var1]$var2) = ...;
</pre>
</li>
</ul>
Note the difference between <code>#$a = 0;</code> and <code>$a = 0;</code>. One CANNOT 
make a wildcard<a name="2746"></a> construction for dollar variables 
themselves as in <code>id f($var?) = ...;</code>

<p>
Dollar variables CANNOT have arguments as in <code>$var(2)</code> or something 
equivalent. There is however a solution at the preprocessor level for this 
by defining individual variables <code>$var1</code> to <code>$varn</code> and then 
using <code>$var`i'</code> or <code>`$var`i''</code> for some preprocessor variable 
<code>i</code>. The exception is the indication of factors when a dollar variable 
has been factorized (see the #factdollar instruction&nbsp;<a href="#prefactdollar">3.28</a> 
and the factdollar statement&nbsp;<a href="#substafactdollar">7.47</a>). This is explained 
later in this chapter and in the chapter about 
polynomials&nbsp;<a href="#polynomials">10</a>.

</p><p>
Printing dollar<a name="2750"></a> variables:

</p><ul>
<li>In the preprocessor one can use the <code>#write</code> instruction
        (see <a href="#prewrite">3.61</a>).
</li>
<li>During execution one can use the Print statement (see 
        <a href="#substaprint">7.105</a>).
</li>
</ul>
In both cases one should use the format<a name="2755"></a> string. The syntax is 
described in the chapters on these statements. The format descriptor of a 
dollar variable is <code>%$</code> and this looks after the format string for the 
next dollar variable. Of course one can also use the dollar variable as a 
preprocessor variable when printing/writing in the preprocessor.

<p>
Examples.

</p><p>
Counting terms:
</p><pre>    S	a,b;
    Off statistics;
    L	F = (a+b)^6;
    #$a = 0;
    $a = $a+1;
    Print "      &gt;&gt; After %t we have %$ term(s)",$a;
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 0
    .sort
      &gt;&gt; After  + a^6 we have 1 term(s)
      &gt;&gt; After  + 6*a^5*b we have 2 term(s)
      &gt;&gt; After  + 15*a^4*b^2 we have 3 term(s)
      &gt;&gt; After  + 20*a^3*b^3 we have 4 term(s)
      &gt;&gt; After  + 15*a^2*b^4 we have 5 term(s)
      &gt;&gt; After  + 6*a*b^5 we have 6 term(s)
      &gt;&gt; After  + b^6 we have 7 term(s)
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 7
    .end
</pre>

<p>
Maximum power of x in an expression:
</p><pre>    S	x,a,b;
    Off statistics;
    L	F = (a+b)^4+a*(a+x)^3;
    .sort
    #$a = 0;
    if ( count(x,1) &gt; $a ) $a = count_(x,1);
    Print "      &gt;&gt; After %t the maximum power of x is %$",$a;
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 0
    .sort
      &gt;&gt; After  + 3*x*a^3 the maximum power of x is 1
      &gt;&gt; After  + 3*x^2*a^2 the maximum power of x is 2
      &gt;&gt; After  + x^3*a the maximum power of x is 3
      &gt;&gt; After  + 4*a*b^3 the maximum power of x is 3
      &gt;&gt; After  + 6*a^2*b^2 the maximum power of x is 3
      &gt;&gt; After  + 4*a^3*b the maximum power of x is 3
      &gt;&gt; After  + 2*a^4 the maximum power of x is 3
      &gt;&gt; After  + b^4 the maximum power of x is 3
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 3
    .end
</pre>

<p>
Starting with version 4, FORM has the capability to factorize polynomials 
(see the chapter on polynomials&nbsp;<a href="#polynomials">10</a>). One type of objects 
that can be factorized is the dollar variables. The immediate question here 
is how to access the factors. As we mentioned before in this chapter, 
normally there is no direct way to use arguments for dollar variables. For 
the factors however we have a way of indexing the dollar variables as in 
<code>$var[1]</code>,...,<code>$var[n]</code> when there are n factors. The number of 
factors can be obtained as <code>$var[0]</code>. In the index field can only be 
(nonnegative integer) numbers, dollar variables or factors of dollar 
variables that evaluate into (nonnegative integer) numbers.
</p><pre>    Symbol x,y;
    CFunction f1,f2;
    Local F = f1(x^2+2*x*y+y^2)+f1(x^4-y^4);
    id  f1(x?$x) = f2(x);
    FactDollar,$x;
    Do $i = 1,$x[0];
      Print "In %t factor %$ is %$",$i,$x[$i];
    Enddo;
    .end
In  + f2(y^2 + 2*x*y + x^2) factor 1 is y + x
In  + f2(y^2 + 2*x*y + x^2) factor 2 is y + x
In  + f2( - y^4 + x^4) factor 1 is  - 1
In  + f2( - y^4 + x^4) factor 2 is y - x
In  + f2( - y^4 + x^4) factor 3 is y + x
In  + f2( - y^4 + x^4) factor 4 is y^2 + x^2
</pre>

<p>
One thing to note is that the use of
</p><pre>     f(&lt;$x[1]&gt;,...,&lt;$x[$x[0]]&gt;)
</pre>
is illegal. <code>$x[0]</code> will be inserted during execution time, while the 
expansion of the triple dot operator is done by the preprocessor. Hence we 
should use <code>`$x[0]'</code> but then <code>$x</code> must be known and factorized 
already at compile time.

<p>

</p><h1><a name="SECTION00710000000000000000"></a>
<a name="pardollars"></a>
<br>
Dollar variables in a parallel environment
</h1>

<p>
When FORM is used for parallel<a name="2767"></a> processing, 
either by means of P<small>AR</small>FORM<a name="2768"></a> or by means of 
TFORM<a name="2769"></a>, there can be a problem with the dollar variables as in 
principle there is a central administration and dollar variables that are 
defined during running will in general have the last assigned value. In a 
parallel environment this can be nondeterministic<a name="2770"></a>. 
Look for instance at the following example:
</p><pre>    S   x,a,b;
    CF  f;
    L   F = f(a+b) + f(a+2*b);
    .sort
    id  f(x?$x) = f(x);
    Multiply,$x;
    Print;
    .end
</pre>
Usually this program will give the 'correct' answer, but in principle one 
thread could define <code>$x</code> and then the next thread could overwrite this 
value before the first thread has used it. This is serious. Hence FORM 
will veto<a name="2773"></a> the use of multiple threads/processors for modules in 
which dollar variables obtain values during the execution of the program, 
unless the user can give FORM more information about the use of the 
dollar variables. In the above case the value of <code>$x</code> will be local to 
each term and hence to each thread<a name="2774"></a>. The value in previous 
terms is unimportant. We can tell this to FORM with a variety of the 
moduleoption<a name="2775"></a> statement (see <a href="#substamoduleoption">7.81</a>). 
This would be:
<pre>    S   x,a,b;
    CF  f;
    L   F = f(a+b) + f(a+2*b);
    .sort
    id  f(x?$x) = f(x);
    Multiply,$x;
    Print;
    ModuleOption,local,$x;
    .end
</pre>
In this case FORM makes at the start of the execution of the module a 
copy of whatever value <code>$x</code> has at that moment for each 
thread/processor (in this case no value yet and hence it gets set to zero) 
and then each thread/processor uses its own copy during execution. After 
the module has been completed the local copies are removed and the original 
global value is accessible again. This way execution will be safe in a 
parallel environment.

<p>
There are more cases that FORM can handle in a parallel environment. 
These are also options in the moduleoption statement:
</p><pre>    ModuleOption,maximum,$a;
    ModuleOption,minimum,$b;
    ModuleOption,sum,$c;
</pre>
Here we say that <code>$a</code> is accumulating a maximum numerical value, 
<code>$b</code> collects a minimum numerical value and <code>$c</code> is a numerical 
sum. In all three cases there is a central administration and the use of 
the variables has to be blocked for other threads/processors during the 
updating of the values. Sometimes that can be efficient, but in other 
programs that may actually make them slower. One should experiment. A 
sample program is given below:
<pre>    S   a1,...,a10;
    L   F = (a1+...+a10)^3;
    .sort
    #$c = 0;
    Print +f "&lt;%w&gt; %t";
    Multiply,(a1+...+a10);
    $c = $c+1;
    ModuleOption,sum,$c;
    .sort
    #message $c = `$c'
    #$max = 0;
    #$min = 10;
    if ( count(a1,1) &gt; $max ) $max = count_(a1,1);
    if ( count(a4,1) &lt; $min ) $min = count_(a4,1);
    ModuleOption,maximum,$max;
    ModuleOption,minimum,$min;
    .sort
    #message $max = `$max'
    #message $min = `$min'
    .end
</pre>
The print statement is showing which thread is dealing with which term.

<p>

</p><h1><a name="SECTION00800000000000000000"></a>
<a name="statements"></a>
<br>
Statements
</h1>

<p>

</p><h1><a name="SECTION00810000000000000000"></a>
<a name="substaabrackets"></a>
<br>
abrackets, antibrackets
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ab[rackets][+][-] <tt>&lt;</tt>list of names<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">antib[rackets][+][-] <tt>&lt;</tt>list of names<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">bracket (<a href="#substabracket">7.10</a>) and the chapter on brackets 
     (<a href="#brackets">9</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="2846"></a><a name="2847"></a> does the opposite of 
the bracket statement (see <a href="#substabracket">7.10</a>). In the bracket statement 
the variables that are mentioned are placed outside brackets and inside the 
brackets are all other objects. In the antibracket statement the variables 
in the list are the only objects that are not placed outside the brackets. 
For the rest of the syntax, see the bracket statement (section 
<a href="#substabracket">7.10</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00820000000000000000"></a>
<a name="substaalso"></a>
<br>
also
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable Statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">a[lso] [options] <tt>&lt;</tt>pattern<tt>&gt;</tt> = 
         <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>), idold (<a href="#substaidold">7.62</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The also<a name="2863"></a> statement should follow either an 
id<a name="2864"></a> statement or another also statement. The action is that the 
pattern matching in the also statement takes place immediately after the 
pattern matching of the previous id statement (or also statement) and after 
possible matching patterns have been removed, but before the r.h.s. 
expressions are inserted. It is identical to the idold statement (see 
<a href="#substaidold">7.62</a>). Example:
</p><pre>    id    x = cosphi*x-sinphi*y;
    also  y = sinphi*x+cosphi*y;
</pre>

<p>
The options are explained in the section on the id statement (see 
<a href="#substaidentify">7.60</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00830000000000000000"></a>
<a name="substaantiputinside"></a>
<br>
antiputinside
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">antiputinside <tt>&lt;</tt>name of function<tt>&gt;</tt> [,<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">antibracket information<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">PutInside (<a href="#substaputinside">7.111</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
This statement<a name="2879"></a> puts all parts of the term 
with the exception of the variables in the antibracket information inside a 
function argument. The function must be a regular function (hence no tensor 
or table which are special types of functions). The 
antibracket<a name="2880"></a> information should adhere to the syntax of 
the bracket statement (<a href="#substabracket">7.10</a>, <a href="#substaabrackets">7.1</a>) and all 
occurrences of all variables with the exception of the antibracket 
variables will be put inside the function. The coefficient will also be put 
inside the function.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00840000000000000000"></a>
<a name="substaantisymmetrize"></a>
<br>
antisymmetrize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">an[tisymmetrize] <code>{</code><tt>&lt;</tt>name of function/tensor<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>];<code>}</code></td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">symmetrize (<a href="#substasymmetrize">7.131</a>), cyclesymmetrize 
(<a href="#substacyclesymmetrize">7.23</a>), rcyclesymmetrize (<a href="#substarcyclesymmetrize">7.113</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The argument specifications are explained in the section on the 
symmetrize statements (see <a href="#substasymmetrize">7.131</a>).
</p><p>
<br>

</p><p>
The action of this statement<a name="2898"></a> is to 
anti-symmetrize the (specified) arguments of the functions that are 
mentioned. This means that the arguments are brought to `natural order' in 
the notation of FORM and each exchange of arguments or groups of arguments 
results in a minus sign in the coefficient of the term. The `natural order' 
may depend on the order of declaration of the variables. If two arguments 
or groups of arguments that are part in the anti-symmetrization are 
identical, the function is replaced by zero. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00850000000000000000"></a>
<a name="substaapply"></a>
<br>
apply
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">apply ["<tt>&lt;</tt>tablename(s)<tt>&gt;</tt>"];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">tablebases (<a href="#tablebase">12</a>), apply (<a href="#tblapply">12.2</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="2910"></a> is explained in the chapter on 
tablebases.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00860000000000000000"></a>
<a name="substaargexplode"></a>
<br>
argexplode
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">argexplode [<tt>&lt;</tt>list of functions<tt>&gt;</tt>]</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">argimplode (<a href="#substaargimplode">7.7</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
See the description of the ArgImplode&nbsp;<a href="#substaargimplode">7.7</a> 
statement.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00870000000000000000"></a>
<a name="substaargimplode"></a>
<br>
argimplode
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">argimplode [<tt>&lt;</tt>list of functions<tt>&gt;</tt>]</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">argexplode (<a href="#substaargexplode">7.6</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This is a rather specialized statement. It converts one notation 
of indices, used for harmonic sums<a name="2932"></a><a name="2933"></a>, harmonic 
polylogarithms<a name="2934"></a><a name="2935"></a> and multiple zeta values<a name="2936"></a> into 
its alternative notation. The two notations are:
</p><pre>   Z(0,0,0,1,0,0,-1)
   Z(4,-3)
</pre>
In the first notation the indices can only be 0, 1 and -1. In the second 
notation there can be no zeroes. The `ArgImplode,Z;' 
statement<a name="2939"></a> would be 
equivalent to the statement
<pre>   repeat id Z(?a,0,x?!{0,0},?b) = Z(?a,x+sig_(x),?b);
</pre>
and takes one from the first notation to the second. The `ArgExplode,Z;' 
statement<a name="2942"></a> is equivalent to the statement
<pre>   repeat id Z(?a,x?!{1,0,-1},?b) = Z(?a,0,x-sig_(x),?b);
</pre>
and takes one from the second notation to the first. The reason that these 
statements have been built in lies in the fact that for many indices the 
repeat statements started to become very time-consuming.

<p>
For the harmonic sums, the harmonic polylogarithms and the 
multiple zeta values one can use the summer6 and the harmpol packages in 
the FORM distribution. They are described in the papers

</p><p>
J.&nbsp;A.&nbsp;M. Vermaseren, <i>Harmonic sums, Mellin transforms and integrals</i>,
  <em>Int. J. Mod. Phys.</em> <b>A14</b> (1999) 2037,
  http://arxiv.org/abs/hep-ph/9806280.

</p><p>
E.&nbsp;Remiddi and J.&nbsp;A.&nbsp;M. Vermaseren, <i>Harmonic polylogarithms</i>,  <em>Int. J. Mod. Phys.</em> <b>A15</b> (2000) 725,
  http://arxiv.org/abs/hep-ph/9905237.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00880000000000000000"></a>
<a name="substaargument"></a>
<br>
argument
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">argument [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT"><code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
[<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">endargument (<a href="#substaendargument">7.36</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement starts an argument<a name="2965"></a> 
environment<a name="2966"></a>. Such an environment is terminated 
by an endargument statement (see <a href="#substaendargument">7.36</a>). The statements 
between the argument and the endargument<a name="2968"></a> statements will 
be applied only to the function arguments as specified by the remaining 
information in the argument statement. This information is given by:

</p><ul>
<li>No further information: the statements are applied to all arguments 
of all functions.
</li>
<li>A series of numbers: the statements are applied to the given 
arguments of all functions.
</li>
<li>A function name (or a set of functions), possibly followed by a 
series of numbers: the statements are applied to the numbered arguments of 
the function specified. If a set of functions was specified, all the 
functions in the set will be taken. If no numbers are specified, all 
arguments of the function (or elements of the set) are taken.
</li>
</ul>
The combination of a function (or set) possibly followed by numbers of 
arguments, can occur as many times as needed. The generic numbers of 
arguments that refer to all functions work in addition to the numbers 
specified for individual functions. Example
<br>
<pre>   Argument 2,f,1,{f,f1},3,4;
</pre>
This specifies the second argument of all functions. In addition the first 
argument of <code>f</code> will be taken and then also the third and fourth 
arguments of <code>f</code> and <code>f1</code> will be taken. <br>
<br>

<p>
Argument/endargument constructions can be nested. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION00890000000000000000"></a>
<a name="substaautodeclare"></a>
<br>
auto, autodeclare
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">autodeclare <tt>&lt;</tt>variable type<tt>&gt;</tt> <tt>&lt;</tt>list of variables to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">auto <tt>&lt;</tt>variable type<tt>&gt;</tt> <tt>&lt;</tt>list of variables to be declared<tt>&gt;</tt>;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The variable<a name="2990"></a><a name="2991"></a> types are 
<br>

</p><p>
<table width="181">
<tbody><tr><td>s[ymbol]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of symbols<a name="7119"></a>. For options see <a href="#substasymbols">7.130</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>v[ector]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of vectors<a name="7133"></a>. For options see <a href="#substavectors">7.148</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>i[ndex]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of indices<a name="7147"></a>. For options see <a href="#substaindex">7.66</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>i[ndices]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of indices<a name="7161"></a>. For options see <a href="#substaindex">7.66</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>f[unctions]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of noncommuting<a name="7175"></a> 
functions<a name="7176"></a>. For options see 
<a href="#substanfunctions">7.87</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>nf[unctions]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of noncommuting functions. For options see 
<a href="#substanfunctions">7.87</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>cf[unctions]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of commuting<a name="7203"></a> 
functions<a name="7204"></a>. For options see 
<a href="#substacfunctions">7.11</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>co[mmuting]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of commuting functions. For options see 
<a href="#substacfunctions">7.11</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>t[ensors]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of commuting tensors<a name="7231"></a>. For options see 
<a href="#substatensors">7.134</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>nt[ensors]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of noncommuting tensors<a name="7245"></a>. For options see 
<a href="#substantensors">7.94</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ct[ensors]
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declaration of commuting tensors<a name="7259"></a>. For options see 
<a href="#substactensors">7.22</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
The action of the autodeclare statement is to set a default for 
variable types. In a statement of the type
</p><pre>   AutoDeclare Symbol a,bc,def;
</pre>
all undeclared variables of which the name starts with the character a, the 
string bc or the string def will be interpreted as symbols and entered in 
the name tables as such. In the case there are two statements as in
<pre>   AutoDeclare CFunction b,d;
   AutoDeclare Symbol a,bc,def;
</pre>
all previously undeclared variables of which the name starts with a, bc or 
def will be declared as symbols. All other previously undeclared variables 
of which the name starts with a b or a d will be declared as commuting 
functions. This is independent of the order of the autodeclare statements. 
FORM starts looking for the most detailed matches 
first. Hence the variable defi will match with the string def first.
<br>
<br>

<p>
It is also allowed to use the properties of the various variables 
in the autodeclare statement:
</p><pre>   AutoDeclare Index i=4,i3=3,i5=5;
</pre>
This declares all previously undeclared variables of which the name starts 
with an i to be four dimensional indices, unless their names start with i3 in 
which case they will be three dimensional indices, or their names start 
with i5 in which case they will be five dimensional indices. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008100000000000000000"></a>
<a name="substabracket"></a>
<br>
bracket
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">b[rackets][+][-] <tt>&lt;</tt>list of names<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">antibracket (<a href="#substaabrackets">7.1</a>), keep (<a href="#substakeep">7.72</a>),
    collect(<a href="#substacollect">7.16</a>) and the chapter on brackets 
     (<a href="#brackets">9</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement causes the output to be reorganized in such a way 
that all objects in the `list of names' are placed outside 
brackets<a name="3047"></a> and all remaining objects inside 
brackets<a name="3048"></a>. This grouping will remain till the next time that 
the expression is active and is being manipulated. Hence the brackets can 
survive skip (see <a href="#substaskip">7.123</a>), hide (see <a href="#substahide">7.59</a>) and even 
save (see <a href="#substasave">7.118</a>) and load (see <a href="#substaload">7.75</a>) statements. The 
bracket information can be used by the collect (see <a href="#substacollect">7.16</a>) 
and keep (see <a href="#substakeep">7.72</a>) statements, as well in r.h.s. expressions 
when the contents of individual brackets of an expression can be picked up 
(see <a href="#brackets">9</a>). <br>
<br>

</p><p>
The list of names can contain names of symbols, vectors, 
functions and tensors. In addition it can contain dotproducts. There should 
be only one bracket or antibracket (see <a href="#substaabrackets">7.1</a>) statement 
in each module. If there is more than one, only the last one has an effect. 
<br>
<br>

</p><p>
The presence of a <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"> or <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"> after the bracket (or anti bracket) 
refers to potential indexing of the brackets<a name="3059"></a>. 
Usually FORM has the information inside the terms in an expression. If 
it needs to search for a particular bracket it does so by starting at the 
beginning of that expression. This can be slow. If one likes to access 
individual brackets, it may be faster to tell FORM to make an index by 
putting the <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"> after the bracket or antibracket keyword. For more 
information, see the chapter on brackets (see <a href="#brackets">9</a>). A <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"> 
indicates that no index should be made. Currently this is the default and 
hence there is no need to use this option. It is present just in case the 
default might be changed in a future version of FORM (in which FORM 
might for instance try to determine by itself what seems best. This option 
exists for case that the user would like to overrule such a mechanism). 
<br>
<br>

</p><p>
See also the antibracket statement in <a href="#substaabrackets">7.1</a>.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008110000000000000000"></a>
<a name="substacfunctions"></a>
<br>
cfunctions
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">c[functions] <tt>&lt;</tt>list of functions to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), nfunctions (<a href="#substanfunctions">7.87</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement declares commuting<a name="3078"></a> 
functions<a name="3079"></a>. The name of a 
function can be followed by some information that specifies additional 
properties of the preceding function. These can be (name indicates the 
name of the function to be declared): <br>
<br>

</p><p>
<table width="186">
<tbody><tr><td>name#r
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is considered to be a real<a name="7280"></a> function (default).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name#c
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is considered to be a complex<a name="7295"></a> function. This means 
that internally two spaces are reserved. One for the variable name and one 
for its complex conjugate name#.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name#i
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is considered to be imaginary<a name="7312"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(s[ymmetric])
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is totally symmetric<a name="7325"></a>. This means that during 
normalization FORM will order the arguments according to its internal 
notion of order by trying permutations. The result will depend on the order 
of declaration of variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(a[ntisymmetric])
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is totally antisymmetric<a name="7340"></a>. This means that 
during normalization FORM will order the arguments according to its 
internal notion of order and if the resulting permutation of arguments is 
odd the coefficient of the term will change sign. The order will depend on 
the order of declaration of variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(c[yclesymmetric])
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is cycle<a name="7355"></a> symmetric in 
all its arguments. This means that during normalization FORM will order 
the arguments according to its internal notion of order by trying cyclic 
permutations. The result will depend on the order of declaration of 
variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(r[cyclesymmetric)

<p>
name(r[cyclic])

</p><p>
name(r[eversecyclic])
</p></td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is reverse<a name="7370"></a> 
cycle symmetric in all its arguments. This means that during normalization 
FORM will order the arguments according to its internal notion of order 
by trying cyclic permutations and/or a complete reverse order of all 
arguments. The result will depend on the order of declaration of 
variables.</td></tr>
</tbody></table>
    <br>

</p><p>
The complexity properties and the symmetric properties can be 
combined. In that case the complexity properties should come first as in
</p><pre>    CFunction f1#i(antisymmetric);
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008120000000000000000"></a>
<a name="substachainin"></a>
<br>
chainin
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">Chainin,name of function;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">chainout (<a href="#substachainout">7.13</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Has<a name="3124"></a> the same effect as the statement
</p><pre>   repeat id f(?a)*f(?b) = f(?a,?b);
</pre>
if f is the name of the function specified. The chainin statement is just a 
faster shortcut. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008130000000000000000"></a>
<a name="substachainout"></a>
<br>
chainout
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">Chainout,name of function;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">chainin (<a href="#substachainin">7.12</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Has<a name="3135"></a> the same effect as the statement
</p><pre>   repeat id f(x1?,x2?,?a) = f(x1)*f(x2,?a);
</pre>
if f is the name of the function specified. The chainout statement is just a 
much faster shortcut. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008140000000000000000"></a>
<a name="substachisholm"></a>
<br>
chisholm
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">chisholm [options] <tt>&lt;</tt>spinline indices<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">trace4 (<a href="#substatrace">7.141</a>) and the chapter on gamma algebra 
(<a href="#gammaalgebra">14</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="3149"></a> applies the identity
<br>
</p><div align="CENTER">

<!-- MATH
 \begin{eqnarray}
\gamma_a\gamma_\mu\gamma_b {\rm Tr}[\gamma_\mu S] & = &
         2\gamma_a( S + S^R ) \gamma_b  \nonumber
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="104" height="31" align="MIDDLE" border="0" src="./online_files/img41.png" alt="$\displaystyle \gamma_a\gamma_\mu\gamma_b {\rm Tr}[\gamma_\mu S]$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="106" height="36" align="MIDDLE" border="0" src="./online_files/img43.png" alt="$\displaystyle 2\gamma_a( S + S^R ) \gamma_b$"></td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
in order to contract traces. <img width="15" height="14" align="BOTTOM" border="0" src="./online_files/img44.png" alt="$S$"> is here a string of
gamma<a name="3154"></a> matrices and <img width="25" height="17" align="BOTTOM" border="0" src="./online_files/img45.png" alt="$S^R$"> is the reverse string. This 
identity is particularly useful when the matrices <!-- MATH
 $\gamma_6 = 1+\gamma_5$
 -->
<img width="84" height="28" align="MIDDLE" border="0" src="./online_files/img46.png" alt="$\gamma_6 = 1+\gamma_5$"> 
and/or <!-- MATH
 $\gamma_7 = 1-\gamma_5$
 -->
<img width="84" height="28" align="MIDDLE" border="0" src="./online_files/img47.png" alt="$\gamma_7 = 1-\gamma_5$"> are involved. The spinline<a name="3155"></a> index refers to 
which trace should be eliminated this way. The options are <br>

<p>
<table width="181">
<tbody><tr><td>symmetrize
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>If there is more than one contraction with other gamma matrices, 
the answer will be the sum of the various contractions, divided by the 
number of different contractions. This will often result in a minimization 
of the number of <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> matrices left in the final results.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>nosymmetrize
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The first contraction encountered will be taken. No attempt is 
made to optimize with respect to the number of <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> matrices left.</td></tr>
</tbody></table>
    <br>

</p><p>
IMPORTANT: the above identity is only valid in 4 dimensions. For 
more details, see chapter <a href="#gammaalgebra">14</a> on gamma<a name="3162"></a> algebra. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008150000000000000000"></a>
<a name="substacleartable"></a>
<br>
cleartable
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ClearTable [<tt>&lt;</tt>list of tables<tt>&gt;</tt>]</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement clears the tables that are mentioned. Sometimes 
(sparse) tables can take so much space that there is no room for new 
elements, while old elements are not needed any longer. In that case one 
can clear the table and start all over again with filling it. It is also 
useful when one wants to reuse a table, but now with a different content.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008160000000000000000"></a>
<a name="substacollect"></a>
<br>
collect
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">collect <tt>&lt;</tt>name of function<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">collect <tt>&lt;</tt>name of function<tt>&gt;</tt> 
        <tt>&lt;</tt>name of other function<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">collect <tt>&lt;</tt>name of function<tt>&gt;</tt> 
        <tt>&lt;</tt>name of other function<tt>&gt;</tt> <tt>&lt;</tt>percentage<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">bracket (<a href="#substabracket">7.10</a>), antibracket 
     (<a href="#substaabrackets">7.1</a>) and the chapter on brackets 
     (<a href="#brackets">9</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Upon processing<a name="3194"></a> the expressions (hence expressions 
in hide as well as skipped expressions do not take part in this) the 
contents of the brackets<a name="3195"></a> (if there was a bracket or 
antibracket<a name="3196"></a> statement in the preceding module) are 
collected and put inside the argument of the named function. Hence if the 
expression <code>F</code> is given by
</p><pre>   F =
      a*(b^2+c)
    + a^2*(b+6)
    + b^3 + c*b + 12;
</pre>
the statement
<pre>   Collect cfun;
</pre>
will change <code>F</code> into
<pre>   F = a*cfun(b^2+c)+a^2*cfun(b+6)+cfun(b^3+c*b+12);
</pre>
The major complication<a name="3203"></a> occurs if the content of a 
bracket is so long that it will not fit inside a single term. The maximum 
size of a term is limited by the setup parameter 
maxtermsize<a name="3204"></a> (see <a href="#setupmaxtermsize">16</a>). If this size 
is exceeded, FORM will split the bracket contents over more than one term, 
in each of which it will be inside the named function. It will issue a 
warning that it has done so. <br>
<br>

<p>
If a second function is specified (the 
alternative<a name="3208"></a> collect function) and if a bracket takes 
more space than can be put inside a single term, the bracket contents will 
be split over more than one term, in each of which it will be inside the 
alternative collect function. In this case there is no need for a 
warning<a name="3209"></a> 
as the user can easily check whether this has occurred by checking whether 
the alternative function is present in the expression. <br>
<br>

</p><p>
If additionally a percentage<a name="3211"></a> is specified (an 
integer in the range of 1 to 99) this determines how big the argument must 
be as compared to MaxTermSize (see chapter <a href="#setup">16</a> on the setup) before 
use is made of the alternate collect function. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008170000000000000000"></a>
<a name="substacommuteinset"></a>
<br>
commuteinset
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">commuteinset <tt>&lt;</tt><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img25.png" alt="$\{$">list of noncommuting functions/tensors<img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img26.png" alt="$\}$"><tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="3223"></a> allows one or more sets of 
noncommuting functions and or tensors for its argument(s). The functions 
inside each set will commute with each other. It is allowed to have the 
same function inside more than one set. For a function to commute with 
itself (with for instance different arguments) it needs to be specified 
twice inside the same set. In that case it is more efficient to have a 
separate set with only two arguments. Example:
</p><pre>    I   i1,...,i10;
    F   A1,...,A10;
    CommuteInSet{A1,A3,A5},{A1,g_},{A1,A1};
    L   F = A5*A1*A5*A1*A5*A2*A3*A5*A1*A5*A3*A1;
    L   G = g_(2,i1)*g_(2,i2,i3)*A1(i2)*g_(1,i4)*g_(1,5_,i5,i6)
                    *A1(i1)*A1(i3)*g5_(1)*A3(i5)*A3(i4)*g5_(1);
    Print +f +s;
    .end

   F =
       + A1*A1*A5*A5*A5*A2*A1*A1*A3*A3*A5*A5;
   G =
       + g_(1,i4,i5,i6)*g_(2,i1,i2,i3)*A1(i1)*A1(i2)*A1(i3)*
       A3(i5)*A3(i4)*g_(1,5_);
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008180000000000000000"></a>
<a name="substacommuting"></a>
<br>
commuting
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">co[mmuting] <tt>&lt;</tt>list of functions to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">cfunctions (<a href="#substacfunctions">7.11</a>), functions (<a href="#substafunctions">7.54</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="3237"></a> is completely identical to the 
cfunction statement (see <a href="#substacfunctions">7.11</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008190000000000000000"></a>
<a name="substacompress"></a>
<br>
compress
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">comp[ress] <tt>&lt;</tt>on/off<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>), off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="3250"></a> is obsolete. The user should try 
to use the compress option of the on (see <a href="#substaon">7.99</a>) or the off (see 
<a href="#substaoff">7.98</a>) statements. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008200000000000000000"></a>
<a name="substacontract"></a>
<br>
contract
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">contract [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>];</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Statement<a name="3262"></a> causes the contraction of pairs of 
Levi-Civita<a name="3263"></a> tensors<a name="3264"></a> <code>e_</code> 
(see also <a href="#functions">8</a>) into combinations of Kronecker<a name="3266"></a> 
delta's<a name="3267"></a>. If there are contracted indices, and if 
their dimension is identical to the number of indices of the Levi-Civita 
tensors, the regular shortcuts are taken. If there are contracted indices 
with a different dimension, the contraction treats these indices 
temporarily as different and lets the contraction be ruled by the 
contraction mechanism of the Kronecker delta's. In practise this means that 
the dimension will enter via <!-- MATH
 $\delta^{\mu}_{\mu} \rightarrow {\rm
dim}(\mu)$
 -->
<img width="94" height="31" align="MIDDLE" border="0" src="./online_files/img49.png" alt="$\delta^{\mu}_{\mu} \rightarrow {\rm
dim}(\mu)$">. <br>
<br>

</p><p>
In FORM there are no upper<a name="3273"></a> and lower<a name="3274"></a> 
indices<a name="3275"></a><a name="3276"></a>. Of course the user can 
emulate those. The contract statement always assumes that there is a proper 
distribution of upper and lower indices if the user decided to work in a 
metric in which this makes a difference. Note however that due to the fact 
that the Levi-Civita tensor is considered to be imaginary, there is usually 
no need to do anything special. This is explained in the chapter on 
functions (see <a href="#functions">8</a>). <br>
<br>

</p><p>
There are several options to control which contractions will be 
taken. They are <br>

</p><p>
<table width="181">
<tbody><tr><td>Contract;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Here only a single pair of Levi-Civita tensors will be contracted. 
The pair that is selected by FORM is the pair that will give the smallest 
number of terms in their contraction.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Contract <tt>&lt;</tt>number<tt>&gt;</tt>;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>This tells FORM to keep contracting pairs of Levi-Civita tensors 
until there are <tt>&lt;</tt>number<tt>&gt;</tt> or <tt>&lt;</tt>number<tt>&gt;</tt><img width="24" height="28" align="MIDDLE" border="0" src="./online_files/img50.png" alt="$+1$"> 
Levi-Civita tensors left. A common example is

<p>
Contract 0;

</p><p>
which will contract as many pairs as possible.</p></td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Contract:<tt>&lt;</tt>number<tt>&gt;</tt>;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Here the number indicates the number of indices in the 
Levi-Civita tensors to be contracted. Only a single pair will be 
contracted and it will be the pair that gives the smallest number of 
terms.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Contract:<tt>&lt;</tt>number<tt>&gt;</tt>

<p>
<tt>&lt;</tt>number<tt>&gt;</tt>;
</p></td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The First number refers to the number of indices in the 
Levi-Civita tensors to be contracted. The second number refers to the 
number of Levi-Civita tensors that should be left (if possible) after 
contraction.</td></tr>
</tbody></table>
    <br>

</p><p>
Note that the order in which FORM selects the contractions is by 
looking at which pair will give the smallest number of terms. This means 
that usually the largest buildup of terms is at the end. This is not always 
the case, because there can be a complicated network of contracted indices. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008210000000000000000"></a>
<a name="substactable"></a>
<br>
ctable
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ctable <tt>&lt;</tt>options<tt>&gt;</tt> <tt>&lt;</tt>table to be 
declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), table (<a href="#substatable">7.132</a>),
        ntable (<a href="#substantable">7.93</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement declares a commuting<a name="3318"></a> 
table<a name="3319"></a> and is identical to the table command (see 
<a href="#substatable">7.132</a>) which has the commuting property as its default. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008220000000000000000"></a>
<a name="substactensors"></a>
<br>
ctensors
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ct[ensors] <tt>&lt;</tt>list of tensors to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), tensors 
        (<a href="#substatensors">7.134</a>), ntensors (<a href="#substantensors">7.94</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement declares commuting<a name="3333"></a> 
tensors<a name="3334"></a>. It is equal to the tensor statement (see 
<a href="#substatensors">7.134</a>) which has the commuting property as its default. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008230000000000000000"></a>
<a name="substacyclesymmetrize"></a>
<br>
cyclesymmetrize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">cy[clesymmetrize] <code>{</code><tt>&lt;</tt>name of function/tensor<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>];<code>}</code></td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">symmetrize (<a href="#substasymmetrize">7.131</a>), antisymmetrize 
(<a href="#substaantisymmetrize">7.4</a>), rcyclesymmetrize (<a href="#substarcyclesymmetrize">7.113</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The argument<a name="3350"></a> specifications are explained 
in the section on the symmetrize statements (see <a href="#substasymmetrize">7.131</a>). 

</p><p>
<br>

</p><p>
The action of this statement is to cycle-symmetrize the (specified) 
arguments of the functions that are mentioned. This means that the 
arguments are brought to `natural order' in the notation of FORM by trying 
cyclic permutations of the arguments or groups of arguments. The `natural 
order' may depend on the order of declaration of the variables. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008240000000000000000"></a>
<a name="substadeallocatetable"></a>
<br>
deallocatetable
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">DeallocateTable,name(s) of sparse table(s);</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">table (<a href="#substatable">7.132</a>), fill (<a href="#substafill">7.49</a>),
   table bases (<a href="#tablebase">12</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Works<a name="3362"></a> only for sparse<a name="3363"></a> 
tables<a name="3364"></a>. Deallocates all definitions of elements as 
obtained with `Fill'<a name="3365"></a> statements as if there never were any 
`Fill' statements for the given tables.

</p><p>
This statement exists because sometimes cleaning up big tables is needed 
when they take too much memory. This can be the case when a big tablebase 
has been used. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008250000000000000000"></a>
<a name="substadelete"></a>
<br>
delete
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">delete storage;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">save (<a href="#substasave">7.118</a>), load (<a href="#substaload">7.75</a>)</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">delete extrasymbols;</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">delete extrasymbols&gt;number;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">extrasymbols (<a href="#substaextrasymbols">7.45</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement has currently two varieties. The delete 
storage<a name="3377"></a> clears the complete storage<a name="3378"></a> 
file<a name="3379"></a> and reduces it to zero size. The effect is that 
all stored expressions are removed from the system. Because it is 
impossible to remove individual expressions from the store file (there is 
no mechanism to fill the resulting holes) it is the only way to clean up 
the storage file. If some expressions should be excluded from this 
elimination process, one should copy them first into active global 
expressions, then delete the storage file, after which the expressions can 
be written to storage again with a .store<a name="3380"></a> instruction.

</p><p>
The delete extrasymbols<a name="3381"></a><a name="3382"></a> variety removes 
extra symbols<a name="3383"></a> from the list. The default is that all 
extra symbols are removed, but one can also remove the symbols above a 
given number as in
</p><pre>   #$es = `extrasymbols_';
   ToPolynomial;
     ....some code....
   .sort
   * now the new extra symbols are not needed anylonger
   Delete extrasymbols&gt;`$es';
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008260000000000000000"></a>
<a name="substadenominators"></a>
<br>
denominators
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">denominators functionname;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="3393"></a> allows the user to rename all 
occurrences of the built-in denominator function. This built-in function is 
kind of an oddity inside FORM. Denominators are presented by a very special 
function which doesn't really have a name and hence is rather hard to 
address. In addition there are special rules connected to denominators. 
Hence it is usually better to collect denominators inside functions that 
have been defined by the user and hence allow the user to manipulate them 
at will. Yet, objects can end up inside denominator functions, especially 
when output from other programs is read in. Hence this statement allows all 
occurrences of the denominator function to be renamed into the function 
that is given in the statement. This function will work well together with 
the PolyRatFun statement in which we define a PolyFun with two arguments of 
which the second acts as a denominator and the first as a numerator:
</p><pre>   PolyRatFun,rat;
   Denominators,den;
   id den(x?) = rat(1,x);
</pre>
For more about this one should consult the part on the 
PolyRatFun<a name="3396"></a> statement 
(<a href="#substapolyratfun">7.103</a>) and the chapter on polynomials (still to be 
included because the current version can handle only polynomials in a 
single variable and is also not optimized for many occurrences that have 
identical denominators).
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008270000000000000000"></a>
<a name="substadimension"></a>
<br>
dimension
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">d[imension] <tt>&lt;</tt>number or symbol<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">index (<a href="#substaindex">7.66</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Sets the default dimension<a name="3408"></a>. This default 
dimension determines the dimension of the indices<a name="3409"></a> that are 
being declared without dimension specification as well as the dimension of 
all dummy indices<a name="3410"></a>. At the moment an index is declared 
and there is no dimension specification, FORM looks for the default 
dimension and uses that. This index will then have this dimension, even 
when the default dimension is changed at a later moment. The dummy indices 
always have the dimension of the current default dimension. If the default 
dimension is changed the dimension of all dummy indices changes with it. 
Varieties: <br>

</p><p>
<table width="181">
<tbody><tr><td>Dimension <tt>&lt;</tt>number<tt>&gt;</tt>;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Declares the number to be the default dimension. The number must be smaller than
32768 on 32bit architectures or 2147483648 on 64bit architectures. Negative numbers are not allowed.
If one wants to work with negative dimensions, the practical workaround is to use a symbolic
dimension and later replace that symbol appropriately.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Dimension <tt>&lt;</tt>symbol<tt>&gt;</tt>;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Symbol must be the name of a symbol, either previously 
declared or declarable because of an auto-declaration (see 
<a href="#substaautodeclare">7.9</a>). Declares the symbol to be the default dimension.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Dimension

<p>
<tt>&lt;</tt>symbol<tt>&gt;</tt>:<tt>&lt;</tt>symbol<tt>&gt;</tt>;
</p></td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The symbols<a name="7513"></a> must be the names of symbols, 
either previously declared or declarable because of an auto-declaration 
(see <a href="#substaautodeclare">7.9</a>). The first symbol will be the default 
dimension. The second symbol will be the first symbol minus 4. It will 
be used as such in the trace<a name="7515"></a> 
contractions<a name="7516"></a>. See also <a href="#substatracen">7.142</a> and 
<a href="#substaindex">7.66</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
Examples:
</p><pre>   Dimension 3;
   Dimension n;
   Dimension n:[n-4];
</pre>
The default dimension in FORM is 4. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008280000000000000000"></a>
<a name="substadiscard"></a>
<br>
discard
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">dis[card];</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement discards<a name="3445"></a> the current term. It can 
be very useful in statements of the type
</p><pre>   if ( count(x,1) &gt; 5 ) Discard;
</pre>
which eliminates all terms that have more than five powers of x. 
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008290000000000000000"></a>
<a name="substadisorder"></a>
<br>
disorder
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">disorder <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement is identical to the disorder<a name="3460"></a> 
option<a name="3461"></a> of the id<a name="3462"></a><a name="3463"></a> 
statement (see <a href="#substaidentify">7.60</a>). It is just a shorthand notation for 
`id disorder'. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008300000000000000000"></a>
<a name="substado"></a>
<br>
do
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">do $loopvar = lowvalue,highvalue<code>{</code>,increment<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">enddo (<a href="#substaenddo">7.37</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The syntax is the typical syntax for do-loops. The loop variable 
has to be a dollar variable. For parallel performance this variable can be 
declared local in a moduleoption (see <a href="#substamoduleoption">7.81</a>) statement, 
unless it is also used in other ways in the current module. The loop 
parameters should either be (short) integers or dollar variables or factors 
of dollar variables provided they evaluate at run time to (short) integers. 
The enddo statement should be in the same module as the do statement. In 
addition it should be properly nested with if, repeat, while and argument 
constructions.

</p><p>
The do-loop facility is in principle superfuous, because the 
repeat(<a href="#substarepeat">7.116</a>), if(<a href="#substaif">7.63</a> and the pattern matcher can 
basically do everything the do-loop can do. Sometimes however the do-loop 
is easier to program and gives more readable code as shown here:
</p><pre>   do $i = 1,5;
      id,only,x^$i = f(F[factor_^$i]);
   enddo;
</pre>
versus
<pre>   id,only,x^n?{1,2,3,4,5} = ff(n);
   repeat id ff(n?pos_) = ff(n-1)*f(F[factor_^n]);
   id ff(n?neg0_) = 1;
</pre>
One should note that the do-loop is evaluated at run time. Hence 
the dollar variables need to be evaluated at run time as well. Therefore, 
if it is possible, the preprocessor variety (see <a href="#predo">3.18</a>) is almost 
always faster in execution as in
<pre>   #do i = 1,5
      id,only,x^`i' = f(F[factor_^`i']);
   #enddo
</pre>
This can of course not be done in constructions like
<pre>   id  f1(x?$x) = f2(x);
   FactDollar,$x;
   Do $i = 1,$x[0];
     Multiply f($i,$x[$i]);
   Enddo;
</pre>
because here <code>$x</code> and its factors are only known at run time 
and may be different for each term.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008310000000000000000"></a>
<a name="substadrop"></a>
<br>
drop
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">drop;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">drop <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">ndrop (<a href="#substandrop">7.85</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In the first variety this statement<a name="3495"></a> eliminates all 
expressions<a name="3496"></a> from the system. In the second variety it 
eliminates only the expressions that are mentioned from the system. All 
expressions that are to be dropped can still be used in the r.h.s. of other 
expressions inside the current module. Basically the expressions to be 
dropped are not treated for execution and after the module has finished 
completely they are removed. See also the ndrop 
statement&nbsp;<a href="#substandrop">7.85</a>. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008320000000000000000"></a>
<a name="substadropcoefficient"></a>
<br>
dropcoefficient
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">DropCoefficient;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement replaces the coefficient of the current term by 
one. In principle it has the same effect as
</p><pre>   Multiply 1/coeff_;
</pre>
but there is always the philosophical issue what is the coefficient once 
one enters function arguments. Inside an 
Argument/EndArgument<a name="3507"></a><a name="3508"></a> environment this 
statement would drop the coefficient of the terms inside the argument.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008330000000000000000"></a>
<a name="substadropsymbols"></a>
<br>
dropsymbols
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">DropSymbols;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement removes all symbols from a term. 
It has the same effect as
</p><pre>   id,many,x?^n? = 1;
</pre>
(x and n are symbols) except for that it is much faster.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008340000000000000000"></a>
<a name="substaelse"></a>
<br>
else
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">else;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">if (<a href="#substaif">7.63</a>),
              elseif (<a href="#substaelseif">7.35</a>),
              endif (<a href="#substaendif">7.38</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
To be used in combination with an if statement (see 
<a href="#substaif">7.63</a>). The statements following the
else<a name="3529"></a><a name="3530"></a> statement until the matching 
endif<a name="3531"></a><a name="3532"></a> 
statement (see <a href="#substaendif">7.38</a>) will be executed for the current term if 
the conditions of the matching proceeding if<a name="3534"></a><a name="3535"></a> 
statement and/or all corresponding elseif<a name="3536"></a> statements (see 
<a href="#substaelseif">7.35</a>) are false. If any of the conditions of the matching 
proceeding if or elseif statements are true the statements following the 
else statement will be skipped. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008350000000000000000"></a>
<a name="substaelseif"></a>
<br>
elseif
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">elseif ( <tt>&lt;</tt>condition<tt>&gt;</tt> );</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">if (<a href="#substaif">7.63</a>),
              else (<a href="#substaelse">7.34</a>),
              endif (<a href="#substaendif">7.38</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Should be proceeded by an if<a name="3550"></a><a name="3551"></a> 
statement (see <a href="#substaif">7.63</a>) and followed at least by a matching 
endif<a name="3553"></a><a name="3554"></a> 
statement (see <a href="#substaendif">7.38</a>). If the conditions of the proceeding 
matching if statement and all proceeding matching
elseif<a name="3556"></a><a name="3557"></a> statements are false the 
condition of this elseif statement will be evaluated. If it is true, the 
statements following it until the next matching elseif,
else<a name="3558"></a><a name="3559"></a> or endif statement will be executed. 
If not, control is passed to this next elseif, else or endif statement. The 
syntax for the condition is exactly the same as for the condition in the if 
statement. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008360000000000000000"></a>
<a name="substaendargument"></a>
<br>
endargument
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endargument;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">argument (<a href="#substaargument">7.8</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Terminates an argument environment<a name="3568"></a> 
(see <a href="#substaargument">7.8</a>). The argument<a name="3570"></a> statement and its 
corresponding endargument<a name="3571"></a> statement must belong to the 
same module. Argument environments can be nested with all other 
environments. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008370000000000000000"></a>
<a name="substaenddo"></a>
<br>
enddo
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">enddo;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">do (<a href="#substado">7.30</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
See the do statement (<a href="#substado">7.30</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008380000000000000000"></a>
<a name="substaendif"></a>
<br>
endif
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endif;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">if (<a href="#substaif">7.63</a>),
              elseif (<a href="#substaelseif">7.35</a>),
              else (<a href="#substaelse">7.34</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Terminates an if<a name="3591"></a><a name="3592"></a> construction (see <a href="#substaif">7.63</a>, 
<a href="#substaelseif">7.35</a> and <a href="#substaelse">7.34</a>). If should be noted that 
if<a name="3596"></a><a name="3597"></a> 
constructions can be nested.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008390000000000000000"></a>
<a name="substaendinexpression"></a>
<br>
endinexpression
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endinexpression;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">inexpression(<a href="#substainexpression">7.67</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Only to be used in combination with the 
inexpression<a name="3606"></a><a name="3607"></a> statement. The 
combination
</p><pre>   InExpression,expr;
       Statements;
   EndInExpression;
</pre>
is a more readable version of the construction
<pre>   if ( expression(expr) );
       Statements;
   endif;
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008400000000000000000"></a>
<a name="substaendinside"></a>
<br>
endinside
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endinside;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">inside (<a href="#substainside">7.69</a>) and the chapter on $-variables 
(<a href="#dollars">6</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Terminates an `inside'<a name="3621"></a> 
environment<a name="3622"></a> (see <a href="#substainside">7.69</a>) which is 
used to operate on the contents of $-variables<a name="3624"></a> (see 
<a href="#dollars">6</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008410000000000000000"></a>
<a name="substaendrepeat"></a>
<br>
endrepeat
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endrepeat;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">repeat (<a href="#substarepeat">7.116</a>), while (<a href="#substawhile">7.149</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Ends the repeat<a name="3635"></a> 
environment<a name="3636"></a>. The repeat environment is started 
with a repeat statement (see <a href="#substarepeat">7.116</a>). The repeat and its 
matching endrepeat<a name="3638"></a> should be inside the same module. 
Repeat environments can be nested with all other environments (and other 
repeat environments). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008420000000000000000"></a>
<a name="substaendterm"></a>
<br>
endterm
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endterm;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">term (<a href="#substaterm">7.135</a>), sort (<a href="#substasort">7.124</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Terminates a term<a name="3648"></a> environment<a name="3649"></a> 
(see <a href="#substaterm">7.135</a>). Term environments<a name="3651"></a> can be nested with 
other term environments and with other environments in general. The whole 
environment should be part of one single module. See also <a href="#substasort">7.124</a>. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008430000000000000000"></a>
<a name="substaendwhile"></a>
<br>
endwhile
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">endwhile;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">while (<a href="#substawhile">7.149</a>), repeat (<a href="#substarepeat">7.116</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Terminates a while<a name="3662"></a> environment<a name="3663"></a> (see <a href="#substawhile">7.149</a>). The while 
statement and its corresponding endwhile<a name="3665"></a> statement must be part of the same 
module. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008440000000000000000"></a>
<a name="substaexit"></a>
<br>
exit
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">exit ["<tt>&lt;</tt>string<tt>&gt;</tt>"];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">setexitflag (<a href="#substasetexitflag">7.121</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Causes execution to be aborted<a name="3676"></a><a name="3677"></a> 
immediately. The string will be printed in the output. This can be used to 
indicate where FORM ran into the exit statement. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008450000000000000000"></a>
<a name="substaextrasymbols"></a>
<br>
extrasymbols
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">extrasymbols,array|vector|underscore,name;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">ToPolynomial (<a href="#substatopolynomial">7.138</a>), FromPolynomial 
(<a href="#substafrompolynomial">7.53</a>) and extra symbols 
(<a href="#sect-extrasymbols">2.11</a>).</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Starting with version 4.0 of FORM some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization(<a href="#substafactarg">7.46</a>) (which uses the topolynomial facilities 
automatically) and output simplification (see the Format 
statement <a href="#substaformat">7.52</a>).
The ToPolynomial statement<a name="3693"></a> takes each term, looks for 
objects that are not symbols to positive powers and replaces them by 
symbols. If the object has been encountered before the same symbol will be 
used, otherwise a new symbol will be defined. The object represented by the 
`extra symbol'<a name="3694"></a> is stored internally and can be printed 
if needed with the %X option in the #write instruction (<a href="#prewrite">3.61</a>). 
The representation of the extra symbols is by default the name Z followed 
by a number and an underscore character. If another name is desired this 
should be specified in an `ExtraSymbols' statement. The name given may 
contain only alphabetic characters! Because some compilers do not like the 
underscore character, there is an alternative notation for the extra 
symbols. This is just for cosmetic reasons and one cannot feed these 
symbols into the compiler this way. This is with an array notation. The 
statement
</p><pre>   ExtraSymbols,array,Ab;
</pre>
would cause the second extra symbol to be printed as <tt>Ab(2)</tt>. The total 
number of defined extra symbols is given by the built in symbol 
extrasymbols_.
The option vector in the ExtraSymbols statement is identical to the option 
array and the option underscore reverts the notation back to the default 
notation with the trailing underscore.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008460000000000000000"></a>
<a name="substafactarg"></a>
<br>
factarg
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">factarg options <code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
                [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">splitarg (<a href="#substasplitarg">7.125</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Splits<a name="3711"></a> the indicated function<a name="3712"></a> arguments into individual factors. The argument specifications 
are as in the splitarg<a name="3713"></a> statement (see 
<a href="#substasplitarg">7.125</a>). There are a few extra options:

</p><p>
<table width="91">
<tbody><tr><td>(0)
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Eliminates the coefficient<a name="7534"></a> of the term 
in the argument. Similar to Normalize,(0),....</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td>(1)
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>The coefficient of the term and its sign are pulled out 
separately.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td>(-1)
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>The coefficient is pulled out with its sign.</td></tr>
</tbody></table>
    <br>

</p><p>
In the case of the above options only the coefficient is treated. 
When these options are not used the whole term is treated as in:
</p><pre>    Symbols a,b,c;
    CFunctions f,f1,f2,f3;
    Local F = f(-3*a*b)+f(3*a*b)
             +f1(-3*a*b)+f1(3*a*b)
             +f2(-3*a*b)+f2(3*a*b)
             +f3(-3*a*b)+f3(3*a*b);
    FactArg,f;
    Factarg,(0),f1;
    Factarg,(1),f2;
    Factarg,(-1),f3;
    Print;
    .end

   F =
      f(a,b,-1,3) + f(a,b,3) + 2*f1(a*b) + f2(a*b,-1,3) + f2(a*b,3)
      + f3(a*b,-3) + f3(a*b,3);
</pre>
When no extra options are used, starting with version 4.0, the whole 
argument is factorized over the rationals. This means that
<pre>    f(x^2+2*x*y+y^2) --&gt; f(y + x,y + x,1)
</pre>
It should be noticed that FORM can although the internal algorithms can
only factorize expressions with numbers and symbols, FORM redefines all
non-symbol objects temporarily into symbols and at the end substitutes them 
back. This is done with a mechanism that is similar to that of the 
ToPolynomial statement.

<p>
See also the On OldfactArg; and Off OldFactArg statements for a 
compatibility mode with versions before version 4.0.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008470000000000000000"></a>
<a name="substafactdollar"></a>
<br>
factdollar
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">factdollar <tt>&lt;</tt>name of dollar variable<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The FactDollar statement will factorize a dollar expression. If 
the dollar expression was already factorized the old factors will be 
removed first. Unlike expressions (see <a href="#substafactorize">7.48</a>) where only 
either the expanded or the factorized version exists, with dollar 
expressions we have both versions simultaneously. This means that one can 
refer to the complete dollar in its unfactorized form and its factors. The 
factors are indicated between braces as in <code>$x[1]</code> which would be the 
first factor. The number of factors of <code>$x</code> is given by <code>$x[0]</code>. 
One can also obtain the number of factors of a dollar variable with the 
numfactors_ function (see <a href="#funnumfactors">8.46</a>).

</p><p>
The index indicating the number of the factor can be a nonzero 
integer, no greater than the number of factors, or (a factor of) a dollar 
variable that evaluates into such a number. Composite expressions are not 
allowed. They should be worked out first in a separate dollar variable, 
after which this dollar variable can then be used as a factor indicator.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008480000000000000000"></a>
<a name="substafactorize"></a>
<br>
factorize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">factorize <code>{</code><tt>&lt;</tt>name of expression(s)<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
If no expressions are mentioned all expressions will be affected 
by the action of this statement. One may exclude certain expressions with 
the nfactorize statement (see <a href="#substanfactorize">7.86</a>). If one or more 
expressions are mentoned they will be added to the list of expressions that 
will be affected.

</p><p>
The statement causes the output expression(s) that is/are marked 
as such to be factorized after they have been processed and already written 
to the output. This means that each expression, after having been written, 
is read again and factorized. Then the factorized result is written over 
the original output. After that FORM will start executing the statements of 
the current module on the next expression, sort it, write it to output, and 
if necessary read it again and factorize it.

</p><p>
Expressions never exists in two varieties as the dollar variable 
that have been factorized. It is either unfactorized (default) or 
factorized. An expression remains factorized untill an UnFactorize 
statement is encoutered that mentions that this expression should be 
brought to unfactorized representation (see also 
UnFactorize&nbsp;<a href="#substaunfactorize">7.145</a> and 
NunFactorize&nbsp;<a href="#substanunfactorize">7.95</a>).

</p><p>
One should realize that factorization of complicated expressions 
can be a rather costly operation.

</p><p>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008490000000000000000"></a>
<a name="substafill"></a>
<br>
fill
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">fill <tt>&lt;</tt>tableelement<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt> [,<tt>&lt;</tt>moreexpressions<tt>&gt;</tt>];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">table (<a href="#substatable">7.132</a>), 
                fillexpression (<a href="#substafillexpression">7.50</a>),
                printtable (<a href="#substaprinttable">7.107</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The standard<a name="3774"></a> way to define elements of a 
table<a name="3775"></a>. In the left hand 
side one specifies the table element without the extra function arguments 
that could potentially occur (see <a href="#substatable">7.132</a>). In the right hand 
side one specifies what the table element should be substituted by. 
Example:
</p><pre>    Table tab(1:2,1:2,x?);
    Fill tab(1,1) = x+y;
    Fill tab(2,1) = (x+y)^2;
    Fill tab(1,2) = tab(1,1)+y;
    Fill tab(2,2) = tab(2,1)+y^2;
</pre>
The first fill statement is a bit like a continuous attempt to try the 
substitution
<pre>    id  tab(1,1,x?) = x+y;
</pre>
The last two fill statements show that one could use the table 
recursively<a name="3781"></a>. 
If a real loop occurs the program may terminate due to
stack<a name="3782"></a> overflow.

<p>
It is possible to define several table elements in one statement. 
In that case the various elements are separated by commas. The last index 
is the first one to be raised. This means that in the above example one 
could have written:
</p><pre>    Table tab(1:2,1:2,x?);
    Fill tab(1,1) = x+y,tab(1,1)+y,(x+y)^2,tab(2,1)+y^2;
</pre>
<br>
<br>
<br>

<p>
One warning<a name="3786"></a> is called for. One should avoid using 
expressions in the right hand side of fill statements:
</p><pre>    Table B(1:1);
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    Drop dummy;
    .sort
    Local F = B(1);
    Print;
    .end
</pre>
In the example a crash will result, because when we use the table element 
the expression dummy doesn't exist anymore. In a fill statement the r.h.s. 
is not expanded. Hence it keeps the reference to the expression dummy. When 
the table element is used the reference to the expression dummy is inserted 
and expanded. Hence one obtains the contents of dummy that exist at the 
moment of use. This is illustrated in the following example:
<pre>    Table B(1:1);
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    .sort
    Local F = B(1);
    Print;
    .sort
    Drop;
    .sort
    Local dummy = 2;
    .sort
    Local F = B(1);
    Print;
    .end
</pre>
The final value of F will be 2, not 1.

<p>
A way to get around this problem is to force the evaluation of 
the table definition by using dollar<a name="3791"></a> 
variables<a name="3792"></a>:
</p><pre>    Table B(1:1);
    Local dummy = 1;
    .sort
    #$value = dummy;
    Fill B(1) = `$value';
    Drop dummy;
    .sort
    Local F = B(1);
    Print;
    .end
</pre>
Here we use the character representation of the contents of the dollar 
variable to obtain an expression that doesn't need any further evaluation. 
If we would put
<pre>    fill B(1) = $value;
</pre>
a reference to the dollar variable would be inserted and it would only be 
evaluated at use again. In principle this could cause similar problems.

<p>
Not dropping the expression dummy can sometimes give the correct 
result, but is potentially still unsafe. 
</p><pre>    Table B(1:1);
    Local u = 2;
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    Drop dummy;
    .sort
    Local v = 5;
    Local F = B(1);
    Print;
    .end
</pre>
Here the answer will be 5, because after u has been dropped the expressions 
will be renumbered. Hence now dummy becomes the first expression, and 
eventually v becomes the second expression. The references in the table 
elements are not renumbered. Hence the r.h.s. of B(1) keeps pointing at the 
second expression, which at the moment of application has the value 5. One 
can see now also why the original example crashes. First dummy was the 
first expression and at the moment of application F is the first (existing) 
expression. Hence the substitution of B(1) causes a self reference and 
hence an infinite loop. Eventually some buffer will 
overflow<a name="3799"></a>.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008500000000000000000"></a>
<a name="substafillexpression"></a>
<br>
fillexpression
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">fillexpression <tt>&lt;</tt>table<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>(<tt>&lt;</tt>x1<tt>&gt;</tt>,...,<tt>&lt;</tt>xn<tt>&gt;</tt>);</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">fillexpression <tt>&lt;</tt>table<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>(<tt>&lt;</tt>funname<tt>&gt;</tt>);</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">table (<a href="#substatable">7.132</a>), 
                fill (<a href="#substafill">7.49</a>) and the table_ function 
(<a href="#funtable">8.61</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Used<a name="3824"></a> to dynamically<a name="3825"></a>
load<a name="3826"></a> a table<a name="3827"></a> during runtime. When 
there are n symbols (here called x1 to xn) it is assumed that the table is 
n-dimensional. The expression must previously have been bracketed in these 
symbols and each of the brackets<a name="3828"></a> has the effect of a 
fill<a name="3829"></a> statement in which the powers of the x1 to xn refer to the 
table elements. Brackets that do not have a corresponding table element are 
skipped.

</p><p>
In the case that only a function name is specified the arguments 
of the function refer to the table elements.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008510000000000000000"></a>
<a name="substafixindex"></a>
<br>
fixindex
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">fi[xindex] <code>{</code><tt>&lt;</tt>number<tt>&gt;</tt>:<tt>&lt;</tt>value<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">index (<a href="#substaindex">7.66</a>) and chapter <a href="#metric">15</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Defines <code>d_(number,number) = value</code> in which number is the 
number<a name="3843"></a> of a fixed<a name="3844"></a> index<a name="3845"></a> 
(hence a positive short integer with a value less than 
ConstIndex<a name="3846"></a> (see <a href="#setup">16</a>). The value should be a 
short<a name="3848"></a> integer, i.e. its absolute value should be less 
than <img width="26" height="16" align="BOTTOM" border="0" src="./online_files/img51.png" alt="$2^{15}$"> on 32<a name="3850"></a> bit computers and less than <img width="26" height="16" align="BOTTOM" border="0" src="./online_files/img52.png" alt="$2^{31}$"> on 
64<a name="3852"></a> bit 
computers. One can define more than one fixed index in one statement. 
Before one would like to solve problems involving the choice of a metric 
with this statement, one should consult the chapter on the use of a 
metric<a name="3853"></a> 
(chapter <a href="#metric">15</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008520000000000000000"></a>
<a name="substaformat"></a>
<br>
format
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">fo[rmat] <tt>&lt;</tt>option<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">print (<a href="#substaprint">7.105</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Controls the format<a name="3865"></a> for the 
printing<a name="3866"></a> of expressions. There is a variety of options.

</p><p>
<table width="159">
<tbody><tr><td><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">number<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Output will be printed using the indicated number of 
characters per line. The default is 72. Numbers outside the range 1-255 are 
corrected to 72. Positive numbers less than 39 are corrected to 39.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>float<a name="7579"></a><a name="7580"></a> 
<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>[</tt><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">number<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"><tt>]</tt>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Numbers are printed in floating<a name="7589"></a> 
point notation, even though internally they remain fractions. This is 
purely cosmetic. If no number is specified the precision of the output will 
be 10 digits. If a number is specified it indicates the number of digits to 
be used for the precision.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>rational<a name="7596"></a><a name="7597"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Output format is switched back to rational numbers (in 
contrast to floating point output). This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>nospaces<a name="7610"></a><a name="7611"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The output is printed without the spaces that make the 
output slightly more readable. This gives a more compact output.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>spaces<a name="7624"></a><a name="7625"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The output is printed with extra spaces between the terms 
and around certain operators to make it slightly more readable. This is the 
default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>O0<a name="7638"></a><a name="7639"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>FORM will turn off output optimization. See the section 
on output optimization <a href="#optimization">11</a></td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>O1[options]<a name="7654"></a><a name="7655"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>FORM will use level 1 output optimization. See the section 
on output optimization <a href="#optimization">11</a></td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>O2[options]<a name="7670"></a><a name="7671"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>FORM will use level 2 output optimization. See the section 
on output optimization <a href="#optimization">11</a></td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>O3[options]<a name="7686"></a><a name="7687"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>FORM will use level 3 output optimization. See the section 
on output optimization <a href="#optimization">11</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>fortran<a name="7702"></a><a name="7703"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The output is printed in a way that is readable by a 
fortran compiler. This includes continuation characters and the splitting 
of the output into blocks of no more than 15 continuation lines. This 
number can be changed with the setup parameter ContinuationLines (see 
<a href="#setup">16</a>). In addition dotproducts are printed with the `dotchar' 
in the place of the period between the vectors. This dotchar can be set in 
the setup file (see <a href="#setup">16</a>). Its default is the underscore character.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>doublefortran<a name="7718"></a><a name="7719"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as the fortran mode, but fractions are printed with 
double floating point numbers, because some compilers convert numbers like 
1. into 1.E0. With this format FORM will force double precision by using 
1.D0.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>quadruplefortran<a name="7733"></a><a name="7734"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as the fortran mode, but fractions are printed with 
quadruple floating point numbers, because some compilers convert numbers like 
1. into 1.E0. With this format FORM will force quadruple precision by using 
1.Q0.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>quadfortran<a name="7748"></a><a name="7749"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as quadruplefortran.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>fortran90<a name="7762"></a><a name="7763"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Similar to the fortran option, but prints the 
continuation lines according to the syntax of Fortran 90. If the fortran90 
option is followed by a comma and a string that does not contain white space 
or other comma's, this string is attached to all numbers in coefficients of 
terms. Example: 
<br><tt>      Format Fortran90,.0_ki;</tt> 
<br>
which would give in the printout: 
<br><tt>      +23.0_ki/32.0_ki*a**2&amp; </tt> 
<br><tt>    &amp; +34.0_ki/1325.0_ki*a**3</tt> 
<br>
When there is no string attached it defaults to a period as in the regular 
Fortran option.
</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>C<a name="7779"></a><a name="7780"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Output will be C compatible. The
exponent<a name="7787"></a> operator (<img width="15" height="14" align="BOTTOM" border="0" src="./online_files/img13.png" alt="$\wedge$">) is represented by the 
function pow<a name="7788"></a>. It is the responsibility of the user that this 
function will be properly defined. Dotproducts are printed with the 
`dotchar'<a name="7789"></a> in the place of the period between the vectors. 
This dotchar can be set in the setup file (see <a href="#setup">16</a>). Its default is 
the underscore<a name="7791"></a> character.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>maple<a name="7798"></a><a name="7799"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Output will be as much as possible compatible with Maple 
format. It is not guaranteed that this is perfect.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>mathematica<a name="7812"></a><a name="7813"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Output will be as much as possible compatible with 
Mathematica format. It is not guaranteed that this is perfect.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>reduce<a name="7826"></a><a name="7827"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Output will be as much as possible compatible with 
Reduce format. It is not guaranteed that this is perfect.</td></tr>
</tbody></table>
    <br>

</p><p>
The last few formats have not been tried out extensively. The 
author is open for suggestions.

</p><p>
<table width="159">
<tbody><tr><td>normal<a name="7840"></a><a name="7841"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Will return to the regular FORM formatting mode.</td></tr>
</tbody></table>
    <br>

</p><p>
If the statement has no arguments the formatting will be reset to 
the mode it was in when the program started.
<br>
<br>

</p><p>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008530000000000000000"></a>
<a name="substafrompolynomial"></a>
<br>
frompolynomial
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">frompolynomial</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">factarg (<a href="#substafactarg">7.46</a>), ToPolynomial 
(<a href="#substatopolynomial">7.138</a>) and ExtraSymbols (<a href="#substaextrasymbols">7.45</a>,
<a href="#sect-extrasymbols">2.11</a>).</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Starting with version 4.0 of FORM some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization(<a href="#substafactarg">7.46</a>) and output simplification (still to be 
implemented). Whereas the ToPolynomial statement takes each term, looks for objects 
that are not symbols to positive powers and replaces them by symbols the 
FromPolynomial does the opposite: it replaces the newly defined extra 
symbols and replaces them back by their original meaning.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008540000000000000000"></a>
<a name="substafunctions"></a>
<br>
functions
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">f[unctions] <tt>&lt;</tt>list of functions to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">cfunctions (<a href="#substacfunctions">7.11</a>), 
           tensors (<a href="#substatensors">7.134</a>),
           ntensors (<a href="#substantensors">7.94</a>),</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">table (<a href="#substatable">7.132</a>),
           ntable (<a href="#substantable">7.93</a>),
           ctable (<a href="#substactable">7.21</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Used to declare one or more functions<a name="3999"></a>. The functions declared 
with this statement will be noncommuting<a name="4000"></a>. For 
commuting<a name="4001"></a> functions one 
should use the cf[unctions] statement (see <a href="#substacfunctions">7.11</a>). 
Functions can have a number of properties that can be set in the 
declaration. This is done by appending the options to the name of the 
function. These options are:

</p><p>
<table width="186">
<tbody><tr><td>name#r
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is considered to be a real<a name="7864"></a> function (default).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name#c
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is considered to be a complex<a name="7879"></a> function. This means 
that internally two spaces are reserved. One for the variable name and one 
for its complex conjugate name#.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name#i
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is considered to be imaginary<a name="7896"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(s[ymmetric])
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is totally symmetric<a name="7909"></a>. This means that during 
normalization FORM will order the arguments according to its internal 
notion of order by trying permutations. The result will depend on the order 
of declaration of variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(a[ntisymmetric])
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is totally antisymmetric<a name="7924"></a>. This means that 
during normalization FORM will order the arguments according to its 
internal notion of order and if the resulting permutation of arguments is 
odd the coefficient of the term will change sign. The order will depend on 
the order of declaration of variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(c[yclesymmetric])
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is cycle<a name="7939"></a> 
symmetric<a name="7940"></a> in all its arguments. 
This means that during normalization FORM will order the arguments 
according to its internal notion of order by trying cyclic permutations. 
The result will depend on the order of declaration of variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name(r[cyclesymmetric)

<p>
name(r[cyclic])

</p><p>
name(r[eversecyclic])
</p></td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function is reverse<a name="7955"></a> 
cycle symmetric<a name="7956"></a> in all its arguments. This 
means that during normalization FORM will order the arguments according 
to its internal notion of order by trying cyclic permutations and/or a 
complete reverse order of all arguments. The result will depend on the 
order of declaration of variables.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="186">
<tbody><tr><td>name&lt;number

<p>
name&lt;=number

</p><p>
name&gt;number

</p><p>
name&gt;=number
</p></td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The function has a restriction on the number of 
arguments. If the number of arguments of an occurrence of the function is 
not fulfilling the condition during normalization FORM will set the term 
equal to zero.</td></tr>
</tbody></table>
    <br>
<br>

</p><p>
The complexity properties, the symmetric properties and the 
number of arguments restrictions can be 
combined. In that case the complexity properties should come first and the 
argument restrictions should come last as in
</p><pre>    Function f1#i(symmetric)&gt;=4&lt;8;
    Function f1#i&lt;=8;
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008550000000000000000"></a>
<a name="substafunpowers"></a>
<br>
funpowers
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">funpowers <tt>&lt;</tt>on/off<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>), off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4056"></a> is obsolete<a name="4057"></a>. The 
user should try to use the funpowers option of the on<a name="4058"></a> (see 
<a href="#substaon">7.99</a>) or the off<a name="4060"></a> (see <a href="#substaoff">7.98</a>) statements. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008560000000000000000"></a>
<a name="substagfactorized"></a>
<br>
gfactorized
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Definition statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">g[lobal]factorized <tt>&lt;</tt>option<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a>, the 
factorize statement&nbsp;<a href="#substafactorize">7.48</a> and the LocalFactorized</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">statement&nbsp;<a href="#substalfactorized">7.74</a>.</td>
</tr>
</tbody></table>

</p><p></p>

<p>
The syntax is like the syntax of the LocalFactorized (or 
LFactorized) statement&nbsp;<a href="#substalfactorized">7.74</a>. The only difference is that 
now the expression defined by the statement will become a global 
expression (see the Global statement&nbsp;<a href="#substaglobal">7.57</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008570000000000000000"></a>
<a name="substaglobal"></a>
<br>
global
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Definition statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">g[lobal] <tt>&lt;</tt>name<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">g[lobal] <tt>&lt;</tt>names of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">См. также</td>
<td align="LEFT">local (<a href="#substalocal">7.76</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Используется для объявления глобальных выражений<a name="4089"></a> <a name="4090"></a>. 
Глобальное выражение - это такое выражение, которое остается активным, до первой инструкции .store<a name="4091"></a>. 
В этот момент оно сохраняется в `накопительном файле'<a name="4092"></a><a name="4093"></a> и прекращает обрабатываться. 
После этого оно может использаваться в правой части выражений и конструкций id<a name="4094"></a> (см. <a href="#substaidnew">7.61</a>). 
Глобальные выражения, которые находятся в накопительном файле, могут быть сохранены в файл на диск<a name="4096"></a> при помощи конструкции save (см. <a href="#substasave">7.118</a>) для использования в последующих программах.

</p><p>
Существует две версии конструкции global. 
В первой - выражение объявляется и заполняется выражением в правой части. 
Левая и правая части разделяются знаком = . 
В этом случае выражение может иметь аргументы, которые будут обрабатываться как фиктивные аргументы<a name="4098"></a> 
после того, как глобальное выражение будет сохранено инструкцией .store. 
Помните, что использование аргументов часто можно обойти при помощи функции replace_ (см. <a href="#funreplace">8.53</a>) как в
</p><pre>    Global F(a,b) = (a+b)^2;
    .store
    Local FF = F(x,y);
    Local GG = F*replace_(a,x,b,y);
</pre>
потому что оба объявления дадут один и тот же результат.

<p>
Вторая версия конструкции global не имеет знака = и не имеет правой части. 
Она может использоваться для замены локального выражения<a name="4102"></a> на глобальное. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008580000000000000000"></a>
<a name="substagoto"></a>
<br>
goto
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">go[to] <tt>&lt;</tt>label<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">label (<a href="#substalabel">7.73</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Causes<a name="4113"></a> processing to proceed at the indicated 
label<a name="4114"></a> statement 
(see <a href="#substalabel">7.73</a>). This label statement must be in the same module. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008590000000000000000"></a>
<a name="substahide"></a>
<br>
hide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">hide;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">hide <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">nhide (<a href="#substanhide">7.88</a>),
              unhide (<a href="#substaunhide">7.146</a>),
              nunhide (<a href="#substanunhide">7.96</a>),
              pushhide (<a href="#substapushhide">7.110</a>),
              pophide (<a href="#substapophide">7.104</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In the first variety this statement marks all currently active 
expressions for being put in hidden<a name="4130"></a> storage. In the second variety it marks 
only the specified active<a name="4131"></a> expressions as such. <br>
<br>

</p><p>
If an expression is marked for being hidden, it will be copied to 
the `hide<a name="4133"></a> file'<a name="4134"></a>, a storage which is 
either in memory or on file depending on the combined size of all 
expressions being hidden. If this size exceeds the size of the setup 
parameter scratchsize<a name="4135"></a> (see <a href="#setup">16</a>) the storage will 
be on file. If it is less, the storage will be in memory. An expression 
that has been hidden is not affected by the statements in the modules as 
long as it remains hidden, but it can be used inside other expressions in 
the same way skipped<a name="4137"></a> expressions (see 
<a href="#substaskip">7.123</a>) or active expressions can be used. In particular all its 
bracket<a name="4139"></a> information (see <a href="#substabracket">7.10</a>) is retained 
and can be accessed, including possible bracket<a name="4141"></a> 
indexing. <br>
<br>

</p><p>
The hide mechanism is particularly useful if an expression is not 
needed for a large number of modules. It has also advantages over the 
storing of global expressions after a .store<a name="4143"></a> instruction (see 
<a href="#instrstore">4</a>), because the substitution of global expressions is slower 
(name definitions may have changed and have to be checked) and also a 
possible bracket index is not maintained by the .store instruction. 
<br>
<br>

</p><p>
Expressions can be returned from a hidden status into active 
expressions with the unhide<a name="4146"></a> statement (see 
<a href="#substaunhide">7.146</a>). One might want to consult the nhide<a name="4148"></a> 
statement (<a href="#substahide">7.59</a>) as well. <br>
<br>

</p><p>
When an expression is marked to be hidden it will remain just 
marked until execution starts in the current module. When it is the turn of 
the expression to be executed, it is copied to the hide file instead. 
<br>
<br>

</p><p>
Note that a .store instruction will simultaneously remove all 
expressions from the hide system. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008600000000000000000"></a>
<a name="substaidentify"></a>
<br>
identify
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Тип</td>
<td align="LEFT">Исполняемая конструкция</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">id[entify] [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">also (<a href="#substaalso">7.2</a>),
              idnew (<a href="#substaidnew">7.61</a>),
              idold (<a href="#substaidold">7.62</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Конструкция пытается распознать паттерн<a name="4168"></a><a name="4169"></a><a name="4170"></a>. 
Если паттерн найден один или более раз, он будет заменен на выражение в правой части,
принимая во внимание возможные замены подстановочных символов<a name="4171"></a>. 
Описание паттернов см. в главе <a href="#pattern">5</a>.

</p><p>
Опции: <br>

</p><p>
<table width="181">
<tbody><tr><td>multi<a name="7979"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>
Эта опция только для комбинаций символов и скалярных произведений, 
и она не использует возможностей подстановочных символов. 
FORM определяет, сколько раз встречается паттерн, за одну операцию. 
Затем правая часть подставляется в этой степени. 
Так происходит по умолчанию для такого типа паттернов.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>many<a name="7993"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>
Так происходит по умолчанию для паттернов, которые содержат объекты кроме символов и скалярных произведений. 
Шаблон сопоставляется и вынимается. 
FORM пытается снова распознать паттерн в оставшемся терме. 
Так будет продолжаться до тех пор, пока паттерн распознается. 
Затем для каждого совпадения в правой части происходит подстановка 
(с соответствующей заменой подстановочных символов).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>select<a name="8007"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>
За этой опцией должны следовать одно или более множеств<a name="8014"></a>. 
После множеств можно задавать паттерн. 
Шаблон будет заменен, только если ни один из объектов, упомянутых в множествах, 
не останется после того, как шаблон был вынут.
Это имеет место только для объектов 'на уровне корня'; 
т.е. поисковик шаблонов на будет заглядывать в аргументы функции. 
Обратите внимение, что это частный случай опции 'only'.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>once<a name="8021"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The pattern is matched only once, even if it occurs more than once 
in the term. The first match that FORM encounters is taken. When wildcards 
are involved, this may depend on the order of declaration of variables. It 
could also be installation dependent. Also the setting of 
properorder<a name="8028"></a> (see <a href="#substaon">7.99</a> and <a href="#substaoff">7.98</a>) 
could be relevant. Try to write programs in such a way that the outcome 
does not depend on which match is taken.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>only<a name="8038"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The pattern will match only if there is an exact match in 
the powers of the symbols and dotproducts present.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ifmatch<img width="28" height="28" align="MIDDLE" border="0" src="./online_files/img53.png" alt="$-\!\!&gt;$"><a name="8051"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>This option should be followed by the name (or number) of a 
label<a name="8058"></a>. If the pattern matches, the replacement will be made 
after which the execution continues at the label.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ifnomatch<img width="28" height="28" align="MIDDLE" border="0" src="./online_files/img53.png" alt="$-\!\!&gt;$"><a name="8065"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>This option should be followed by the name (or number) of a 
label<a name="8072"></a>. If the pattern does not match, 
execution continues at the label.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>disorder<a name="8079"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>This option is used for products of 
noncommuting<a name="8086"></a> functions<a name="8087"></a> or 
tensors<a name="8088"></a>. The match will only take place if the 
order of the functions in the match is different from what FORM would have 
made of it if the functions would be commuting<a name="8089"></a>. Hence if 
the functions in the term are in the order that FORM would give them if 
they would be commuting (which depends on the order of declaration) there 
will be no match. This can be rather handy when using wildcards as in <tt>F(a?)*F(b?)</tt>.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008610000000000000000"></a>
<a name="substaidnew"></a>
<br>
idnew
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">idn[ew] [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>),
              also (<a href="#substaalso">7.2</a>),
              idold (<a href="#substaidold">7.62</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4212"></a> and its options are completely 
identical to the regular id<a name="4213"></a> or identify<a name="4214"></a> statement 
(see <a href="#substaidentify">7.60</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008620000000000000000"></a>
<a name="substaidold"></a>
<br>
idold
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ido[ld] [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>),
              also (<a href="#substaalso">7.2</a>),
              idnew (<a href="#substaidnew">7.61</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
This statement<a name="4232"></a> and its options are completely 
identical to the regular also<a name="4233"></a> statement (see <a href="#substaalso">7.2</a>). 
The options are described with the id<a name="4235"></a> or identify<a name="4236"></a> 
statement (see <a href="#substaidentify">7.60</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008630000000000000000"></a>
<a name="substaif"></a>
<br>
if
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">if ( <tt>&lt;</tt>condition<tt>&gt;</tt> );</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">if ( <tt>&lt;</tt>condition<tt>&gt;</tt> ) <tt>&lt;</tt>executable statement<tt>&gt;</tt></td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">elseif (<a href="#substaelseif">7.35</a>),
              else (<a href="#substaelse">7.34</a>),
              endif (<a href="#substaendif">7.38</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Used<a name="4254"></a> for executing parts of code only when certain 
conditions<a name="4255"></a> are met. Works together with the 
else<a name="4256"></a> statement (see <a href="#substaelse">7.34</a>), the elseif<a name="4258"></a> 
statement (see <a href="#substaelseif">7.35</a>) and the endif<a name="4260"></a> statement 
(see <a href="#substaendif">7.38</a>). There are two versions. In the first the if 
statement must be accompanied by at least an endif statement. In that case 
the statements between the if statement and the endif statement will be 
executed if the condition is met. It is also possible to use elseif and 
else statements to be more flexible. This is done in the same way as in 
almost all computer languages.

</p><p>
In the second form the if statement does not terminate with a 
semicolon<a name="4262"></a>. It is followed by a single regular statement. 
No endif statement should be used. The single statement will be executed if 
the condition is met.

</p><p>
The condition in the if statement should be enclosed by 
parentheses. Its primary components are:

</p><p>
<table width="159">
<tbody><tr><td>count()<a name="8099"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Returns an integer power counting value for the current 
term. Should have arguments that come in pairs. The first element of the 
pair is a variable. The second is its integer weight<a name="8106"></a>. The 
types of variables that are allowed are symbols, dotproducts, functions, 
tensors, tables and vectors. The weights can be positive as well as 
negative. They have to be short integers (Absolute value <img width="42" height="33" align="MIDDLE" border="0" src="./online_files/img54.png" alt="$&lt; 2^{15}$"> on 
32<a name="8108"></a> bit computers and <img width="42" height="33" align="MIDDLE" border="0" src="./online_files/img55.png" alt="$&lt; 2^{31}$"> on 64<a name="8110"></a> bit 
computers). The vectors can have several options appended to their name. 
This is done by putting a + after the name of the vector and have this 
followed by one or more of the following letters:

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">v</td>
<td align="LEFT">Loose vectors with an index are taken into account.</td>
</tr>
<tr><td align="LEFT">d</td>
<td align="LEFT">Vectors inside dotproducts are taken into account.</td>
</tr>
<tr><td align="LEFT">f</td>
<td align="LEFT">Vectors inside tensors are taken into account.</td>
</tr>
<tr><td align="LEFT">?set</td>
<td align="LEFT"><table width="499">
<tbody><tr><td>The set should be a set of functions. Vectors inside 
the functions that are members of the set are taken into account. It is 
assumed that those functions are linear in the given vector</td></tr>
</tbody></table></td>
</tr>
</tbody></table> <br>

</p><p>
When no options are specified the result is identical to +vfd.</p></td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>match()<a name="8125"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument of the match condition can be any left hand 
side of an id statement, including options as once<a name="8132"></a>, 
only<a name="8133"></a>, multi<a name="8134"></a>, many<a name="8135"></a> and 
select<a name="8136"></a> (see <a href="#substaidnew">7.61</a>). The id of the id statement 
should not be included. FORM will invoke the pattern<a name="8138"></a> 
matcher and see how many times the pattern matches. This number is 
returned. In the case of once or only this is of course at most one.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>expression()<a name="8146"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument(s) of this condition is/are a list of 
expressions. In the case that the current term belongs to any of the given 
expressions the return value is 1. If it does not belong to any of the 
given expressions the return value is 0.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>occurs()<a name="8159"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument(s) of this condition is/are a list of 
variables. In the case that any of the variables occurs inside the current 
term (including inside function arguments) the 
return value is 1. Otherwise the return value is zero.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>findloop()<a name="8172"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The arguments are as in the 
replaceloop<a name="8179"></a> statement (see <a href="#substareplaceloop">7.117</a>) with 
the exception of the outfun which should be omitted. If FORM detects an 
index<a name="8181"></a> loop in the current term that fulfils the specified 
conditions the return value is 1. It is 0 otherwise.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>multipleof()<a name="8189"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The argument should be a positive integer. This object is 
to be compared with a number (could be obtained from a condition) and if 
this number is an integer multiple of the argument there will be a match. 
If should be obvious that such a compare only makes sense for the == and != 
operators.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">integer<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>To be compared either with another number, the result of a 
condition or a multipleof object.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>coefficient<a name="8214"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Represents the coefficient of the current term.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>$-variable
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Will be evaluated at runtime when the if statement is 
encountered. Should evaluate into a numerical value. If it does not, an 
error will result.</td></tr>
</tbody></table>
    <br>

</p><p>
All the above primary components result in numerical objects. 
Such objects can be compared to each other in structures of the type 
<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">obj1<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"> <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">operator<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"> <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">obj2<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">. The result of such a compare is 
either true (or 1) or false (or 0). The operators are:

</p><p>
<table width="91">
<tbody><tr><td><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Results in true if object 1 is greater than object 2.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Results in true if object 1 is less than object 2.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="17" height="15" align="BOTTOM" border="0" src="./online_files/img34.png" alt="$=$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Same as ==.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="29" height="15" align="BOTTOM" border="0" src="./online_files/img33.png" alt="$==$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Results in true if both objects have the same value.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img31.png" alt="$&gt;=$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Results in true if object 1 is greater than or equal to object 2.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img32.png" alt="$&lt;=$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Results in true if object 1 is less than or equal to object 2.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="25" height="14" align="BOTTOM" border="0" src="./online_files/img35.png" alt="$!=$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Results in true if object 1 does not have the same value 
as object 2.</td></tr>
</tbody></table>
    <br>

</p><p>
If the condition for true is not met, false is returned. Several of the 
above compares can be combined with logical operators. For this it is 
necessary to enclose the above compares within parentheses. This forces 
FORM to interpret the hierarchy<a name="4347"></a> of the operators 
properly. The extra logical operators are

</p><p>
<table width="91">
<tbody><tr><td><img width="13" height="31" align="MIDDLE" border="0" src="./online_files/img37.png" alt="$\vert\vert$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>The or operation. True if at least one of the objects 1 
and 2 is true (or nonzero). False or zero if both are false or zero.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td><img width="29" height="14" align="BOTTOM" border="0" src="./online_files/img36.png" alt="$\&amp;\&amp;$">
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>The and operation. True if both the objects 1 
and 2 are true (or nonzero). False or zero if at least one is false or zero.</td></tr>
</tbody></table>
    <br>

</p><p>
Example:
</p><pre>    if ( ( match(f(1,x)*g(?a)) &amp;&amp; ( count(x,1,v+d,1) == 3 ) )
         || ( expression(F1,F2) == 0 ) );
        some statements
    endif;
    if ( ( ( match(f(1,x)*g(?a)) == 0 ) &amp;&amp; ( count(x,1,v+d,1) == 3 ) )
         || expression(F1,F2) );
        some statements
    endif;
</pre>
We see that <code>match()</code> is equivalent to <code>( match() != 0 )</code> and 
something similar for <code>expression()</code>. This shorthand<a name="4358"></a> 
notation can make a program slightly more readable.

<p>
<b>Warning! </b> The if-statement knows only logical values as the result of 
operations. Hence the answer to anything that contains parenthesis (which 
counts as the evaluation of an expression) is either true (1) or false (0). 
Hence the object (5) evaluates to true. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008640000000000000000"></a>
<a name="substaifmatch"></a>
<br>
ifmatch
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ifmatch<img width="28" height="28" align="MIDDLE" border="0" src="./online_files/img53.png" alt="$-\!\!&gt;$"> <tt>&lt;</tt>label<tt>&gt;</tt> <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4374"></a> is identical to the ifmatch option 
of the id statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   ifmatch-&gt; ....
</pre>
is just a shorthand notation for
<pre>   id ifmatch-&gt; ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008650000000000000000"></a>
<a name="substaifnomatch"></a>
<br>
ifnomatch
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ifnomatch<img width="28" height="28" align="MIDDLE" border="0" src="./online_files/img53.png" alt="$-\!\!&gt;$"> <tt>&lt;</tt>label<tt>&gt;</tt> <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4394"></a> is identical to the ifnomatch option 
of the id statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   ifnomatch-&gt; ....
</pre>
is just a shorthand notation for
<pre>   id ifnomatch-&gt; ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008660000000000000000"></a>
<a name="substaindex"></a>
<br>
index, indices
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">i[ndex] <tt>&lt;</tt>list of indices to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">i[ndices] <tt>&lt;</tt>list of indices to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">dimension (<a href="#substadimension">7.27</a>),
              fixindex (<a href="#substafixindex">7.51</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Declares one or more indices<a name="4413"></a><a name="4414"></a>. In the 
declaration of an index one can specify its dimension<a name="4415"></a>. 
This is done by appending one or two options to the name of the index to be 
declared:
<br>
<br>

</p><p>
<table width="159">
<tbody><tr><td>name=dim
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The dimension is either a nonnegative integer or a 
previously declared symbol. If the dimension is zero<a name="8354"></a> 
this means that no dimension is attached to the index. The consequence is 
that the index cannot be summed over and index contractions are not 
performed for this index. If no dimension is specified the default 
dimension will be assumed (see the dimension statement 
<a href="#substadimension">7.27</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>name=dim:ext
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The dimension is a symbol as above. Ext is an extra 
symbol which indicates the value of dim-4. This option is useful when 
traces over gamma matrices are considered (see <a href="#substatrace">7.141</a> and 
<a href="#substatracen">7.142</a>).</td></tr>
</tbody></table>
    <br> <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008670000000000000000"></a>
<a name="substainexpression"></a>
<br>
inexpression
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">inexpression,name(s) of expression(s);</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">endinexpression(<a href="#substaendinexpression">7.39</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The combination<a name="4435"></a>
</p><pre>   InExpression,expr;
       Statements;
   EndInExpression;
</pre>
is a more readable version of the construction
<pre>   if ( expression(expr) );
       Statements;
   endif;
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008680000000000000000"></a>
<a name="substainparallel"></a>
<br>
inparallel
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">inparallel;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">inparallel <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">NotInParallel (<a href="#substanotinparallel">7.90</a>), 
     ModuleOption (<a href="#substamoduleoption">7.81</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement is only active in the context of 
TFORM<a name="4451"></a>. It causes 
(small) expressions to be executed side by side. Normally the terms of 
expressions are distributed over the processors and the expressions are 
executed one by one. This isn't very efficient for small expressions 
because there is a certain amount of overhead. When there are many small 
expressions, this statement can cause each expression to be executed by its 
own processor. A consequence is that the expressions now can finish in a 
semi-random order and hence may end up in the output in a order that is 
different from when this statement isn't used. The proper order is restored 
in the first module that comes after and that doesn't use this option. One 
should be careful using this statement for big expressions, because in that 
case the sorting may need sort files and the output may temporarily need 
scratch files and the simultaneous use of many files can slow execution 
down significantly.

</p><p>
In the case that no expressions are mentioned, all active 
expressions will be affected. When there is a list of expressions, only 
those mentioned will be affected, provided they are active. Several of 
these statements will work cumulatively. This statement doesn't affect 
expressions that are still to be defined inside the current module. If it 
is needed to affect such expressions inside the current module, one should 
use the InParallel option of the 
ModuleOption&nbsp;<a href="#substamoduleoption" name="4453">7.81</a> 
statement. This statement works independently of the `On 
Parallel;'&nbsp;<a href="#substaon">7.99</a> and `Off Parallel;'&nbsp;<a href="#substaoff">7.98</a> statements.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008690000000000000000"></a>
<a name="substainside"></a>
<br>
inside
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">inside <tt>&lt;</tt>list of $-variables<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">endinside (<a href="#substaendinside">7.40</a>) and the chapter on $-variables 
(<a href="#dollars">6</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
works<a name="4467"></a> a bit like the argument<a name="4468"></a> 
statement (see <a href="#substaargument">7.8</a>) but with 
$-variables<a name="4470"></a> instead of with functions. An inside 
statement should be paired with an endinside<a name="4471"></a> statement 
(see <a href="#substaendinside">7.40</a>) inside the same module. The statements 
in-between will then be executed on the contents of the $-variables that 
are mentioned. One should pay some attention to the order of the action. 
The $-variables are treated sequentially. Hence, after the first one has 
been treated its contents are substituted by the new value. Then the second 
one is treated. If it uses the contents of the first variable, it will use 
the new value. If the first variable uses the contents of the second 
variable it will use its old value. Redefining any of the listed 
$-variables in the range of the `inside-environment' is very dangerous. It 
is not specified what FORM will do. Most likely it will be 
unpleasant<a name="4473"></a>. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008700000000000000000"></a>
<a name="substainsidefirst"></a>
<br>
insidefirst
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">insidefirst <tt>&lt;</tt>on/off<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>), off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4485"></a> is obsolete<a name="4486"></a>. 
The user should try to use the insidefirst option of the on (see 
<a href="#substaon">7.99</a>) or the off (see <a href="#substaoff">7.98</a>) statements. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008710000000000000000"></a>
<a name="substaintohide"></a>
<br>
intohide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">intohide;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">intohide <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">hide (<a href="#substahide">7.59</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In the first variety this statement marks all currently active 
expressions for being put in hidden<a name="4499"></a> storage at the end of the 
module, after it has been processed. In the second variety it marks only 
the specified active<a name="4500"></a> expressions as such. 
<br>
<br>

</p><p>
The difference with the hide (<a href="#substahide">7.59</a>) statement is 
that in the hide statement the expression is copied immediately into the 
hide system and it will not be processed in the current module, while in 
the intohide statement the expression is first processed and its final 
output in this module is sent to the hide system rather than to the regular 
scratch system. The effect is the same as not putting the intohide 
statement in the current module and putting a hide statement in the next, 
but it saves one copy operation and it is possibly a bit more economical 
with the disk space.
<br>
<br>

</p><p>
Note that a .store instruction will simultaneously remove all 
expressions from the hide system. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008720000000000000000"></a>
<a name="substakeep"></a>
<br>
keep
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">keep brackets;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">bracket (<a href="#substabracket">7.10</a>), antibracket 
     (<a href="#substaabrackets">7.1</a>) and the chapter on brackets 
     (<a href="#brackets">9</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The effect<a name="4514"></a><a name="4515"></a><a name="4516"></a> 
of this statement is that during execution of the current module the 
contents of the brackets are not considered. The statements only act on the 
`outside' of the brackets. Only when the terms are considered finished and 
are ready for the sorting are they multiplied by the contents of the 
brackets. At times this can save much computer time as complicated pattern 
matching and multiplications of function arguments with large fractions 
have to be done only once, rather than for each complete term separately 
(assuming that each bracket contains a large number of terms).

</p><p>
There can be some nasty side effects. Assume an expression like:
</p><pre>    F = f(i1,x)*(g(i1,y)+g(i1,z));
    B  f;
    .sort
    Keep Brackets;
    sum i1;
</pre>
the result will be
<pre>    F = f(N1_?,x)*g(i1,y)+f(N1_?,x)*g(i1,z);
</pre>
because at the moment of summing over i1 FORM is not looking inside the 
brackets and hence it never sees the second occurrence of i1. There are 
some beneficial applications of the keep statement in the 
`mincer'<a name="4521"></a> package that comes with the FORM distribution. In 
this package the most costly step was made faster by a significant factor 
(depending on the problem) due to the keep brackets statement. 
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008730000000000000000"></a>
<a name="substalabel"></a>
<br>
label
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">la[bel] <tt>&lt;</tt>name of label<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">goto (<a href="#substagoto">7.58</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Places a label<a name="4532"></a> at the current location. The name of 
the label can be any name or positive number. Control can be transfered to the 
position of the label by a goto<a name="4533"></a> statement (see 
<a href="#substagoto">7.58</a>) or the ifmatch<a name="4535"></a> option of an id statement 
(see <a href="#substaidentify">7.60</a>). The only condition is that the goto statement 
and the label must be inside the same module. Once the module is terminated 
all existing labels are forgotten. This means that in a later module a 
label with the same name can be used again (this may not improve 
readability though but it is a good thing when third party libraries are 
used). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008740000000000000000"></a>
<a name="substalfactorized"></a>
<br>
lfactorized
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Definition statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">l[ocal]factorized <tt>&lt;</tt>name<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a> and the 
factorize statement&nbsp;<a href="#substafactorize">7.48</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Used to define a local<a name="4550"></a> expression in factorized 
notation and keep it that way. The factors are recognized by multiplication 
and division signs at lowest bracket level. For the rest the expression is 
treated as a regular local expression. Example:
</p><pre>    Symbols x,y,z;
    LocalFactorized F1 = 3*(x+y)*(y+z)*((x+z)*(2*x+1));
    LocalFactorized F2 = 3*(x+y)*(y+z)+((x+z)*(2*x+1));
    Print;
    .end

   F1 =
         ( 3 )
       * ( y + x )
       * ( z + y )
       * ( z + x + 2*x*z + 2*x^2 );

   F2 =
         ( z + 3*y*z + 3*y^2 + x + 5*x*z + 3*x*y + 2*x^2 );
</pre>
As one can see in the second expression, the plus at ground level 
makes that there is only one factor. In the first expression the last 
factor is seen as a single factor and not two factor2 because of the extra 
parentheses. Only parentheses at ground level are used to recognize 
factors. If one needs those factors anyway, one should either leave away 
those parentheses or use an extra Factorize statement to have FORM 
refactorize the expression.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008750000000000000000"></a>
<a name="substaload"></a>
<br>
load
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">loa[d] <tt>&lt;</tt>filename<tt>&gt;</tt> [<tt>&lt;</tt>list of expressions<tt>&gt;</tt>];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">save (<a href="#substasave">7.118</a>), delete (<a href="#substadelete">7.25</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Loads<a name="4566"></a> a previously saved<a name="4567"></a> 
file<a name="4568"></a> (see <a href="#substasave">7.118</a>). If no expressions are 
specified all expressions in the file are put in the storage 
file<a name="4570"></a> and obtain the status of stored global 
expressions. If a list of expressions is specified all those expressions 
are loaded and possible other expressions are ignored. If a specified 
expression is not present, an error will result. If one does not know 
exactly what expressions are present in a file one could load the file 
without a list of expressions, because FORM will list all expressions that 
it encountered. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008760000000000000000"></a>
<a name="substalocal"></a>
<br>
local
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Definition statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">l[ocal] <tt>&lt;</tt>name<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">l[ocal] <tt>&lt;</tt>names of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">См. также</td>
<td align="LEFT">global (<a href="#substaglobal">7.57</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Используется для определения локального <a name="4585"></a> выражения. 
Локальное выражение - это выражение, которое будет выброшено<a name="4586"></a>, 
когда встретится инструкция .store<a name="4587"></a>. 
Если это не то, что вы хотите, используйте глобальные<a name="4588"></a> выражения (см. <a href="#substaglobal">7.57</a>). 
Эта конструкция также может использоваться для изменения статуса глобального выражения на локальный. 
В этом случае отсутствует знак = и отсутствует правая часть. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008770000000000000000"></a>
<a name="substamakeinteger"></a>
<br>
makeinteger
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">makeinteger [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT"><code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
[<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">normalize (<a href="#substanormalize">7.89</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Normalizes<a name="4604"></a> the indicated 
argument<a name="4605"></a> of the indicated functions(s) in such a way that 
all terms in this argument have integer 
coefficients<a name="4606"></a> with a their greatest common 
divider being one. This still leaves the possibility that the first term of 
this argument may be negative. If this is not desired one can first 
normalize<a name="4607"></a> the argument and then make its coefficients 
integer. The overall factor that is needed to make the coefficients like 
described is taken from the overall factor of the complete term. Example:
</p><pre>    S   a,b,c;
    CF  f;
    L   F = f(22/3*a+14/5*b+18/7*c);
    MakeInteger,f;
    Print +f;
    .end
   F =
      2/105*f(135*c + 147*b + 385*a);
</pre>

<p>
Note that this feature can be used to make outputs look much more 
friendly. It can be used in combination with the 
AntiBracket<a name="4610"></a> statement (<a href="#substaabrackets">7.1</a>) and the 
function dum_<a name="4612"></a> (<a href="#fundum">8.14</a>) to imitate a smart extra level 
of brackets and make outputs shorter.

</p><p>
It is possible to introduce a scale factor when extracting the coefficient 
and multiplying it into the complete term.

</p><p>
<table width="181">
<tbody><tr><td>MakeInteger,<img width="62" height="28" align="MIDDLE" border="0" src="./online_files/img56.png" alt="$\wedge&lt;n&gt;$">,f;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The number n must be an integer (may be negative) and if 
the coefficient that is extracted is c the whole term is multiplied by the 
factor <img width="20" height="14" align="BOTTOM" border="0" src="./online_files/img57.png" alt="$c^n$">.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008780000000000000000"></a>
<a name="substamany"></a>
<br>
many
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">many <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4630"></a> is identical to the many option of the 
id<a name="4631"></a> statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   many ....
</pre>
is just a shorthand notation for
<pre>   id many ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008790000000000000000"></a>
<a name="substamerge"></a>
<br>
merge
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">merge,functionname;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">merge,once,functionname;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">shuffle (<a href="#substashuffle">7.122</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement is exactly the same as the shuffle<a name="4645"></a> 
statement (see <a href="#substashuffle">7.122</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008800000000000000000"></a>
<a name="substametric"></a>
<br>
metric
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">metric <tt>&lt;</tt>option<tt>&gt;</tt>;</td>
</tr>
</tbody></table>

</p><p></p>

<p>
Remark: statement<a name="4655"></a> is inactive<a name="4656"></a>. 
Should have no effect.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008810000000000000000"></a>
<a name="substamoduleoption"></a>
<br>
moduleoption
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Module control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">moduleoption <tt>&lt;</tt>option<tt>&gt;</tt>[,<tt>&lt;</tt>value<tt>&gt;</tt>];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">polyfun (<a href="#substapolyfun">7.102</a>),
              processbucketsize (<a href="#substaprocessbucketsize">7.108</a>),
              dollar variables (<a href="#pardollars">6.1</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Used<a name="4671"></a> to set a mode for just the current 
module. It overrides the normal setting and will revert to this normal 
setting after this module. The settings are:

</p><p>
<table width="159">
<tbody><tr><td>parallel<a name="8393"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Allows parallel<a name="8400"></a> execution of the current module if all 
other conditions are right. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>noparallel<a name="8407"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Vetoes parallel<a name="8414"></a> execution of the current module.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>inparallel<a name="8421"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>This option is more or less equivalent to the 
InParallel&nbsp;<a href="#substainparallel">7.68</a> statement. The difference is that because 
this statement comes at the end of the module, its effects include also the 
expressions that have been defined inside the current module. This is not 
the case for the InParallel statement. The InParallel option can be 
followed by the names of expressions. If no such names are present, all 
active expressions are affected. Otherwise only the expressions that are 
mentioned are affected. Once this option is mentioned no more options can 
be used inside the same ModuleOption statement. This is to avoid potential 
confusion that could arise when expressions are used with a name identical 
to the name of one of the options.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>notinparallel<a name="8435"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>This option is more or less equivalent to the 
NotInParallel&nbsp;<a href="#substanotinparallel">7.90</a> statement. The difference is that 
because this statement comes at the end of the module, its effects include 
also the expressions that have been defined inside the current module. This 
is not the case for the NotInParallel statement. The NotInParallel option 
can be followed by the names of expressions. If no such names are present, 
all active expressions are affected. Otherwise only the expressions that 
are mentioned are affected. Once this option is mentioned no more options 
can be used inside the same ModuleOption statement. This is to avoid 
potential confusion that could arise when expressions are used with a name 
identical to the name of one of the options.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>polyfun<a name="8449"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Possibly followed by the name of a 
`polyfun'<a name="8456"></a>. Is similar to the polyfun statement (see 
<a href="#substapolyfun">7.102</a>) but only valid for the current module.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>polyratfun<a name="8464"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Possibly followed by the name of a 
`polyratfun'<a name="8471"></a>. Is similar to the polyfun statement (see 
<a href="#substapolyratfun">7.103</a>) but only valid for the current module. If there is 
second name, it refers to the inverse polyratfun. More complicated options 
of the polyratfun statement cannot be used here.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>processbucketsize<a name="8479"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Followed by a number. Similar to the 
processbucketsize<a name="8486"></a> 
statement (see <a href="#substaprocessbucketsize">7.108</a>) but only valid for the current 
module.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>local<a name="8494"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Should be followed by a list of $-variables. Indicates 
that the contents of the indicated $-variables<a name="8501"></a> are not 
relevant once the module has been finished and neither is the term by term 
order in which the $-variables obtain their value. In practise each 
processor<a name="8502"></a>/thread<a name="8503"></a> will work with its own copy 
of this variable.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>maximum<a name="8510"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Should be followed by a list of 
$-variables<a name="8517"></a>. Indicates that of the contents of the 
indicated $-variables the maximum is the only thing that is relevant once 
the module has been finished. The term by term order in which the 
$-variables obtain their value is not relevant.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>minimum<a name="8524"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Should be followed by a list of 
$-variables<a name="8531"></a>. Indicates that of the contents of the 
indicated $-variables the minimum is the only thing that is relevant once 
the module has been finished. The term by term order in which the 
$-variables obtain their value is not relevant.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>sum<a name="8538"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Should be followed by a list of 
$-variables<a name="8545"></a>. Indicates that the indicated $-variables 
are representing a sum. The term by term order in which the $-variables 
obtain their value is not relevant.</td></tr>
</tbody></table>
    <br>

</p><p>
The options `local', `maximum', `minimum' and `sum' are for 
parallel versions of FORM. The presence of $-variables can be a problem 
when the order of processing of the terms is not well defined. These 
options tell FORM what these $-variables are used for. In the above 
cases FORM can take the appropriate action when gathering information 
from the various processors. This will allow
parallel<a name="4721"></a> execution of the current module. If
$-variables are used in a module and they are defined on a term by term
basis, the normal action of FORM will be to veto parallel execution unless
it is clear that no confusion can occur. See also chapter <a href="#parallel">17</a> on
the parallel version and section <a href="#pardollars">6.1</a> on the dollar variables.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008820000000000000000"></a>
<a name="substamodulus"></a>
<br>
modulus
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">m[odulus] [option(s)] <tt>&lt;</tt>value<tt>&gt;</tt>;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Defines all calculus to be modulus<a name="4733"></a> the given 
integer value, provided this number is positive.

</p><p>
The modulus calculus extends itself to 
fractions<a name="4734"></a>. This means that if the value is not a prime 
number division by zero could result. It is the responsibility of the user 
to avoid such problems.

</p><p>
When the value in the modulus statement is either 0 or 1 the 
statement would be meaningless. It is used as a signal to FORM that modulus 
calculus should be switched off again.

</p><p>
The options are
</p><dl>
<dt><strong>NoFunctions</strong></dt>
<dd>Modulus calculus is not performed inside function 
arguments.
</dd>
<dt><strong>AlsoFunctions</strong></dt>
<dd>Modulus calculus is also performed inside function 
arguments.
</dd>
<dt><strong>CoefficientsOnly</strong></dt>
<dd>Modulus calculus is neither performed inside function 
arguments nor on powers of symbols.
</dd>
<dt><strong>PlusMin</strong></dt>
<dd>The values of numbers are reduced to the range 
<img width="110" height="31" align="MIDDLE" border="0" src="./online_files/img58.png" alt="$(-value+1)/2$"> to <img width="98" height="31" align="MIDDLE" border="0" src="./online_files/img59.png" alt="$(value-1)/2$">.
</dd>
<dt><strong>Positive</strong></dt>
<dd>The values of numbers are reduced to the range <img width="12" height="14" align="BOTTOM" border="0" src="./online_files/img60.png" alt="$0$"> to 
<img width="70" height="29" align="MIDDLE" border="0" src="./online_files/img61.png" alt="$value-1$">.
</dd>
<dt><strong>NoDollars</strong></dt>
<dd>The modulus calculus is not performed inside dollar 
variables.
</dd>
<dt><strong>AlsoDollars</strong></dt>
<dd>The modulus calculus is performed also inside dollar 
expressions.
</dd>
<dt><strong>InverseTable</strong></dt>
<dd>To speed up calculations all inverses are computed by 
means of a table. If the modulus value is very big, this table may be too 
big for the memory. That would result in an error message.
</dd>
<dt><strong>NoInverseTable</strong></dt>
<dd>No Table of Inverses is constructed. They are 
calculated whenever needed.
</dd>
<dt><strong>AlsoPowers</strong></dt>
<dd>Reduction is also used on powers of symbols with the 
relation <img width="72" height="14" align="BOTTOM" border="0" src="./online_files/img62.png" alt="$x^mod = x$"> if mod is the given value
</dd>
<dt><strong>NoPowers</strong></dt>
<dd>No reduction on powers is done.
</dd>
<dt><strong>PrintPowersOf</strong></dt>
<dd>The proper syntax is here printpowersof(generator) in 
which generator is supposed to be a generator for calculus modulus the 
given value, which means that all numbers will be written as a power of the 
generator. If the number turns out not to be a proper generator an error 
will be given. Note that finding the powers is done by means of the 
construction of a table. Hence, if the modulus value is very big the table 
might not fit inside memory. This will result in an error message.
</dd>
</dl>
The default mode is NoFunctions, Positive, NoInverseTable, NoDollars, 
NoPowers.

<p>
The current syntax (version 4.0 and later) differs slightly from the 
previous syntax. As however there were many bugs in the old implementation 
we suspect that a slight change of the options does not inconvenience any 
many users.

</p><p>

</p><h1><a name="SECTION008830000000000000000"></a>
<a name="substamulti"></a>
<br>
multi
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">multi <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement is identical to the multi<a name="4748"></a> option of 
the id<a name="4749"></a> statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   multi ....
</pre>
is just a shorthand notation for
<pre>   id multi ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008840000000000000000"></a>
<a name="substamultiply"></a>
<br>
multiply
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">mu[ltiply] [<tt>&lt;</tt>option<tt>&gt;</tt>] <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Statement multiplies<a name="4766"></a> all terms by the given 
expression. It is advisable to use the options when noncommuting variables 
are involved. They are:
<br>

</p><p>
<table width="181">
<tbody><tr><td>left<a name="8557"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Multiplication is from the left.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>right<a name="8570"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Multiplication is from the right.</td></tr>
</tbody></table>
    <br>

</p><p>
There is no guarantee<a name="4772"></a> as to what the default is 
with respect to multiplication from the left or from the right. It is up to 
FORM to decide what it considers to be most efficient when neither 
option is present. <br>
<br>

</p><p>
Note that one should not abbreviate this command to `multi', 
because there is a separate multi<a name="4775"></a> command (see 
<a href="#substamulti">7.83</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008850000000000000000"></a>
<a name="substandrop"></a>
<br>
ndrop
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ndrop;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">ndrop <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">drop (<a href="#substadrop">7.31</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In the first variety<a name="4787"></a> this statement cancels all 
drop<a name="4788"></a> plans. This means that all expressions scheduled for being 
dropped will be restored to their previous status of local or global 
expressions. In the second variety this happens only to the expressions 
that are specified. Example:
</p><pre>   Drop;
   Ndrop F1,F2;
</pre>
This drops all expressions, except for the expressions <code>F1</code> and 
<code>F2</code>. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008860000000000000000"></a>
<a name="substanfactorize"></a>
<br>
nfactorize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nfactorize <code>{</code><tt>&lt;</tt>name of expression(s)<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a> and 
<a href="#substafactorize">7.48</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
When one uses a factorize (see <a href="#substafactorize">7.48</a>) statement 
without arguments all expressions will be marked for factorization. If one 
would like to exclude a few expressions this can be done with the 
NFactorize statement. There should be at least one expression mentioned as 
in:
</p><pre>   Factorize;
   NFactorize expr12,expr29;
</pre>
One can also use the Factorize statement with a number of expressions after 
which the NFactorize statement can remove some from the list again as in:
<pre>   Factorize expr1,...,expr100;
   NFactorize expr12,expr29;
</pre>

<p>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008870000000000000000"></a>
<a name="substanfunctions"></a>
<br>
nfunctions
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">n[functions] <tt>&lt;</tt>list of functions to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), cfunctions (<a href="#substacfunctions">7.11</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4818"></a> declares 
noncommuting<a name="4819"></a> functions. It is equal to the 
function<a name="4820"></a> statement (see <a href="#substafunctions">7.54</a>) which has 
the noncommuting property as its default. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008880000000000000000"></a>
<a name="substanhide"></a>
<br>
nhide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nhide;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">nhide <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">hide (<a href="#substahide">7.59</a>),
              unhide (<a href="#substaunhide">7.146</a>),
              nunhide (<a href="#substanunhide">7.96</a>),
              pushhide (<a href="#substapushhide">7.110</a>),
              pophide (<a href="#substapophide">7.104</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In its first variety<a name="4836"></a> this statement undoes all 
hide<a name="4837"></a> plans that exist thus far in the current module. In the 
second variety it does this only for the specified active<a name="4838"></a> 
expressions. See the hide statement in <a href="#substahide">7.59</a>. Example:
</p><pre>   Hide;
   Nhide F1,F2;
</pre>
Here all active expressions will be transferred to the hide file except for 
the expressions <code>F1</code> and <code>F2</code>. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008890000000000000000"></a>
<a name="substanormalize"></a>
<br>
normalize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">normalize options <code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">argument (<a href="#substaargument">7.8</a>), splitarg 
            (<a href="#substasplitarg">7.125</a>), makeinteger (<a href="#substamakeinteger">7.77</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Normalizes<a name="4856"></a> the indicated 
arguments<a name="4857"></a> of the indicated functions. Normalization means 
that the argument will be multiplied by the inverse of its 
coefficient<a name="4858"></a> 
(provided it is not zero). This holds for single term arguments. For 
multiple term arguments the inverse of the coefficient of the first term of 
the argument is used. The options and the argument specifications are as in 
the SplitArg<a name="4859"></a> statement (see <a href="#substasplitarg">7.125</a>). Under normal 
circumstances the coefficient that is removed from the argument(s) is 
multiplied into the coefficient of the term. This can be avoid with the 
extra option
<code>(0)</code>. Hence

</p><p>
<table width="181">
<tbody><tr><td>Normalize,f;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>changes <tt>f(2*x+3*y)</tt> into <tt>2*f(x+3/2*y)</tt> but</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Normalize,(0),f;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>changes <tt>f(2*x+3*y)</tt> into <tt>f(x+3/2*y)</tt>.</td></tr>
</tbody></table>
    <br>

</p><p>
A more flexible way to extract the coefficient of the (first) term is by 
providing a scale factor as in

</p><p>
<table width="181">
<tbody><tr><td>Normalize,<img width="62" height="28" align="MIDDLE" border="0" src="./online_files/img56.png" alt="$\wedge&lt;n&gt;$">,f;
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The number n must be an integer (may be negative) and if 
the coefficient of the first term was c the whole term is multiplied by the 
factor <img width="20" height="14" align="BOTTOM" border="0" src="./online_files/img57.png" alt="$c^n$">.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008900000000000000000"></a>
<a name="substanotinparallel"></a>
<br>
notinparallel
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">notinparallel;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">notinparallel <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">InParallel (<a href="#substainparallel">7.68</a>), 
     ModuleOption (<a href="#substamoduleoption">7.81</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement is only active in the context of 
TFORM<a name="4886"></a>. It vetoes (small) expressions to be executed side by 
side. For a complete explanation of this type of running one should look at 
the InParallel&nbsp;<a href="#substainparallel">7.68</a> statement. Because the default is 
that expressions are executed one by one, the major use of this statement 
is in constructions like:
</p><pre>   InParallel;
   NotInParallel F1,F25;
</pre>
which would first mark all expressions to be executed in simultaneous mode 
and then make an exception for <tt>F1</tt> and <tt>F25</tt>.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION008910000000000000000"></a>
<a name="substanprint"></a>
<br>
nprint
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">np[rint] <tt>&lt;</tt>list of names of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">print (<a href="#substaprint">7.105</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Statement<a name="4902"></a> is used to take expressions from the list 
of expressions to be printed. When a print<a name="4903"></a> statement is used 
(see <a href="#substaprint">7.105</a>) without specification of expressions, all active 
expressions are marked for printing. With this statement one can remove a 
number of them from the list. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008920000000000000000"></a>
<a name="substanskip"></a>
<br>
nskip
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nskip;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">nskip <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">skip (<a href="#substaskip">7.123</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In the first variety<a name="4915"></a> it causes the cancellation of 
all skip<a name="4916"></a> plans (see <a href="#substaskip">7.123</a>) for expressions. The 
status of these expressions is restored to their previous status (active 
local or global expressions). In the second variety this is done for the 
specified expressions only. Example:
</p><pre>   Skip;
   Nskip F1,F2;
</pre>
This causes all active expressions to be skipped except for the expressions 
<code>F1</code> and <code>F2</code>. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008930000000000000000"></a>
<a name="substantable"></a>
<br>
ntable
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ntable <tt>&lt;</tt>options<tt>&gt;</tt> <tt>&lt;</tt>table to be 
declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), table (<a href="#substatable">7.132</a>),
        ctable (<a href="#substactable">7.21</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4934"></a> declares a 
noncommuting<a name="4935"></a> table<a name="4936"></a>. For the 
rest it is identical to the table<a name="4937"></a> command (see 
<a href="#substatable">7.132</a>) which has the commuting property as its default. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008940000000000000000"></a>
<a name="substantensors"></a>
<br>
ntensors
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nt[ensors] <tt>&lt;</tt>list of tensors to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), tensors 
            (<a href="#substatensors">7.134</a>), ctensors (<a href="#substactensors">7.22</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="4951"></a> declares 
noncommuting<a name="4952"></a> tensors<a name="4953"></a>. For 
the rest it is equal to the tensor<a name="4954"></a> statement (see 
<a href="#substatensors">7.134</a>) which has the commuting property as its default.

</p><p>
The options that exist for properties of tensors are the same as 
those for functions (see <a href="#substafunctions">7.54</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008950000000000000000"></a>
<a name="substanunfactorize"></a>
<br>
nunfactorize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nunfactorize <code>{</code><tt>&lt;</tt>name of expression(s)<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a> and 
<a href="#substaunfactorize">7.145</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
When one uses an UnFactorize (see <a href="#substaunfactorize">7.145</a>) 
statement without arguments all expressions will be marked for being 
unfactorized. If one would like to exclude a few expressions this can be 
done with the NUnFactorize statement. There should be at least one expression 
mentioned as in:
</p><pre>   UnFactorize;
   NUnFactorize expr12,expr29;
</pre>
One can also use the UnFactorize statement with a number of expressions after 
which the NUnFactorize statement can remove some from the list again as in:
<pre>   UnFactorize expr1,...,expr100;
   NUnFactorize expr12,expr29;
</pre>

<p>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008960000000000000000"></a>
<a name="substanunhide"></a>
<br>
nunhide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nunhide;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">nunhide <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">hide (<a href="#substahide">7.59</a>),
              nhide (<a href="#substanhide">7.88</a>),
              unhide (<a href="#substaunhide">7.146</a>),
              pushhide (<a href="#substapushhide">7.110</a>),
              pophide (<a href="#substapophide">7.104</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In its first variety<a name="4987"></a> this statement undoes all 
unhide<a name="4988"></a> (see <a href="#substaunhide">7.146</a> and <a href="#substahide">7.59</a>) plans 
that the system has in the current module. In its second variety this 
happens only with the specified expressions. Example:
</p><pre>   Unhide;
   Nunhide F1,F2;
</pre>
All expressions are taken from the hide<a name="4993"></a> system, except for the 
expressions <code>F1</code> and <code>F2</code>. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION008970000000000000000"></a>
<a name="substanwrite"></a>
<br>
nwrite
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">nw[rite] <tt>&lt;</tt>keyword<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>), off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5005"></a> is considered 
obsolete<a name="5006"></a>. All its varieties have been taken over by the 
off<a name="5007"></a> statement (see <a href="#substaoff">7.98</a>) and the on<a name="5009"></a> 
statement (see <a href="#substaon">7.99</a>). The current version of FORM will still 
recognize it, but the user is advised to avoid its usage. In future 
versions of FORM it is scheduled to be used for a different kind of 
writing and hence its syntax may change considerably. The conversion 
program conv2to3<a name="5013"></a> should help in the conversion of programs 
that have been written for version 2. For completeness we still give the 
syntax and how it should be converted.
The keywords are: <br>
<br>

</p><p>
<table width="159">
<tbody><tr><td>stats<a name="8627"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off stats;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>statistics<a name="8640"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off statistics;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstats<a name="8653"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off shortstats;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstatistics<a name="8666"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off shortstatistics;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>warnings<a name="8679"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off warnings;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>allwarnings<a name="8692"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off allwarnings;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>setup<a name="8705"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off setup;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>names<a name="8718"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off names;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>allnames<a name="8731"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off allnames;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstats<a name="8744"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off shortstats;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>highfirst<a name="8757"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off highfirst;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>lowfirst<a name="8770"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off lowfirst;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>powerfirst<a name="8783"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: Off powerfirst;</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008980000000000000000"></a>
<a name="substaoff"></a>
<br>
off
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">off <tt>&lt;</tt>keyword<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">off <tt>&lt;</tt>keyword<tt>&gt;</tt> <tt>&lt;</tt>option<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Statement<a name="5081"></a> to control settings<a name="5082"></a> during 
execution. Many of these settings replace older statements. The settings 
and their keywords are:

</p><p>
<table width="159">
<tbody><tr><td>allnames<a name="8796"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the allnames mode off. The default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>allwarnings<a name="8809"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns off the printing of all warnings.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>checkpoint<a name="8822"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Deactivates the checkpoint mechanism. See
<a href="#checkpoints">4.1</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>compress<a name="8836"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns compression mode off.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>finalstats<a name="8849"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns off the last line of statistics that is normally 
printed at the end of the run (introduced in version 3.2).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>highfirst<a name="8862"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Puts the sorting in a low first mode.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>insidefirst<a name="8875"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Not active at the moment.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>lowfirst<a name="8888"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Leaves the default low first mode and puts the sorting in 
a high first mode.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>names<a name="8901"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the names mode off. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>nospacesinnumbers<a name="8914"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td><a name="staoffnospacesinnumbers"></a>
<br>
<br>
Allows very
long numbers to be printed with leading blank spaces at the beginning of a new
line. The numbers are usually broken up by placing a backslash character at
the end of the line and then continuing at the next line. For cosmetic
purposes FORM puts usually a few blank spaces at the beginning of the line.
FORM itself can read this but some programs cannot. This option can be turned
off by the `on nospacesinnumbers;' statement. The printing of the blank
characters can be restored by turning this variable off. See also page 
<a href="#nospacesinnumbers">16</a> for a corresponding variable in the setup file.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>oldfactarg<a name="8932"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td><a name="staoffoldfactarg"></a>Switches the use of the FactArg 
statement<a href="#substafactarg" name="8941">7.46</a> to the new mode of version 4 or 
later in which expressions in the argument of the mentioned function are 
completely factored over the rationals. The default is off.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>parallel<a name="8948"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Disallows the running of the program in parallel mode 
(only relevant for parallel versions of FORM).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>powerfirst<a name="8962"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Puts the sorting back into `highfirst' mode.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>processstats<a name="8975"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the process by process printing of the statistics 
in P<small>AR</small>FORM off. Only the master process will be printing statistics. 
Other versions of FORM will ignore this option.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>propercount<a name="8992"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the propercounting mode off. This means that for the 
generated terms in the statistics not only the `ground level' terms are 
counted but also terms that were generated inside function arguments.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>properorder<a name="9005"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the properorder mode off. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>setup<a name="9018"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Switches off the mode in which the setup parameters are 
printed. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>stats<a name="9031"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as `Off statistics'.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>statistics<a name="9044"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns off the printing of statistics.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstats<a name="9057"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as `Off shortstatistics'.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstatistics<a name="9070"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Takes the writing of the statistics back from shorthand 
mode to the regular statistics mode in which each statistics messages takes 
three lines of text and one blank line.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>threadloadbalancing<a name="9083"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>
<br>
<br>
<br>
Disables the loadbalancing mechanism of 
TFORM in parallel mode. In other versions of FORM this option is 
ignored.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>threads<a name="9099"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Disallows multithreaded running in TFORM.
In other versions of FORM this option is ignored.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>threadstats<a name="9114"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns off the thread by thread printing of the statistics 
in TFORM. Only the master thread will be printing statistics. Other 
versions of FORM will ignore this option.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>totalsize<a name="9129"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Switches the totalsize mode off. For a more detailed 
description of the totalsize mode, see the "On TotalSize;" 
command<a href="#ontotalsize">7.99</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>warnings<a name="9143"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns off the printing of warnings.</td></tr>
</tbody></table>
    <br>

</p><p>
If a description is too short, one should also consult the 
description in the on statement (see <a href="#substaon">7.99</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION008990000000000000000"></a>
<a name="substaon"></a>
<br>
on
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Тип</td>
<td align="LEFT">Конструкция объявления</td>
</tr>
<tr><td align="LEFT">Синтаксис</td>
<td align="LEFT">on <tt>&lt;</tt>keyword<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">on <tt>&lt;</tt>keyword<tt>&gt;</tt> <tt>&lt;</tt>option<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">См. также</td>
<td align="LEFT">off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Новая конструкция для управления настройками в процессе выполнения. 
Большинство этих настроек заменяют старые конструкции. 
Вот настройки и их keywords:

</p><p>
<table width="159">
<tbody><tr><td>allnames<a name="9156"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Тоже что `On names', 
но также дополнительно печатаются все системные переменные. По умолчанию выключена. </td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>allwarnings<a name="9169"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Переводит печать предупреждений в режим, 
в котором печатаются все предупреждения, даже совсем незначительные.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>checkpoint<a name="9182"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Активирует механизм контрольных точек, 
которые позволяюбт восстановиться после падения сессии FORM-а. 
См. <a href="#checkpoints">4.1</a> для детальной информации.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>compress<a name="9197"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Включает режим сжатия. 
Это сжатие - относительно простое сжатие, 
по сравнению с тем, которое могло бы потребовать много компьютерного времени, 
но сжимает примерно в 2 раза данные на диске. 
Старая конструкция была `compress on' 
но ее следует избегать в будущем. 
Этот параметр используется по умолчанию.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>compress,gzip<a name="9210"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>
За этой опцией должна следовать запятая или пробел и одна цифра. 
она активирует gzip сжатие для sort-файла. 
Это сжатие может делать промежуточный sort-файл значительно короче, потребовав некоторое время процессора. 
Эта опция может использоваться, когда очень ценится дисковое пространство. 
Цифра показывает степень сжатия. 
Ноль означает без сжатия и 9 - это наивысший уровень. По умолчанию уровень 6. 
Выше этого уровня сжатие становится очень медленным и не приносит много пользы.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>fewerstatistics<a name="9223"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Определяет, как много статистики будет печатать FORM когда маленький буфер заполнится. 
За ключевым словом может следовать положительное целое. 
В этом случае one out of that many of these statistics will be printed. 
Если число не указано, по умолчанию используется значение 10. 
Когда число равно нулю, эта фича выключается (такой же эффект при значении один).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>fewerstats<a name="9237"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>То же что и fewerstatistics.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>finalstats<a name="9250"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Определяет, будет ли FORM печатать последнюю строку со статистикой времени выполнения 
в конце работы. По умолчанию включено.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>highfirst<a name="9264"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>В этом режиме полиномы сортируются в порядке убывания степеней.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>insidefirst<a name="9277"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>В данный момент не работает.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>lowfirst<a name="9290"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>В этом режиме полиномы сортируются 
в порядке возрастания степеней. Это по умолчанию.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>names<a name="9303"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns on the mode in which at the end of each module the 
names of all variables that have been defined by the user are printed. This 
is an inspection mode for debugging by the user. Default is off.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>nospacesinnumbers<a name="9316"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td><a name="staonnospacesinnumbers"></a>
<br>
<br>
Makes that very
long numbers are printed with no leading blank spaces at the beginning of a
new line. The numbers are usually broken up by placing a backspace character
at the end of the line and then continuing at the next line. For cosmetic
purposes FORM puts usually a few blank spaces at the beginning of the line.
FORM itself can read this but some programs cannot. Hence this printing of the
blank characters can be omitted by turning this variable on. See also page
<a href="#nospacesinnumbers">16</a> for a corresponding variable in the setup file.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>oldfactarg<a name="9334"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td><a name="staonoldfactarg"></a>Switches the use of the FactArg 
statement<a href="#substafactarg" name="9343">7.46</a> to the old mode from before 
version 4. This is a compatibility mode to allow oldprograms that rely on a 
specific working of the FactArg statement to still run. The default is 
off.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>parallel<a name="9350"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Allows the running of the program in parallel mode unless 
other problems prevent this. This is of course only relevant for parallel 
versions of FORM. The default is on.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>powerfirst<a name="9364"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>In this mode polynomials are sorted in a way that high 
powers come before low powers. The most relevant is however the combined 
power of all symbols.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>processstats<a name="9377"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Only active for P<small>AR</small>FORM. It determines whether all
processes print their run time statistics or only the master process does so.
Default is on.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>propercount<a name="9392"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Sets the counting of the terms during generation into 
`propercount' mode. This means that only terms at the `ground level' are 
counted and terms inside functions arguments are not counted in the 
statistics. This setting is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>properorder<a name="9405"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the properorder mode on. The default is off. In the 
properorder mode FORM pays particular attention to function arguments when 
bringing terms and expressions to normal form. This may cost a considerable 
amount of extra time. In normal mode FORM is a bit sloppy (and much 
faster) about this, resulting sometimes in an ordering that appears without 
logic. This concerns only function arguments! This mode is mainly intended 
for the few moments in which the proper ordering is important.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>setup<a name="9420"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Causes the printing of the current setup parameters for 
inspection. Default is off.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstatistics<a name="9433"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Puts the writing of the statistics in a shorthand mode in 
which the complete statistics are written on a single line only.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstats<a name="9446"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as `On shortstatistics'.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>statistics<a name="9459"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns the writing of runtime statistics on. This is the 
default. It is possible to change this default with one of the setup 
parameters in the setup file (see <a href="#setup">16</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>stats<a name="9473"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as `On statistics'.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>threadloadbalancing<a name="9486"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>
<br>
<br>
<br>
Causes the load balancing mechanism in TFORM
to be turned on or off. Default is on. Ignored by other versions of FORM.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>threads<a name="9502"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Allows the running of the program in multithreaded mode 
unless other problems prevent this. This is of course only relevant for 
TFORM. Other versions of FORM ignore this. The default is on.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>threadstats<a name="9517"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Only active for TFORM. It determines whether all threads 
print their run time statistics or only the master thread does so. Default 
is on.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>totalsize<a name="9531"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td><a name="ontotalsize"></a> Puts FORM in a 
mode<a name="9539"></a> in which it tries to determine 
the maximum space occupied by all expressions at any given moment during 
the execution of the program. This space is the sum of the 
input/output/hide scratch files, the sort file(s) and the .str file. This 
maximum is printed at the end of the program. The same can be obtained with 
the "TotalSize ON" command in the setup (see <a href="#setup">16</a>) or the -T option 
in the command tail when FORM is started (see <a href="#running">1</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>warnings<a name="9550"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Turns on the printing of warnings in regular mode. This 
is the default.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081000000000000000000"></a>
<a name="substaonce"></a>
<br>
once
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">once <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5342"></a> is identical to the once option of the 
id<a name="5343"></a> statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   once ....
</pre>
is just a shorthand notation for
<pre>   id once ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081010000000000000000"></a>
<a name="substaonly"></a>
<br>
only
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">only <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5361"></a> is identical to the only option of the 
id<a name="5362"></a> statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   only ....
</pre>
is just a shorthand notation for
<pre>   id only ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081020000000000000000"></a>
<a name="substapolyfun"></a>
<br>
polyfun
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">polyfun <tt>&lt;</tt>name of function<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">polyfun;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">moduleoption (<a href="#substamoduleoption">7.81</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Declares the specified<a name="5378"></a> function to be the 
`polyfun'. The polyfun is a function of which the single 
argument<a name="5379"></a> is considered to be the 
coefficient<a name="5380"></a> of the term. If two terms are otherwise 
identical the arguments of their polyfun will be added during the sorting, 
even if these arguments are little expressions. Hence
</p><pre>    PolyFun acc;
    Local F = 3*x^2*acc(1+y+y^2)+2*x^2*acc(1-y+y^2);
</pre>
will result in
<pre>    F = x^2*acc(5+y+5*y^2);
</pre>
Note that the external numerical coefficient<a name="5385"></a> is also 
pulled inside the polyfun.

<p>
If the polyfun statement has no argument, FORM reverts to its 
default mode in which no polyfun exists. This does not change any terms. If 
one would like to remove the polyfun from the terms one has to do that 
`manually' as in
</p><pre>    PolyFun;
    id  acc(x?) = x;
</pre>
in which we assume that previously the function acc had been declared to be 
the `polyfun'. <br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081030000000000000000"></a>
<a name="substapolyratfun"></a>
<br>
polyratfun
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">polyratfun <tt>&lt;</tt>name of function<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">polyratfun <tt>&lt;</tt>name of function<tt>&gt;</tt>,<tt>&lt;</tt>name of function<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">polyratfun;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">polyfun (<a href="#substapolyfun">7.102</a>),
			  moduleoption (<a href="#substamoduleoption">7.81</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Declares the specified<a name="5403"></a> function to be the 
`polyratfun'. The polyratfun is a function with two 
arguments<a name="5404"></a> which together form a rational polynomial that 
acts as the 
coefficient<a name="5405"></a> of the term. If two terms are otherwise 
identical the arguments of their polyratfun will be added during the sorting, 
even if these arguments are little nontrivial. Hence
</p><pre>    PolyRatFun acc;
    Local F = 3*x^2*acc(1+y+y^2,1-y)+2*x^2*acc(1-y+y^2,1+y);
</pre>
will result in
<pre>    F = x^2*acc(-y^3-10*y^2-2*y-5,y^2-1);
</pre>
Note that the external numerical coefficient<a name="5410"></a> is also 
pulled inside the polyratfun.

<p>
If the polyratfun statement has no argument, FORM reverts to its 
default mode in which no polyratfun exists. This does not change any terms.

</p><p>
The polyratfun has many similarities with the polyfun (see 
<a href="#substapolyfun">7.102</a>). At any moment there can only be at most either one 
polyfun or one polyratfun. Occurrences of the polyfun or the polyratfun 
with the wrong number or the wrong type of arguments are treated as regular 
functions.

</p><p>
There is a fundamental difference between the polyfun and the 
polyratfun. The last one is far more restrictive. It can have only numbers 
and symbols for its arguments. Also the ordering of the terms in the 
arguments can be different. In the polyratfun the terms are always sorted 
with the highest power first. In the polyfun the ordering is as with the 
regular terms. By default the lowest powers come first as one usually likes 
for power series expansions.

</p><p>
When two functions are specified, the first will be the 
PolyRatFun, and the second will be its inverse as in
</p><pre>    PolyRatFun rat,RAT;
</pre>
in which case
<pre>        RAT(x1,x2) = rat(x2,x1)
</pre>
This can be handy when one needs to solve systems of equations by manual 
interference. In that case exchanging numerators and denominators can be 
rather messy, while just changing a name is far less error-prone.

<p>
In many cases it may be very wasteful to keep full track of the 
complete rational polynomial. An example is the reduction of a complicated 
4-loop massless propagator diagram for which the rational polynomials can 
easily have hundreds of powers of the dimension parameter <img width="81" height="29" align="MIDDLE" border="0" src="./online_files/img63.png" alt="$D=4-2\epsilon$">. 
In the end one has to expand in terms of <img width="11" height="14" align="BOTTOM" border="0" src="./online_files/img64.png" alt="$\epsilon$"> although it is not 
known in advance to how many powers. For this there are two extra options 
in the polyratfun statement. The first is
</p><pre>    PolyRatFun rat(divergence,x);
</pre>
in which x is the name of the symbol of interest. In this case the 
polyratfun keeps only its most divergent term in this variable x and gives 
it the coefficient one. The result is that terms will never cancel and at 
the end of the calcuation one can see how many poles in x were maximally 
present, and hence how far one has to expand in x. Because the contents of 
the polyratfun are extremely simple, the expensive rational arithmetic is 
completely absent and things should go rather fast.

<p>
In the second option one can specify how far one should expand:
</p><pre>    PolyRatFun rat(expand,x,power);
</pre>
In this case the denomnator can only be a polynomial in the variable x. It 
will be expanded and multiplied by the numerator and eventually all terms 
with powers of x that are greater than 'power' will be discarded. The 
remaining incidence of the function rat will then have only one argument, 
like the polyfun (see <a href="#substapolyfun">7.102</a>). The advantage is that now the 
addition of two coefficients is a simple and straightforward operation that 
does not need the expensive polynomial GCD computations.

<p>
Of course one can program such expansions externally and maybe 
better suited for the problem at hand, but using this option of the 
polyratfun is much faster and gives fewer chances of mistakes.

</p><p>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081040000000000000000"></a>
<a name="substapophide"></a>
<br>
pophide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">pophide;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">hide (<a href="#substahide">7.59</a>),
              nhide (<a href="#substanhide">7.88</a>),
              unhide (<a href="#substaunhide">7.146</a>),
              nunhide (<a href="#substanunhide">7.96</a>),
              pushhide (<a href="#substapushhide">7.110</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Undoes<a name="5433"></a> the action of the most recent 
pushhide<a name="5434"></a> statement (see <a href="#substapushhide">7.110</a>). If there is 
no matching pushhide statement an error will result. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081050000000000000000"></a>
<a name="substaprint"></a>
<br>
print
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Print statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">Print [<tt>&lt;</tt>options<tt>&gt;</tt>];</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">Print <code>{</code>[<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>expression<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">Print [<tt>&lt;</tt>options<tt>&gt;</tt>] "<tt>&lt;</tt>format string<tt>&gt;</tt>" [<tt>&lt;</tt>objects<tt>&gt;</tt>];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">print[] (<a href="#substaprintc">7.106</a>),
              nprint (<a href="#substanprint">7.91</a>),
              printtable (<a href="#substaprinttable">7.107</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
General purpose print<a name="5458"></a> statement. It has three modes. In 
the first two modes flags are set for the printing of expressions after the 
current module has been finished. The third mode concerns printing during 
execution. This allows the printing of individual terms or 
$-variables<a name="5459"></a> on a term by term basis. It should be 
considered as a useful debugging<a name="5460"></a> device.

</p><p>
In the first mode all active<a name="5461"></a> expressions are 
scheduled for printing. The options are

</p><p>
<table width="45">
<tbody><tr><td>+f
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Printing will be only to the log<a name="9571"></a> 
file<a name="9572"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>-f
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Printing will be both to the screen<a name="9585"></a> and to 
the log<a name="9586"></a> file<a name="9587"></a>. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>+s
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Each term will start a new line. This is called the 
single<a name="9600"></a> term mode<a name="9601"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>+ss
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Each term will start a new line. In addition each 
internal group will start a new line. A group is either a single function 
or all symbols together, or all dotproducts together, or all vectors 
together, or all Kronecker delta's together.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>+sss
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Like the +ss option but now each symbol and its power 
will start a new line. The same for individual dotproducts (and their 
power), vectors and Kronecker delta's.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>-s
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Regular term mode. There can be more terms in a line. 
Linebreaks<a name="9638"></a> are placed when the line is full. The line 
size is set in the format<a name="9639"></a> statement (see <a href="#substaformat">7.52</a>). 
This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>-ss
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Lowers the single term mode to -s. If one would like to 
switch off the single term mode altogether, -s suffices.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>-sss
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>Lowers the single term mode to -ss. If one would like to 
switch off the single term mode altogether, -s suffices.</td></tr>
</tbody></table>
    <br>

</p><p>
In the second mode one can specify
individual<a name="5500"></a> expressions to be printed. The 
options hold for all the expressions that follow them until new options are 
specified. The options are the same as for the first mode.

</p><p>
In the third mode there is a format<a name="5501"></a> string 
as for the printf<a name="5502"></a> command in the C<a name="5503"></a> programming 
language. Of course the control characters are not exactly the same as for 
the C language because the objects are different. The special characters 
are:

</p><p>
<table width="45">
<tbody><tr><td>%t<a name="9671"></a>
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>The current term will be printed at this position 
including its sign, even if this is a plus sign.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>%T<a name="9684"></a>
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>The current term will be printed at this position. If its 
coeficient is positive no leading plus sign is printed.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>%w<a name="9697"></a>
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>The number of the current thread will be printed. This is 
for TFORM only. In the sequential version this combination is skipped. The 
number zero refers to the master thread.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>%W<a name="9711"></a>
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>The number of the current thread and its CPU-time at the 
moment of printing. This is for TFORM only. In the sequential version 
this combination is skipped. The number zero refers to the master thread.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>%$<a name="9725"></a>
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>A dollar expression will be printed at this position. The 
name(s) of the dollar expression(s) should follow the format string in the 
order in which they are used in the format string.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>%%<a name="9738"></a>
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>The character %.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>%
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>If this is the last character of the string no linefeed 
will be printed at the end of the print command.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td><img width="12" height="31" align="MIDDLE" border="0" src="./online_files/img40.png" alt="$\backslash$">n
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>A linefeed<a name="9769"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
Each call is terminated with a linefeed<a name="5536"></a>. Example:
</p><pre>    Symbols a,b,c;
    Local F = 3*a+2*b;
    Print "&gt; %T";
    id  a = b+c;
    Print "&gt;&gt; %t";
    Print;
    .end
&gt; 3*a
&gt;&gt;  + 3*b
&gt;&gt;  + 3*c
&gt; 2*b
&gt;&gt;  + 2*b

   F =
      5*b + 3*c;
</pre>

<p>
In the third mode one can also use the +/-f options of the 
first mode. This should be placed before the format string as in
</p><pre>    Print +f "(%$) %t",$var;
</pre>

<p>
Because of the mixed nature of this statement it can occur in 
more than one location in the module. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081060000000000000000"></a>
<a name="substaprintc"></a>
<br>
print[]
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">print[] <code>{</code>[<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>name<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">print (<a href="#substaprint">7.105</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Print<a name="5554"></a> statement<a name="5555"></a> to cause the printing 
of expressions at the end of the current module. Is like the first two 
modes of the regular print statement (see <a href="#substaprint">7.105</a>), but when 
printing FORM does not print the contents of each bracket<a name="5557"></a>, 
only the number of terms inside the bracket. Is to be used in combination 
with a bracket or an antibracket<a name="5558"></a> statement (see 
<a href="#substabracket">7.10</a> and <a href="#substaabrackets">7.1</a>). Apart from this the options 
are identical to those of the first two modes of the print statement. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081070000000000000000"></a>
<a name="substaprinttable"></a>
<br>
printtable
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Print statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">printtable [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>tablename<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">printtable [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>tablename<tt>&gt;</tt> <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"> <tt>&lt;</tt>filename<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">printtable [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>tablename<tt>&gt;</tt> <img width="24" height="28" align="MIDDLE" border="0" src="./online_files/img65.png" alt="$&gt;\!\!&gt;$"> <tt>&lt;</tt>filename<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">print (<a href="#substaprint">7.105</a>),
            table (<a href="#substatable">7.132</a>),
            fill (<a href="#substafill">7.49</a>),
            fillexpression (<a href="#substafillexpression">7.50</a>),</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">and the table_ function (<a href="#funtable">8.61</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Almost<a name="5589"></a> the opposite of a 
FillExpression<a name="5590"></a> statement (see 
<a href="#substafillexpression">7.50</a>). Prints<a name="5592"></a> the contents of a 
table<a name="5593"></a> according to the current format (see 
<a href="#substaformat">7.52</a>). The output can go to standard output, the 
log<a name="5595"></a> file<a name="5596"></a> or a specified file. The elements of 
the table that have been defined and filled are written in the form of 
fill<a name="5597"></a> statements (see <a href="#substafill">7.49</a>) in such a way that they 
can be read in a future program to fill the table with the current 
contents. This is especially useful when the fillexpression statement has 
been used to dynamically extend tables based on what FORM has encountered 
during running. This way those elements will not have to be computed again 
in future programs. 

</p><p>
The options are

</p><p>
<table width="59">
<tbody><tr><td>+f
</td></tr>
</tbody></table>
<br>
<table width="667">
<tbody><tr><td>Output is to the logfile and not to the screen.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="59">
<tbody><tr><td>-f
</td></tr>
</tbody></table>
<br>
<table width="667">
<tbody><tr><td>Output is both to the logfile and to the screen. This is 
the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="59">
<tbody><tr><td>+s
</td></tr>
</tbody></table>
<br>
<table width="667">
<tbody><tr><td>Output will be in a mode in which each new term starts a 
new line.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="59">
<tbody><tr><td>-s
</td></tr>
</tbody></table>
<br>
<table width="667">
<tbody><tr><td>Output will be in the regular mode in which new terms 
continue to be written on the same line within the limits of the number of 
characters per line as set in the format statement. Default is 72 
characters per line. This can be changed with the format<a name="9820"></a> 
statement (see <a href="#substaformat">7.52</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
If redirection to a file is specified output will be only to this 
file. The +f option will be ignored. There are two possibilities:

</p><p>
<table width="127">
<tbody><tr><td><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"> filename
</td></tr>
</tbody></table>
<br>
<table width="599">
<tbody><tr><td>The old contents of the file with name `filename' will be 
overwritten<a name="9834"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="127">
<tbody><tr><td><img width="24" height="28" align="MIDDLE" border="0" src="./online_files/img65.png" alt="$&gt;\!\!&gt;$"> filename
</td></tr>
</tbody></table>
<br>
<table width="599">
<tbody><tr><td>The table will be appended<a name="9847"></a> to the file 
with the name `filename'. This allows the writing of more than one table to 
a file.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081080000000000000000"></a>
<a name="substaprocessbucketsize"></a>
<br>
processbucketsize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">processbucketsize <tt>&lt;</tt>value<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">moduleoption (<a href="#substamoduleoption">7.81</a>), setup 
(<a href="#setupprocessbucketsize">16</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Sets the number of terms<a name="5635"></a> in the buckets that are sent 
to the secondary processors in P<small>AR</small>FORM<a name="5636"></a>, one of the 
parallel<a name="5637"></a> versions of FORM (see chapter <a href="#parallel">17</a>). In 
all other versions this statement is ignored. See also the moduleoption 
(<a href="#substamoduleoption">7.81</a>) statement and the corresponding parameter for 
the setup (<a href="#setupprocessbucketsize">16</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081090000000000000000"></a>
<a name="substapropercount"></a>
<br>
propercount
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">propercount <tt>&lt;</tt>on/off<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>), off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5652"></a> is obsolete<a name="5653"></a>. 
The user should try to use the propercount option of the on<a name="5654"></a> (see 
<a href="#substaon">7.99</a>) or the off<a name="5656"></a> (see <a href="#substaoff">7.98</a>) statements. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081100000000000000000"></a>
<a name="substapushhide"></a>
<br>
pushhide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">pushhide;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">hide (<a href="#substahide">7.59</a>),
              nhide (<a href="#substanhide">7.88</a>),
              unhide (<a href="#substaunhide">7.146</a>),
              nunhide (<a href="#substanunhide">7.96</a>),
              pophide (<a href="#substapophide">7.104</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Hides<a name="5670"></a> all currently<a name="5671"></a> active 
expressions (see <a href="#substahide">7.59</a>). The pophide<a name="5673"></a> statement 
(see <a href="#substapophide">7.104</a>) can bring them back to active status again. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081110000000000000000"></a>
<a name="substaputinside"></a>
<br>
putinside
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">putinside <tt>&lt;</tt>name of function<tt>&gt;</tt> [,<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">bracket information<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">AntiPutInside (<a href="#substaantiputinside">7.3</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
This statement<a name="5685"></a> puts the complete term inside a 
function argument. The function must be a regular function (hence no tensor 
or table which are special types of functions). If there is 
bracket<a name="5686"></a> information, this information should adhere to the 
syntax of the bracket statement (<a href="#substaantiputinside">7.3</a>) and only 
occurrences of the bracket variables will be put inside the function. The 
coefficient will also be put inside the function.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081120000000000000000"></a>
<a name="substaratio"></a>
<br>
ratio
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ratio <tt>&lt;</tt>symbol1<tt>&gt;</tt> <tt>&lt;</tt>symbol2<tt>&gt;</tt> <tt>&lt;</tt>symbol3<tt>&gt;</tt>;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5701"></a> can be used for limited but fast 
partial<a name="5702"></a> fractioning. In the statement
</p><pre>   ratio a,b,c;
</pre>
in which <code>a</code>, <code>b</code> and <code>c</code> should be three symbols FORM 
will assume that <img width="67" height="29" align="MIDDLE" border="0" src="./online_files/img66.png" alt="$c = b-a$"> and then make the substitutions
<br>
<div align="CENTER">

<!-- MATH
 \begin{eqnarray}
\frac{1}{a^m}\frac{1}{b^n} & = & \sum_{i=0}^{m-1}\sign(i)
        \binom(n-1+i,n-1)\frac{1}{a^{m-i}}\frac{1}{c^{n+i}}
        +\sum_{i=0}^{n-1}\sign(m)
        \binom(m-1+i,m-1)\frac{1}{b^{n-i}}\frac{1}{c^{m+i}}
        \nonumber \\
    \frac{b^n}{a^m} & = & \sum_{i=0}^n\binom(n,i)\frac{c^i}{a^{m-n+i}}
            \ \ \ \ \ \ \ \hfill m\ge n \nonumber \\
    \frac{b^n}{a^m} & = & \sum_{i=0}^{m-1}\binom(n,i)\frac{c^{n-i}}{a^{m-i}}
        + \sum_{i=0}^{n-m}\binom(m-1+i,m-1)
            c^ib^{n-m-i}
            \ \ \ \ \ \ \ \hfill m<n \nonumber
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="48" height="49" align="MIDDLE" border="0" src="./online_files/img67.png" alt="$\displaystyle \frac{1}{a^m}\frac{1}{b^n}$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="508" height="65" align="MIDDLE" border="0" src="./online_files/img68.png" alt="$\displaystyle \sum_{i=0}^{m-1}\sign(i)
\binom(n-1+i,n-1)\frac{1}{a^{m-i}}\frac...
... +\sum_{i=0}^{n-1}\sign(m)
\binom(m-1+i,m-1)\frac{1}{b^{n-i}}\frac{1}{c^{m+i}}$"></td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
<tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="28" height="51" align="MIDDLE" border="0" src="./online_files/img69.png" alt="$\displaystyle \frac{b^n}{a^m}$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="200" height="60" align="MIDDLE" border="0" src="./online_files/img70.png" alt="$\displaystyle \sum_{i=0}^n\binom(n,i)\frac{c^i}{a^{m-n+i}}
       \hfill m\ge n$"></td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
<tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="28" height="51" align="MIDDLE" border="0" src="./online_files/img69.png" alt="$\displaystyle \frac{b^n}{a^m}$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="426" height="65" align="MIDDLE" border="0" src="./online_files/img71.png" alt="$\displaystyle \sum_{i=0}^{m-1}\binom(n,i)\frac{c^{n-i}}{a^{m-i}}
+ \sum_{i=0}^{n-m}\binom(m-1+i,m-1)
c^ib^{n-m-i}
       \hfill m&lt;n$"></td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
Of course, such substitutions can be made also by the user in a more 
flexible way. This statement has however the advantage of the best speed.
<br>
<br>

<p>
Actually the ratio statement is a leftover from the 
Schoonschip<a name="5741"></a> 
inheritance. For most simple partial fractioning one could use
</p><pre>   repeat id 1/[x+a]/[x+b] = (1/[x+a]-1/[x+b])/[b-a];
   repeat id [x+a]/[x+b] = 1-[b-a]/[x+b];
   repeat id [x+b]/[x+a] = 1+[b-a]/[x+a];
</pre>
or similar constructions. This does not give the speed of the 
binomials<a name="5744"></a>, but it does make the program more readable and 
it is much more flexible.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081130000000000000000"></a>
<a name="substarcyclesymmetrize"></a>
<br>
rcyclesymmetrize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">rc[yclesymmetrize] <code>{</code><tt>&lt;</tt>name of function/tensor<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>];<code>}</code></td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">symmetrize (<a href="#substasymmetrize">7.131</a>), cyclesymmetrize 
(<a href="#substacyclesymmetrize">7.23</a>), antisymmetrize (<a href="#substaantisymmetrize">7.4</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The argument<a name="5759"></a> specifications are explained 
in the section on the symmetrize<a name="5760"></a> statement (see 
<a href="#substasymmetrize">7.131</a>). 
</p><p>
<br>

</p><p>
The action of this statement is to
reverse<a name="5762"></a>-cycle-symmetrize
<a name="5763"></a> the (specified) arguments of the functions 
that are mentioned. This means that the arguments are brought to `natural 
order' in the notation of FORM by trying cyclic and reverse cyclic 
permutations<a name="5764"></a> of the arguments or groups of arguments. 
The `natural order' may depend on the order of declaration of the 
variables. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081140000000000000000"></a>
<a name="substaredefine"></a>
<br>
redefine
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">r[edefine] <tt>&lt;</tt>preprocessor variable<tt>&gt;</tt> "<tt>&lt;</tt>string<tt>&gt;</tt>";</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">preprocessor variables in the chapter on the preprocessor 
    (<a href="#preprocessor">3</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5777"></a> can be used to change the contents 
of preprocessor<a name="5778"></a> 
variables<a name="5779"></a>. The new contents can be used after 
the current module has finished execution and the preprocessor becomes 
active again for further translation and compilation<a name="5780"></a>. 
This termwise adaptation of the value of a preprocessor variable can be 
very useful in setting up multi module loops until a certain condition is 
not met any longer. Example:
</p><pre>   #do i = 1,1
      statements;
      if ( condition ) redefine i "0";
      .sort
   #enddo
</pre>
As long as there is a term that fulfils the condition the loop<a name="5783"></a> 
will continue. This defines effectively a while loop<a name="5784"></a> (see 
<a href="#substawhile">7.149</a>) over various modules. Note that the .sort<a name="5786"></a> 
instruction is essential. Note also that a construction like
<pre>   if ( count(x,1) &gt; 3 ) redefine i "`i'+1";
</pre>
is probably not going to do what the user intends. It is not going to count 
terms with more than three powers of x. The preprocessor will insert the 
compile time value of the preprocessor variable i. If this is 0, then each 
time a term has more than three powers of x, i will get the string value 
<code>0+1</code>. If one would like to do such counting, one should use a 
dollar variable<a name="5789"></a> (see <a href="#dollars">6</a>). <br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081150000000000000000"></a>
<a name="substarenumber"></a>
<br>
renumber
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">renumber <tt>&lt;</tt>number<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">sum (<a href="#substasum">7.129</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Renumbers<a name="5801"></a> the dummy<a name="5802"></a> 
indices<a name="5803"></a>. Dummy indices are indices of the type 
<code>N1_?</code>. Normally FORM tries to renumber these indices to make the 
internal representation of a term `minimal'. It does not try exhaustively 
though. Especially interference with symmetric or antisymmetric functions 
is far from perfect. This is due to considerations of economy. With the 
renumber statement the user can force FORM to do better. The allowable 
options are:

</p><p>
<table width="45">
<tbody><tr><td>0
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>All exchanges of one pair of dummy indices are tried 
until all pair exchanges yield no improvements. This is the default if no 
option is specified.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="45">
<tbody><tr><td>1
</td></tr>
</tbody></table>
<br>
<table width="680">
<tbody><tr><td>If there are N sets of dummy indices all N! 
permutations<a name="9878"></a> are tried. This can be very costly when a 
large number of indices is involved. Use with care!</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081160000000000000000"></a>
<a name="substarepeat"></a>
<br>
repeat
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">repeat;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">repeat <tt>&lt;</tt>executable statement<tt>&gt;</tt></td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">endrepeat (<a href="#substaendrepeat">7.41</a>), while (<a href="#substawhile">7.149</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The repeat<a name="5823"></a> statement starts a
repeat<a name="5824"></a> environment. It is terminated with an 
endrepeat<a name="5825"></a> statement (see <a href="#substaendrepeat">7.41</a>). The 
repeat statement and its matching endrepeat statement should be inside the 
same module. <br>
<br>

</p><p>
The statements inside the repeat environment should all be 
executable statements (or print statements) and if any of the executable 
statements inside the environment has changed the current term, the action 
of the endrepeat statement will be to bring control back to the beginning 
of the environment. In that sense the repeat/endrepeat combination acts as
</p><pre>   do
      executable statements
   while any action due to any of the statements
</pre>
The second form of the statement is a shorthand<a name="5830"></a> notation:
<pre>   repeat;
      single statement;
   endrepeat;
</pre>
is equivalent to
<pre>   repeat single statement;
</pre>
Particular attention should be given to avoid infinite<a name="5835"></a> 
loops<a name="5836"></a> as in
<pre>   repeat id a = a+1;
</pre>
A more complicated infinite loop is
<pre>   repeat;
      id  S(x1?)*R(x2?) = T(x1,x2,x2-x1);
      id  T(x1?,x2?,x3?pos_) = T(x1,x2-2,x3-1)*X(x2);
      id  T(x1?,x2?,x3?) = S(x1)*R(x2);
   endrepeat;
</pre>
If the current term is S(2)*R(2), the statements in the loop do not change 
it in the end. Yet the program goes into an infinite loop, because the 
first id statement will change the term (action) and the third statement 
will change it back. FORM does not check that the term is the same 
again. Hence there is action inside the repeat environment and hence the 
statements will be executed again. This kind of hidden action is a major 
source of premature<a name="5842"></a> 
terminations<a name="5843"></a> of FORM programs. <br>
<br>

<p>
Repeat environments can be nested<a name="5846"></a> with all other 
environments (and of course also with other repeat/endrepeat combinations). 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081170000000000000000"></a>
<a name="substareplaceloop"></a>
<br>
replaceloop
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">replaceloop <tt>&lt;</tt>parameters<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the findloop option of the if statement (<a href="#substaif">7.63</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
This statement<a name="5857"></a> causes the substitution of 
index<a name="5858"></a> loops<a name="5859"></a>. An index loop is a 
sequence of contracted indices in which the indices are arguments of 
various instances of the same function and each contracted<a name="5860"></a> index<a name="5861"></a> occurs once in one instance of the 
function and once in another instance of the function. Such a contraction 
defines a connection and if a number of such connections between 
occurrences of the function form a loop this structure is a candidate for 
replacement. Examples of such loops are:
</p><pre>    f(i1,i2,j1)*f(i2,i1,j2)
    f(i1,i2,j1)*f(i2,i3,j2)*f(i1,i3,j3)
    f(i1,k1,i2,j1)*f(k2,i2,i3,j2)*f(i1,k3,i3,j3)
</pre>
The first term has a loop of two functions or vertices<a name="5864"></a> and 
the other two terms each define a loop of three vertices. The parameters 
are:

<p>
<table width="181">
<tbody><tr><td><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">name<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The name of the function that defines the `vertices'. 
This must always be the first parameter.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>arguments=number
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Only occurrences of the vertex function with the 
specified number of arguments will be considered. The specification of this 
parameter is mandatory.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>loopsize=number
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Only a loop with this number of vertices will be 
considered.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>loopsize=all
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>All loop<a name="9929"></a> sizes will be considered and the 
smallest loop is substituted.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>loopsize<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">number
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Only loops with fewer vertices than `number' will be 
considered and the smallest looop will be substituted.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>outfun=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">name<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Name of an output function in which the remaining 
arguments of all the vertex functions will be given. This parameter is 
mandatory.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>include-<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">name<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Name of a summable index that must be one of the links in 
the loop. This parameter is optional.</td></tr>
</tbody></table>
    <br>

</p><p>
The loopsize<a name="5893"></a> parameter is mandatory. Hence one of 
its options must be specified. The order of the parameters is not 
important. The only important thing is that the name of the vertex function 
must be first. The names of the keywords may be abbreviated as in
</p><pre>    ReplaceLoop f,a=3,l=all,o=ff,i=i2;
</pre>
although this does not improve the readability of the program. Hence a more 
readable abbreviated version might be
<pre>    ReplaceLoop f,arg=3,loop=all,out=ff,inc=i2;
</pre>

<p>
The action of the statement is to remove the vertex functions 
that constitute the loop and replace them by the output function. This 
outfun will have the arguments of all the vertex functions minus the 
contracted indices that define the loop. The order of the arguments is the 
order in which they are encountered when following the loop. The order of 
the arguments in the outfun depends however on the order in which FORM 
encounters the vertices. Hence the outfun will often be 
cyclesymmetric<a name="5898"></a><a name="5899"></a> (see 
<a href="#substafunctions">7.54</a> and <a href="#substacyclesymmetrize">7.23</a>). If FORM has to 
exchange indices to make a `proper loop' (i.e. giving relevance to the 
first index as if it is something incoming and the second index as if it is 
something outgoing) and if the vertex function is 
antisymmetric<a name="5902"></a><a name="5903"></a>, each exchange will 
result in a minus sign. Examples:
</p><pre>    Functions f(antisymmetric),ff(cyclesymmetric);
    Indices i1,...,i8;
    Local F = f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*f(i4,i7,i8);
    ReplaceLoop f,arg=3,loop=3,out=ff;
</pre>
would result in
<pre>    -f(i4,i7,i8)*ff(i4,i5,i6)
</pre>
and
<pre>    Functions f(antisymmetric),ff(cyclesymmetric);
    Indices i1,...,i9;
    Local F = f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*f(i4,i7,i8)
            *f(i6,i7,i8);
    ReplaceLoop f,arg=3,loop=all,out=ff;
</pre>
would give
<pre>    -f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*ff(i4,i6)
</pre>
because the smallest loop will be taken. A number of examples can be found 
in the package<a name="5912"></a> `color'<a name="5913"></a> for group 
theory<a name="5914"></a> invariants that is part of the FORM 
distribution. 

<p>
A related object is the findloop<a name="5915"></a> option of the 
if<a name="5916"></a> statement (see <a href="#substaif">7.63</a>). This option just probes 
whether a loop is present but makes no replacements.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081180000000000000000"></a>
<a name="substasave"></a>
<br>
save
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">sa[ve] <tt>&lt;</tt>filename<tt>&gt;</tt> [<tt>&lt;</tt>names of global expressions<tt>&gt;</tt>];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">load (<a href="#substaload">7.75</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Saves<a name="5930"></a> the contents of the store<a name="5931"></a> 
file<a name="5932"></a> (all global expressions that were stored in 
.store<a name="5933"></a> 
instructions) to a file with the indicated name. If a list of expressions 
is provided only those expressions are saved and the others are ignored. 

</p><p>
Together with the load<a name="5934"></a> statement (see 
<a href="#substaload">7.75</a>) the save statement provides a mechanism to transfer data 
in internal notation from one program to another. It is the preferred method 
to keep results of a lengthy job for further analysis without the need for 
the long initial running time.

</p><p>
In order to avoid confusion .sav<a name="ex:sav"></a><a name="5937"></a> is the 
preferred extension<a name="5938"></a> of saved files.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081190000000000000000"></a>
<a name="substaselect"></a>
<br>
select
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">select <tt>&lt;</tt>list of sets<tt>&gt;</tt> <tt>&lt;</tt>pattern<tt>&gt;</tt> = <tt>&lt;</tt>expression<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">identify (<a href="#substaidentify">7.60</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="5953"></a> is identical to the select option of 
the id<a name="5954"></a> statement (see <a href="#substaidentify">7.60</a>). Hence
</p><pre>   select ....
</pre>
is just a shorthand notation for
<pre>   id select ....
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081200000000000000000"></a>
<a name="substaset"></a>
<br>
set
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">set <tt>&lt;</tt>set to be declared<tt>&gt;</tt>:<tt>&lt;</tt>element<tt>&gt;</tt> [<tt>&lt;</tt>more elements<tt>&gt;</tt>];</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Declares a single set<a name="5973"></a> and specifies its 
elements<a name="5974"></a>. Sets have a type of variables connected to them. 
There can be sets of symbols, sets of functions, sets of vectors, sets of 
indices and sets of numbers. For the purpose of sets tensors<a name="5975"></a> 
and tables<a name="5976"></a> count as functions.

</p><p>
There can also be mixed sets<a name="5977"></a> of indices and 
numbers. When a number could be either a fixed index or just a number FORM 
will keep the type of the set unfixed. This can change either when the next 
element is a symbolic index or a number that cannot be a fixed index (like 
a negative number). If the status does not get resolved the set can be used 
in the wildcarding of both symbols and indices. Normally sets of numbers 
can be used only in the wildcarding of symbols. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081210000000000000000"></a>
<a name="substasetexitflag"></a>
<br>
setexitflag
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">setexitflag;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">exit (<a href="#substaexit">7.44</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Causes<a name="5986"></a> termination<a name="5987"></a> of the 
program after execution<a name="5988"></a> of the current module has 
finished. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081220000000000000000"></a>
<a name="substashuffle"></a>
<br>
shuffle
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">shuffle,functionname;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">shuffle,once,functionname;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">stuffle (<a href="#substastuffle">7.128</a>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">merge (<a href="#substamerge">7.79</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement is exactly the same as the merge<a name="5998"></a> 
statement. It takes two occurrences of the mentioned function and outputs 
terms, each with one function in which the two argument lists have been 
merged in all different ways, keeping the relative ordering of the two 
lists preserved. It is the opposite of the 
distrib_<a name="5999"></a><a name="6000"></a> function (see 
<a href="#fundistrib">8.12</a>). Hence
</p><pre>   Local F = f(a,b)*f(c,d);
   shuffle,f;
</pre>
will result in
<pre>      +f(a,b,c,d)+f(a,c,b,d)+f(a,c,d,b)+f(c,a,b,d)+f(c,a,d,b)+f(c,d,a,b)
</pre>
One can also obtain the same result with the statements
<pre>   Multiply,ff;
   repeat id f(x1?,?a)*f(x2?,?b)*ff(?c) =
            +f(?a)*f(x2,?b)*ff(?c,x1)
            +f(x1,?a)*f(?b)*ff(?c,x2);
   id f(?a)*f(?b)*ff(?c) = f(?c,?a,?b);
</pre>
but the advantage of the shuffle statement is that is also does a certain 
amount of combinatorics when there are identical arguments. Unfortunately 
the combinatorics doesn't extend over groups of arguments that are 
identical as in
<pre>    CF  f;
    L   F = f(0,1,0,1,0,1)*f(0,1,0,1,0,1);
    Shuffle,f;
    .end

Time =       0.00 sec    Generated terms =        141
               F         Terms in output =         32
                         Bytes used      =        892
</pre>
It does get the combinatorics between two zeroes or two ones, but it cannot 
handle the groups. The explicit method above however doesn't do any 
combinatorics and generates 924 terms.

<p>
One of the applications of this statement is in the field of harmonic 
sums<a name="6010"></a>, 
harmonic polylogarithms<a name="6011"></a> and multiple zeta 
values<a name="6012"></a><a name="6013"></a>. Its twin brother is the 
stuffle statement<a name="6014"></a> (see <a href="#substastuffle">7.128</a>).

</p><p>
When the option once is mentioned, only one pair will be contracted this 
way. Without this option all occurrences of the function inside a term will 
be treated till there are only terms with a single occurrence of the 
function.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081230000000000000000"></a>
<a name="substaskip"></a>
<br>
skip
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">skip;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">skip <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">nskip (<a href="#substanskip">7.92</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In the first<a name="6026"></a> variety this statement marks all 
active<a name="6027"></a> expressions that are in existence at the moment this 
statement is compiled, to be skipped. In the second variety this is done 
only to the active expressions that are specified. If an expression is 
skipped in a given module, the statements in the module have no effect on 
it. Also it will not be sorted<a name="6028"></a> again at the end of the module. 
This means that any bracket<a name="6029"></a> information (see 
<a href="#substabracket">7.10</a>) in the expression remains the way it was. Consult also 
the nskip<a name="6031"></a> statement in <a href="#substanskip">7.92</a>. <br>
<br>

</p><p>
Skipped expressions can be used in the expressions in the r.h.s. 
of id<a name="6034"></a> statements (see <a href="#substaidentify">7.60</a>) or 
multiply<a name="6036"></a> statements (see <a href="#substamultiply">7.84</a>), etc. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081240000000000000000"></a>
<a name="substasort"></a>
<br>
sort
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">sort;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">term (<a href="#substaterm">7.135</a>), endterm (<a href="#substaendterm">7.42</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Statement<a name="6047"></a> to be used inside the term<a name="6048"></a> 
environment<a name="6049"></a> (see <a href="#substaterm">7.135</a> and 
<a href="#substaendterm">7.42</a>). It forces a sort in the same way as a 
.sort<a name="6052"></a> instruction forces a sort for entire expressions. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081250000000000000000"></a>
<a name="substasplitarg"></a>
<br>
splitarg
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">splitarg options <code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
             [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">splitfirstarg (<a href="#substasplitfirstarg">7.126</a>),
             splitlastarg (<a href="#substasplitlastarg">7.127</a>),
             factarg (<a href="#substafactarg">7.46</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Takes<a name="6067"></a> the indicated argument<a name="6068"></a> of a 
function and if such an argument is a subexpression that consists on more 
than one term, all terms become single arguments of the function as in
</p><pre>   f(a+b-5*c*d) --&gt; f(a,b,-5*c*d)
</pre>
The way arguments are indicated is rather similar to the way this is done 
in the argument<a name="6071"></a> statement (see 
<a href="#substaargument">7.8</a>). One can however indicate only a single group of 
functions in one statement. Additionally there are other options. All 
options are in the order that they should be specified:

<p>
<table width="227">
<tbody><tr><td>(term)
</td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>Only terms that are a numerical multiple of the given 
term are split off. The terms that are split off will trail the remainder.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="227">
<tbody><tr><td>((term))
</td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>Only terms that contain the given term will be split off. 
The terms that are split off will trail the remainder.</td></tr>
</tbody></table>
    <br>

</p><p>
The statement is terminated with a sequence of functions or 
sets<a name="6081"></a> of functions. The splitting action will apply only to the 
specified functions or to members of the set(s). If no functions or sets of 
functions are specified all functions will be treated, including the built 
in functions.

</p><p>
The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified, all arguments will be treated. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081260000000000000000"></a>
<a name="substasplitfirstarg"></a>
<br>
splitfirstarg
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">splitfirstarg <code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">splitarg (<a href="#substasplitarg">7.125</a>),
             splitlastarg (<a href="#substasplitlastarg">7.127</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
A little<a name="6095"></a> bit like the 
SplitArg<a name="6096"></a> statement (see <a href="#substasplitarg">7.125</a>). Splits the 
given argument(s) into its first term and a remainder. Then replaces the 
argument by the remainder<a name="6098"></a>, followed by the first term.

</p><p>
The statement is terminated with a sequence of functions or sets 
of functions. The splitting action will apply only to the specified 
functions or to members of the set(s). If no functions or sets<a name="6099"></a> 
of functions are specified all functions will be treated, including the 
built in functions.

</p><p>
The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified all arguments will be treated. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081270000000000000000"></a>
<a name="substasplitlastarg"></a>
<br>
splitlastarg
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">splitlastarg <code>{</code><tt>&lt;</tt>name of function/set<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>]<code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">splitarg (<a href="#substasplitarg">7.125</a>),
             splitfirstarg (<a href="#substasplitfirstarg">7.126</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
A little<a name="6113"></a> bit like the 
SplitArg<a name="6114"></a> statement (see <a href="#substasplitarg">7.125</a>). Splits the 
given argument(s) into its last term and a remainder. Then replaces the 
argument by the remainder, followed by the last term.

</p><p>
The statement is terminated with a sequence of functions or sets 
of functions. The splitting action will apply only to the specified 
functions or to members of the set(s). If no functions or sets<a name="6116"></a> 
of functions are specified all functions will be treated, including the 
built in functions.

</p><p>
The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified all arguments will be treated. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081280000000000000000"></a>
<a name="substastuffle"></a>
<br>
stuffle
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">stuffle,functionname+;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">stuffle,functionname-;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">stuffle,once,functionname+;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">stuffle,once,functionname-;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">shuffle (<a href="#substashuffle">7.122</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement 
takes two occurrences of the mentioned function and outputs 
terms, each with one function in which the two argument lists have been 
merged according to the rules for nested sums. The plus and minus signs 
refer to ones favorite definition for nested sums. In the case of the plus 
sign, the definition is
<br>
</p><div align="CENTER">

<!-- MATH
 \begin{eqnarray}
\sum_{i=1}^N \sum_{i=1}^N & = & \sum_{i=1}^N \sum_{j=1}^{i-1}
        + \sum_{j=1}^N \sum_{i=1}^{j-1}
        + \sum_{i=j=1}^N
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="53" height="66" align="MIDDLE" border="0" src="./online_files/img72.png" alt="$\displaystyle \sum_{i=1}^N \sum_{i=1}^N$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="173" height="67" align="MIDDLE" border="0" src="./online_files/img73.png" alt="$\displaystyle \sum_{i=1}^N \sum_{j=1}^{i-1}
+ \sum_{j=1}^N \sum_{i=1}^{j-1}
+ \sum_{i=j=1}^N$"></td>
<td width="10" align="RIGHT">
(7.4)</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
while in the case of the minus the definition is
<br>
<div align="CENTER">

<!-- MATH
 \begin{eqnarray}
\sum_{i=1}^N \sum_{i=1}^N & = & \sum_{i=1}^N \sum_{j=1}^{i}
        + \sum_{j=1}^N \sum_{i=1}^{j}
        - \sum_{i=j=1}^N
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="53" height="66" align="MIDDLE" border="0" src="./online_files/img72.png" alt="$\displaystyle \sum_{i=1}^N \sum_{i=1}^N$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="173" height="67" align="MIDDLE" border="0" src="./online_files/img74.png" alt="$\displaystyle \sum_{i=1}^N \sum_{j=1}^{i}
+ \sum_{j=1}^N \sum_{i=1}^{j}
- \sum_{i=j=1}^N$"></td>
<td width="10" align="RIGHT">
(7.5)</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
It is assumed that we have harmonic sums<a name="6151"></a> (see the 
summer library in the FORM distribution). For such sums we expect 
functions with lists of nonzero integer arguments. Example:
<pre>    CF  S,R;
    Symbols N,n;
    L   F = S(R(1,-3),N)*S(R(-5,1),N);
    id  S(R(?a),n?)*S(R(?b),n?) = S(?a)*S(?b)*R(n);
    Stuffle,S-;
    id  S(?a)*R(n?) = S(R(?a),n);
    Print +s;
    .end

Time =       0.00 sec    Generated terms =         12
               F         Terms in output =         12
                         Bytes used      =        462

   F =
       + S(R(-6,-4),N)
       - S(R(-6,-3,1),N)
       - S(R(-6,1,-3),N)
       - S(R(-5,1,-4),N)
       + S(R(-5,1,-3,1),N)
       + 2*S(R(-5,1,1,-3),N)
       - S(R(-5,2,-3),N)
       - S(R(1,-5,-4),N)
       + S(R(1,-5,-3,1),N)
       + S(R(1,-5,1,-3),N)
       + S(R(1,-3,-5,1),N)
       - S(R(1,8,1),N)
      ;
</pre>
The above program is equivalent to the basis procedure in the summer 
library. As with the shuffle<a name="6154"></a> statement (see 
<a href="#substashuffle">7.122</a>) a certain amount of combinatorics has been built in.

<p>
When the option once is mentioned, only one pair will be contracted this 
way. Without this option all occurrences of the function inside a term will 
be treated till there are only terms with a single occurrence of the 
function.

</p><p>
The stuffle command takes also the effect of roots of 
unity<a href="#rootofunity" name="6157">7.130</a> into account in the same way 
that the signs of alternating sums are taken into account. This means that 
the sum indices don't have to be integers, but could be multiples of a 
single symbol that has been declared to be a root of 
unity<a href="#substasymbols">7.130</a>.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081290000000000000000"></a>
<a name="substasum"></a>
<br>
sum
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">sum <tt>&lt;</tt>list of indices<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">renumber (<a href="#substarenumber">7.115</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
The given indices will be summed<a name="6169"></a> over. There are two 
varieties. In the first the index is followed by a sequence of nonnegative 
short integers. In that case the summation means that for each of the 
integers a new instance of the term is created in which the index is 
replaced by that integer. In the second variety the index is either the 
last object in the statement or followed by another index. In that case the 
index is replaced by an internal dummy<a name="6170"></a> 
index<a name="6171"></a> of the type <code>N1_?</code> (or with another number 
instead of the 1). Such indices have the current
default<a name="6172"></a> dimension<a name="6173"></a> and can 
be renamed at will by FORM to bring terms into standard notation. For 
example:
</p><pre>   f(N2_?,N1_?)*g(N2_?,N1_?)
</pre>
will be changed into
<pre>   f(N1_?,N2_?)*g(N1_?,N2_?).
</pre>
The user can use these dummy indices in the left hand side of 
id<a name="6178"></a> statements.
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081300000000000000000"></a>
<a name="substasymbols"></a>
<br>
symbols
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">s[ymbols] <tt>&lt;</tt>list of symbols to be declared<tt>&gt;</tt>;</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
Declares one or more symbols<a name="6188"></a>. Each symbol can be 
followed by a number of options. These are (assuming that x is the symbol 
to be declared):

</p><p>
<table width="109">
<tbody><tr><td>x#r
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The symbol is real<a name="10010"></a>. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="109">
<tbody><tr><td>x#c
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The symbol is complex<a name="10025"></a>. This means that two 
spaces are reserved for this symbol, one for x and one for x#(the 
complex conjugate).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="109">
<tbody><tr><td>x#i
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The symbol is imaginary<a name="10041"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="109">
<tbody><tr><td>x#=number
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The symbol is a number-th root of
unity<a name="10056"></a><a name="rootofunity"></a> This means that the number-th 
power of the symbol will be replaced by one and half this power (if even) 
by -1. Negative powers will be replaced by corresponding positive powers.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="109">
<tbody><tr><td>x(:5)
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The symbol has the maximum power 5. This means that <img width="20" height="16" align="BOTTOM" border="0" src="./online_files/img75.png" alt="$x^6$"> 
and higher powers are automatically eliminated during the 
normalization<a name="10070"></a> of a term. Of course any other number, 
positive or negative, is allowed.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="109">
<tbody><tr><td>x(-3:)
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The symbol has the minimum power -3. This means that 
<img width="30" height="16" align="BOTTOM" border="0" src="./online_files/img76.png" alt="$x^{-4}$"> and lower powers are automatically eliminated during the 
normalization of a term. Of course any other number, positive or negative, 
is allowed. Note that when the minimum power is positive, terms that have 
no power of x should technically be eliminated, but FORM will not do so. 
Such an action can be achieved at any moment with a combination of the 
count<a name="10084"></a><a name="10085"></a> option of an if<a name="10086"></a> statement (see 
<a href="#substaif">7.63</a>) and a discard<a name="10088"></a> statement (see 
<a href="#substadiscard">7.28</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="109">
<tbody><tr><td>x(-3:5)
</td></tr>
</tbody></table>
<br>
<table width="626">
<tbody><tr><td>The combination of a maximum and a minimum power 
restriction (see above).</td></tr>
</tbody></table>
    <br>
<br>
<br>

</p><p>
Complexity properties and power restrictions can be combined. In 
that case the complexity properties come first and then the power 
restrictions.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081310000000000000000"></a>
<a name="substasymmetrize"></a>
<br>
symmetrize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">symm[etrize] <code>{</code><tt>&lt;</tt>name of function/tensor<tt>&gt;</tt>
         [<tt>&lt;</tt>argument specifications<tt>&gt;</tt>];<code>}</code></td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">antisymmetrize (<a href="#substaantisymmetrize">7.4</a>), cyclesymmetrize 
(<a href="#substacyclesymmetrize">7.23</a>), rcyclesymmetrize (<a href="#substarcyclesymmetrize">7.113</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The arguments<a name="6239"></a> consist of the name of a function 
(or a tensor), possibly followed by some specifications. Hence we have the 
following varieties: <br>

</p><p>
<table width="227">
<tbody><tr><td><tt>&lt;</tt>name<tt>&gt;</tt>
</td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>The function is symmetrized in all its arguments.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="227">
<tbody><tr><td><tt>&lt;</tt>name<tt>&gt;&lt;</tt>numbers<tt>&gt;</tt>
</td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>The function is symmetrized in the arguments that are 
mentioned. If there are fewer arguments than the highest number mentioned 
in the list or arguments, no symmetrization will take place.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="227">
<tbody><tr><td><tt>&lt;</tt>name<tt>&gt;:&lt;</tt>number<tt>&gt;</tt>
</td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>Only functions with the specified number of arguments 
will be considered. Note: the number should follow the colon directly 
without intermediate space or comma.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="227">
<tbody><tr><td><tt>&lt;</tt>name<tt>&gt;:&lt;</tt>number<tt>&gt;&lt;</tt>numbers<tt>&gt;</tt>
</td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>If there is a number immediately following the colon, 
only functions with exactly that number of arguments will be considered. If 
the list of arguments contains numbers greater than this number, they will 
be ignored. If no number follows the colon directly, this indicates that 
symmetrization will take place, no matter the number of arguments of the 
function. If the list of arguments has numbers greater than the number of 
arguments of the function, these numbers will be ignored.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="227">
<tbody><tr><td><tt>&lt;</tt>name<tt>&gt;</tt>

<p>
<tt>&lt;</tt>(groups of numbers)<tt>&gt;</tt>
</p></td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>The groups are specified as lists of numbers of arguments 
between parenthesis. All groups must have the same number of arguments or 
there will be a compile error. The groups are symmetrized as groups. The 
arguments do not have to be adjacent. Neither do they have to be ordered. 
The symmetrization<a name="10179"></a> takes place in a way that the first elements of the 
groups are most significant, etc. If any argument number is greater than 
the number of arguments of the function, no symmetrization will take place.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="227">
<tbody><tr><td><tt>&lt;</tt>name<tt>&gt;:&lt;</tt>number<tt>&gt;</tt>

<p>
<tt>&lt;</tt>(groups of numbers)<tt>&gt;</tt>
</p></td></tr>
</tbody></table>
<br>
<table width="499">
<tbody><tr><td>The groups are specified as lists of numbers of arguments 
between parenthesis. All groups must have the same number of arguments or 
there will be a compile error. The groups are symmetrized as groups. The 
arguments do not have to be adjacent. Neither do they have to be ordered. 
The symmetrization takes place in a way that the first elements of the 
groups are most significant, etc. If no number follows the colon directly 
symmetrization takes place no matter the number of arguments of the 
function. Groups that contain a number that is greater than the number of 
arguments of the function will be ignored. If a number follows the colon 
directly, only functions with that number of arguments will be symmetrized. 
Again, groups that contain a number that is greater than the number of 
arguments of the function will be ignored.</td></tr>
</tbody></table>
    <br>
<br>
<br>

</p><p>
The action of this statement is to symmetrize the 
(specified) arguments of the functions that are mentioned. This means that 
the arguments are brought to `natural order' in the notation of FORM by 
trying permutations<a name="6281"></a> of the arguments or groups of 
arguments. The `natural order' may depend on the order of declaration of 
the variables. <br>
<br>

</p><p>
Examples:
</p><pre>   Symmetrize Fun;
   Symmetrize Fun 1,2,4;
   Symmetrize Fun:5;
   Symmetrize Fun: 1,2,4;
   Symmetrize Fun:5 1,2,4;
   Symmetrize Fun (1,6),(7,3),(5,2);
   Symmetrize Fun:8 (1,6),(7,3),(5,2);
   Symmetrize Fun: (1,6),(7,3),(5,2);
</pre>
 <br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081320000000000000000"></a>
<a name="substatable"></a>
<br>
table
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">table <tt>&lt;</tt>options<tt>&gt;</tt> <tt>&lt;</tt>table to be 
declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), ctable (<a href="#substactable">7.21</a>),
        ntable (<a href="#substantable">7.93</a>), fill (<a href="#substafill">7.49</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
The statement declares a single table<a name="6300"></a>. A table is a 
very special instance of a function. Hence it can be either 
commuting<a name="6301"></a> or noncommuting<a name="6302"></a>. The table 
statement declares its function to be commuting. A noncommuting table is 
declared with the ntable<a name="6303"></a> statement (see <a href="#substantable">7.93</a>). A 
table has a number of table<a name="6305"></a> indices (at least one!) 
and after that it can have a number of regular function arguments with or 
without wildcarding. The table indices can come in two varieties: 
matrix<a name="6306"></a> like or sparse<a name="6307"></a>. In the case of a 
matrix like table<a name="6308"></a>, for each of the indices a range 
has to be specified. FORM then reserves a location for each of the 
potential elements. For a sparse table<a name="6309"></a> one only 
specifies the number of indices. Sparse tables take less space, but they 
require more time searching whether an element has been defined. For a 
matrix like table FORM can look directly whether an element has been 
defined. Hence one has a tradeoff between space and speed.
<br>
<br>

</p><p>
Table elements are defined with the fill<a name="6311"></a> statement (see 
<a href="#substafill">7.49</a>). Fill statements for table elements cannot be used before 
the table has been declared with a table or ntable statement.
<br>
<br>

</p><p>
When FORM encounters an unsubstituted table it will look for its 
indices. Then it can check whether the table element has been defined. If 
not, it can either complain (when the `strict'<a name="6314"></a> option is 
used) or continue without substitution. Note that an unsubstituted table 
element is a rather expensive object as FORM will frequently check whether 
it can be substituted (new elements can be defined in a variety of 
ways....). If the indices match a defined table element, FORM will check 
whether the remaining arguments of the table will match the function-type 
arguments given in the table declaration in the same way regular function 
arguments are matched. Hence these arguments can contain 
wildcards<a name="6315"></a> and even argument<a name="6316"></a> field 
wildcards. If a match occurs, the table is replaced immediately.

</p><p>
The options are

</p><p>
<table width="181">
<tbody><tr><td>check<a name="10209"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>A check is executed on table boundaries. An element that is 
outside the table boundaries (regular matrix type tables only) will cause 
an error message and execution will be halted.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>relax<a name="10222"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Normally all elements of a table should be defined during 
execution and an undefined element will give an error message. The relax 
option switches this off and undefined elements will remain as if they are 
regular functions.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>sparse<a name="10235"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The table is considered to be sparse. In the case of a sparse 
table only the number of indices should be specified. Ranges are not 
relevant. Each table element is stored separately. Searching for table 
elements is done via a balanced tree<a name="10242"></a>. This takes of 
course more time than the matrix type search with is just by indexing. A 
matrix like table<a name="10243"></a> is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>strict<a name="10250"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>If this option is specified all table elements that are 
encountered during execution should be defined. An undefined table element 
will result in an error and execution is halted. Additionally all table 
elements should be properly defined at the end of the module in which the 
table has been defined.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>zerofill<a name="10263"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Any undefined table element is considered to be 
zero.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>
<table width="181">
<tbody><tr><td>onefill<a name="10276"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Any undefined table element is considered to be 
one.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>
The defaults are that the table is matrix like and table elements 
that cannot be substituted will result in an error.
<br>
<br>

</p><p>
Ranges for indices in matrix like tables are indicated with a 
colon as in
</p><pre>   Symbol x;
   Table t1(1:3,-2:4);
   Table t2(0:3,0:3,x?);
   Table sparse,t3(4);
</pre>
The table <code>t1</code> is two dimensional and has 21 elements. The table 
<code>t2</code> is also two dimensional and has 16 elements. In addition there is 
an extra argument which can be anything that a wildcard symbol will match. 
The table <code>t3</code> is a sparse table with 4 indices.
<br>
<br>

<p>
If the computer on which FORM runs is a 32<a name="6336"></a> bit 
computer no table can have more than <!-- MATH
 $2^{15} = 32768$
 -->
<img width="87" height="16" align="BOTTOM" border="0" src="./online_files/img77.png" alt="$2^{15} = 32768$"> elements. On a 
64<a name="6338"></a> bit computer the limit is <img width="26" height="16" align="BOTTOM" border="0" src="./online_files/img52.png" alt="$2^{31}$">, but one should take 
into account that each element declared causes some overhead. <br>
<br>

</p><p>
If the wildcarding in the declaration of a table involves the 
definition of a dollar variable<a name="6341"></a> (this is allowed! See 
<a href="#dollars">6</a>) parallel execution of the entire remainder of the FORM 
program is switched off. This is of course only relevant for parallel 
versions of FORM. But if at all possible one should try to find better 
solutions than this use of dollar variables, allowing future parallel 
processing of the program.

</p><p>
In some cases tables are built up slowly during the execution of 
a program and used incrementally. This means that more and more CPU memory 
is needed. Eventually this can cause a crash by lack of memory. In the case 
that the earlier elements of the table aren't needed anymore, one could use 
the ClearTable&nbsp;<a href="#substacleartable">7.15</a> statement.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081330000000000000000"></a>
<a name="substatablebase"></a>
<br>
tablebase
</h1>

<p>
This statement is explained in the chapter on 
tablebases<a name="6347"></a> (<a href="#tablebase">12</a>).
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081340000000000000000"></a>
<a name="substatensors"></a>
<br>
tensors
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">t[ensors] <tt>&lt;</tt>list of tensors to be declared<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">functions (<a href="#substafunctions">7.54</a>), ctensors 
        (<a href="#substactensors">7.22</a>), ntensors (<a href="#substantensors">7.94</a>)</td>
</tr>
</tbody></table>
<br>
<br>

</p><p>
A tensor<a name="6361"></a> is a special function that can have only 
indices for its arguments. If an index a contracted with the index of a 
vector Schoonschip<a name="6362"></a> notation is used. This means that the 
vector is written as a pseudo argument of the tensor. It should always be 
realized that in that case in principle the actual argument is a dummy 
index. Tensors come in two varieties: commuting<a name="6363"></a> and 
noncommuting<a name="6364"></a>. The tensor statement declares a tensor to 
be commuting. In order to declare a tensor to be noncommuting one should 
use the ntensor<a name="6365"></a> statement (see <a href="#substantensors">7.94</a>).

</p><p>
The options that exist for properties of tensors are the same as 
those for functions (see <a href="#substafunctions">7.54</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081350000000000000000"></a>
<a name="substaterm"></a>
<br>
term
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">term;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">endterm (<a href="#substaendterm">7.42</a>), sort (<a href="#substasort">7.124</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Begins the term<a name="6377"></a> environment<a name="6378"></a>. 
This environment is terminated with the endterm<a name="6379"></a> statement 
(see <a href="#substaendterm">7.42</a>). The action is that temporarily the current term 
is seen as a little expression by itself. The statements inside the 
environment are applied to it and one can even sort the results with the 
sort<a name="6381"></a> statement (see <a href="#substasort">7.124</a>) which should not be 
confused with the .sort<a name="6383"></a> instruction that terminates a module. 
Inside the term environment one can have only executable statements and 
possibly term-wise print statements (see <a href="#substaprint">7.105</a>). When the end 
of the term environment is reached, the results are sorted (as would be 
done with an expression at the end of a module) and execution continues 
with the resulting terms. This environment can be nested<a name="6385"></a>. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081360000000000000000"></a>
<a name="substatestuse"></a>
<br>
testuse
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">testuse ["<tt>&lt;</tt>tablename(s)<tt>&gt;</tt>"];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">tablebases (<a href="#tablebase">12</a>), testuse (<a href="#tbltestuse">12.10</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="6397"></a> is explained in the chapter on 
tablebases<a name="6398"></a>.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081370000000000000000"></a>
<a name="substathreadbucketsize"></a>
<br>
threadbucketsize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">ThreadBucketSize,number;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the section on TFORM(<a href="#tform">17.1</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="6407"></a> is only active in 
TFORM<a name="6408"></a>. In all other versions of FORM it is ignored. It sets 
the size of the buckets<a name="6409"></a> that the master<a name="6410"></a> thread 
prepares for treatment by the workers. Bigger buckets means less overhead 
in signals, but when the buckets are too big the workers may have to wait 
too long before getting tasks. The best bucket size is usually between 100 
and 1000, although this depends very much on the problem. The default value 
is currently 500. For more ways to set this variable one should consult the 
section on TFORM (<a href="#tform">17.1</a>). To find out what its value is, use the
`ON,setup;' statement (<a href="#substaon">7.99</a> and <a href="#setup">16</a>). <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081380000000000000000"></a>
<a name="substatopolynomial"></a>
<br>
topolynomial
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">topolynomial[,OnlyFunctions[,<tt>&lt;</tt>list of functions<tt>&gt;</tt>]];</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">factarg (<a href="#substafactarg">7.46</a>), FromPolynomial 
(<a href="#substafrompolynomial">7.53</a>) and ExtraSymbols (<a href="#substaextrasymbols">7.45</a>,
<a href="#sect-extrasymbols">2.11</a>).</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Starting with version 4.0 of FORM some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization(<a href="#substafactarg">7.46</a>) and output simplification (still to be 
implemented). The ToPolynomial statement takes each term, looks for objects 
that are not symbols to positive powers and replaces them by symbols. If 
the object has been encountered before, the same symbol will be used, 
otherwise a new symbol will be defined. The object represented by the 
`extra symbol' is stored internally and can be printed if needed with the 
%X option in the #write instruction (<a href="#prewrite">3.61</a>). Note that negative 
powers of symbols will also be replaced.

</p><p>
In some cases one would like to do this only for a subset of objects. It is 
possible to do this only for functions, using the OnlyFunctions option. If 
no functions are specified, all functions will be replaced by extra 
symbols. If a list of functions is specified, only those functions will be 
replaced.
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081390000000000000000"></a>
<a name="substatotensor"></a>
<br>
totensor
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">totensor [nosquare] [functions] [!<tt>&lt;</tt>vector or set<tt>&gt;</tt>] <tt>&lt;</tt>vector<tt>&gt;</tt> <tt>&lt;</tt>tensor<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">totensor [nosquare] [functions] [!<tt>&lt;</tt>vector or set<tt>&gt;</tt>] <tt>&lt;</tt>tensor<tt>&gt;</tt> <tt>&lt;</tt>vector<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">tovector (<a href="#substatovector">7.140</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Looks for multiple<a name="6450"></a> occurrences of the given 
vector, either inside dotproducts, contracted with a tensor, as argument of 
a function or as a loose vector with an index. In all occurrences in 
which the vector has been contracted a dummy index is introduced to make 
the contraction apparent. Then all these vectors with their indices are 
replaced by the specified tensor with all the indices of these vectors. To 
make this clearer:
<br>
</p><div align="CENTER">

<!-- MATH
 \begin{eqnarray}
p^{\mu_1}p^{\mu_2}p^{\mu_3} \rightarrow t^{\mu_1\mu_2\mu_3} \nonumber
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="146" height="30" align="MIDDLE" border="0" src="./online_files/img78.png" alt="$\displaystyle p^{\mu_1}p^{\mu_2}p^{\mu_3} \rightarrow t^{\mu_1\mu_2\mu_3}$"></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
and hence
<pre>   p.p1^2*f(p,p1)*p(mu)*tt(p1,p,p2,p)
</pre>
gives after <code>totensor p,t;</code>
<pre>   f(N1_?,p1)*tt(p1,N2_?,p2,N3_?)*t(p1,p1,mu,N1_?,N2_?,N3_?)
</pre>
<br>
<br>

<p>
The options are

</p><p>
<table width="159">
<tbody><tr><td>nosquare<a name="10297"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Dotproducts with twice the specified vector (square of 
the vector) are not taken into account.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>functions<a name="10310"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Vectors that are arguments of regular functions will also 
be considered. By default this is not done.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>!vector<a name="10323"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Dotproducts involving the specified vector are not 
treated.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>!set<a name="10336"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The set should be a set of vectors. All dotproducts 
involving a vector of the set are not treated.</td></tr>
</tbody></table>
    <br>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081400000000000000000"></a>
<a name="substatovector"></a>
<br>
tovector
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">tovector <tt>&lt;</tt>tensor<tt>&gt;</tt> <tt>&lt;</tt>vector<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">tovector <tt>&lt;</tt>vector<tt>&gt;</tt> <tt>&lt;</tt>tensor<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">totensor (<a href="#substatotensor">7.139</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The opposite<a name="6496"></a> of the totensor<a name="6497"></a> 
statement. The tensor is replaced by a product of the given vectors, each 
with one of the indices of the tensor as in:
<br>
</p><div align="CENTER">

<!-- MATH
 \begin{eqnarray}
t^{\mu_1\mu_2\mu_3} \rightarrow p^{\mu_1}p^{\mu_2}p^{\mu_3} \nonumber
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="146" height="30" align="MIDDLE" border="0" src="./online_files/img79.png" alt="$\displaystyle t^{\mu_1\mu_2\mu_3} \rightarrow p^{\mu_1}p^{\mu_2}p^{\mu_3}$"></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081410000000000000000"></a>
<a name="substatrace"></a>
<br>
trace4
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">trace4 [<tt>&lt;</tt>options<tt>&gt;</tt>] <tt>&lt;</tt>index<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">tracen (<a href="#substatracen">7.142</a>), chisholm (<a href="#substachisholm">7.14</a>),
    unittrace (<a href="#substaunittrace">7.147</a>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">and the chapter on gamma algebra (<a href="#gammaalgebra">14</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Takes the trace<a name="6521"></a> of the gamma<a name="6522"></a> 
matrices with the given trace<a name="6523"></a> line 
index<a name="6524"></a>. It assumes that the matrices are 
defined in four dimensions, hence it uses some relations that are only 
valid in four dimensions. For details about these relations and other 
methods used, consult chapter&nbsp;<a href="#gammaalgebra">14</a> on gamma matrices. The 
options are: <br>
<br>

</p><p>
<table width="181">
<tbody><tr><td>contract<a name="10349"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Try to use the Chisholm<a name="10356"></a> identity to eliminate this 
trace and contract it with other gamma matrices. See also 
<a href="#substachisholm">7.14</a>. This is the default.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>nocontract<a name="10364"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Do not use the Chisholm<a name="10371"></a> identity to eliminate this 
trace and contract it with other gamma matrices. See also 
<a href="#substachisholm">7.14</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>nosymmetrize<a name="10379"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>When using the Chisholm<a name="10386"></a> identity to eliminate this 
trace and contract it with other gamma matrices, do not do it in the 
symmetric fashion, but use the first contraction encountered. See also 
<a href="#substachisholm">7.14</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>notrick<a name="10394"></a>
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The final stage of trace taking, when all indices are different 
and there are no contractions with identical vectors, as well as no 
<img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> matrices present, is done with n-dimensional methods, rather 
than with 4-dimensional tricks.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>symmetrize
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>When using the Chisholm identity to eliminate this trace and 
contract it with other gamma matrices, try to do it in the symmetric 
fashion. See also <a href="#substachisholm">7.14</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>trick
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>The final stage of trace taking, when all indices are different 
and there are no contractions with identical vectors is done using the 
4-dimensional relation

<p>
<!-- MATH
 $\gamma^a\gamma^b\gamma^c = \epsilon^{abcd}\gamma_5\gamma^d
    +\gamma^a\delta^{bc}-\gamma^b\delta^{ac}+\gamma^c\delta^{ab}$
 -->
<img width="305" height="34" align="MIDDLE" border="0" src="./online_files/img80.png" alt="$\gamma^a\gamma^b\gamma^c = \epsilon^{abcd}\gamma_5\gamma^d
+\gamma^a\delta^{bc}-\gamma^b\delta^{ac}+\gamma^c\delta^{ab}$">

</p><p>
This gives a shorter result for long traces. It is the default.
</p></td></tr>
</tbody></table>
    <br> <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081420000000000000000"></a>
<a name="substatracen"></a>
<br>
tracen
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">tracen <tt>&lt;</tt>index<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">trace4 (<a href="#substatrace">7.141</a>), chisholm (<a href="#substachisholm">7.14</a>),
    unittrace (<a href="#substaunittrace">7.147</a>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">and the chapter on gamma algebra (<a href="#gammaalgebra">14</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Takes<a name="6558"></a> the trace of the gamma<a name="6559"></a> 
matrices with the spin<a name="6560"></a> line indicated by the index. It is 
assumed that the trace is over a symbolic number of dimensions. Hence no 
special 4-dimensional tricks are used. The presence of <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$">, 
<img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img81.png" alt="$\gamma_6$"> or <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img82.png" alt="$\gamma_7$"> is not tolerated. When indices are contracted 
FORM will try to use the special symbol for the dimension<img width="24" height="28" align="MIDDLE" border="0" src="./online_files/img83.png" alt="$-4$"> if it has 
been defined in the declaration of the index (see <a href="#substaindex">7.66</a>. This 
results in relatively compact expressions. For more details on the 
algorithm used, see chapter&nbsp;<a href="#gammaalgebra">14</a> on gamma matrices. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081430000000000000000"></a>
<a name="substatransform"></a>
<br>
transform
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">transform,function(s),<tt>&lt;</tt>one or more transformations<tt>&gt;</tt>;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Statement<a name="6573"></a> to manipulation function arguments and 
fields of arguments. Allows speedy transformations without the need of 
multiple statements or repeat loops.

</p><p>
The function(s) is/are indicated as individual, comma or blank space 
separated, functions or sets of functions.

</p><p>
If there is more than one transformation, the transformations are separated 
by comma's (or blanks, unless the blank space would not induce a comma).

</p><p>
Each transformation consists of its keyword, indicating its type, followed 
by a range of arguments that is enclosed by parentheses. After that 
specific information may follow. The range<a name="6574"></a><a name="6575"></a> is as 
in
</p><pre>	(1,4)
	(3,last)
	(last-6,last-2)
</pre>
hence two indicators, separated by a comma. If the first number is bigger 
than the second the arguments will be processed in reverse order whenever 
this is relevant. In the descriptions below we will indicate the range by 
(r1,r2).

<p>
The transformations that are allowed currently are:

</p><p>
<table width="145">
<tbody><tr><td>replace<a name="10437"></a><a name="10438"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>replace(r1,r2)=(from1,to1,from2,to2,...,fromn,ton) in 
which the from-to pairs are as in the replace_ function. Here however 
there are more options than in the replace_ function as we can specify 
(small) numbers as well as in 
<br>
replace(1,last)=(0,1,1,0) which would replace arguments that are zero by 
one and arguments that are one by zero. Generic arguments are indicated by 
the new variables xarg_, iarg_, parg_ and farg_ as in 
<br>
replace(1,last)=(xarg_,2xarg_+1,p) which would replace f(2,a) by f(5,
2a+1,p) if a is a symbol and p a vector. To catch p one would need to use 
parg_.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>encode<a name="10451"></a><a name="10452"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>encode(r1,r2):base=number will interprete the arguments as 
the digits in a base 2 number system, compute the complete number and 
replace the arguments by a single argument that is that number. The number 
must fit inside a single FORM word and so must each of the original 
arguments. They should actually be smaller than the number of the base.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>decode<a name="10465"></a><a name="10466"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>decode(r1,r2):base=number will do the opposite of encode. 
It will take a single argument (the smallest of the two given) and expand 
it into digits in a number system given by the base. It will create the 
specified number of digits and replace the original number by the given 
number of arguments representing these digits. If r2 is less than r1 the 
digits will be in reverse order.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>tosumnotation<a name="10479"></a><a name="10480"></a>
<a name="10481"></a><a name="10482"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>tosumnotation(r1,r2) or implode(r1,r2) realizes an 
encoding in which zeroes are absorbed as extra values in the first nonzero 
argument that is following. This is used when dealing with harmonic sums 
and harmonic polylogarithms. An example is that (0,0,1,0,a,0,0,0,-1) (which 
is in integral notation) goes into (3,2*a,-4) (which is in sum notation). 
Currently only a single symbol is allowed and the numbers should be (small) 
integers because otherwise the reverse operation (explode) would generate 
too many arguments. Instead of ``tosumnotation'' one may also use the word 
``implode'' in accordance with the argimplode statement.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>tointegralnotation<a name="10495"></a>
<a name="10496"></a><a name="10497"></a><a name="10498"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>tointegralnotation(r1,r2) or explode(r1,r2) undoes what 
implode might have done. Hence each integer with an absolute value <img width="14" height="14" align="BOTTOM" border="0" src="./online_files/img84.png" alt="$n$"> 
generates <img width="41" height="28" align="MIDDLE" border="0" src="./online_files/img85.png" alt="$n-1$"> zeroes and leaves something with absolute value one. 
Instead of ``tointegralnotation'' one may also use the word 
``explode'' in accordance with the argexplode statement.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>permute<a name="10511"></a><a name="10512"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>permute(1,3,5)(2,6) will permute the arguments 
according to the cycles indicated. The cycles are executed in order and may 
overlap. Their number is not restricted.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>reverse<a name="10525"></a><a name="10526"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>reverse(r1,r2) reverses the order of the arguments in 
specified range.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>cycle<a name="10539"></a><a name="10540"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>cycle(r1,r2)=+/-number will perform a cyclic permutation 
of the indicated range of arguments. If the number is preceeded by a - the 
cycling is to the left. If there is a plus sign the cycling is to the 
right. Note that either the plus or the minus sign is mandatory.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>islyndon<a name="10553"></a><a name="10554"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>islyndon(r1,r2)=(yes,no) will test whether the indicated 
range of arguments forms a Lyndon word<a name="10561"></a> according to the 
ordering of arguments in FORM. The yes and no arguments are what the main 
term will be multiplied by when the range forms a Lyndon word or does not 
respectively. Because the definition of a Lyndon word is the unique minimal 
cyclic permutation of the arguments, and because often we may need the 
unique maximal cyclic permutation there are varieties: for the minimum one 
may also use islyndon<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">(r1,r2)=(yes,no) or islyndon-(r1,r2)=(yes,no), 
while for the maximum one may use islyndon<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">(r1,r2)=(yes,no) or 
islyndon+(r1,r2)=(yes,no).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="145">
<tbody><tr><td>tolyndon<a name="10568"></a><a name="10569"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>tolyndon(r1,r2)=(yes,no) will permute the given range in 
a cyclic manner till it is (if possible) a Lyndon word<a name="10576"></a> 
according to the ordering of arguments in FORM. The yes and no arguments 
are what the main term will be multiplied by when afterwards the range 
forms a Lyndon word or does not respectively. Because the definition of a 
Lyndon word is the unique minimal cyclic permutation of the arguments, and 
because often we may need the unique maximal cyclic permutation there are 
varieties: for the minimum one may also use tolyndon<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$">(r1,r2)=(yes,no) or 
tolyndon-(r1,r2)=(yes,no), while for the maximum one may use 
tolyndon<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">(r1,r2)=(yes,no) or tolyndon+(r1,r2)=(yes,no). If the output is 
not a Lyndon word, this will be due to that it is a minimum or maximum that 
is not unique.</td></tr>
</tbody></table>
    <br>

</p><p>
Some Examples. Assume that we have some Multiple Zeta Values<a name="6632"></a><a name="6633"></a> (see the papers on harmonic sums<a name="6634"></a>, harmonic polylogarithms<a name="6635"></a> and the MZV 
data mine<a name="6636"></a>) in the sum notation, but for calculational 
reasone we want to use a binary encoding (as used in the MZV programs). We 
could have

</p><p>
</p><pre>    Symbol x,x1,x2;
    CF  H,H1;
    Off Statistics;
    L   F = H(3,4,2,6,1,1,1,2);
    repeat id H(?a,x?!{0,1},?b) = H(?a,0,x-1,?b);
    Print;
    .sort

   F =
      H(0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1);

    Multiply H1;
    repeat id H(x?,?a)*H1(?b) = H(?a)*H1(?b,1-x);
    id  H1(?a)*H = H(?a);
    Print;
    .sort

   F =
      H(1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,0);

    repeat id H(x1?,x2?,?a) = H(2*x1+x2,?a);
    Print;
    .end

   F =
      H(907202);
</pre>
The new version of the same program would be
<pre>    Symbol x,x1,x2;
    CF  H,H1;
    Off Statistics;
    L   F = H(3,4,2,6,1,1,1,2);
    Transform,H,explode(1,last),
                replace(1,last)=(0,1,1,0),
                encode(1,last):base=2;
    Print;
    .end

   F =
      H(907202);
</pre>
It should be clear that this is simpler and faster. On a 64-bits computer 
it is faster by more than a factor 100.

<p>
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081440000000000000000"></a>
<a name="substatryreplace"></a>
<br>
tryreplace
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">tryreplace <code>{</code><tt>&lt;</tt>name<tt>&gt;</tt> <tt>&lt;</tt>replacement<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the replace_ function (<a href="#funreplace">8.53</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
The list<a name="6653"></a> of potential replacements should be 
similar to the arguments of the replace_<a name="6654"></a> 
function<a name="6655"></a> (see <a href="#funreplace">8.53</a>). FORM will 
make a copy of the current term, try the replacement and if the replacement 
results in a term which, by the internal ordering of FORM, comes before 
the current term, the current term is replaced by the new variety. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081450000000000000000"></a>
<a name="substaunfactorize"></a>
<br>
unfactorize
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Output control statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">unfactorize <code>{</code><tt>&lt;</tt>name of expression(s)<tt>&gt;</tt><code>}</code>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">the chapter on polynomials&nbsp;<a href="#polynomials">10</a> and the 
factorize statement&nbsp;<a href="#substafactorize">7.48</a>.</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Without arguments the statement causes all expressions that were 
factorized to be 'unfactorized'. This means that all factors are multiplied 
and the expression is replaced by this new version. Like the factorize 
statement this statement is an output control statement, which means that 
it takes effect after an expression has been processed in the current 
module (see also the factorize&nbsp;<a href="#substafactorize">7.48</a> statement).

</p><p>
Because an immediate multiplication of all factors is sometimes 
far from optimal, FORM uses a binary scheme to combine factors. After each 
step there will be a sort operation. This means that when statistics are 
printed, there may be several statistics for this step.

</p><p>
When the statement has arguments, these arguments should be names 
of expressions. In that case the unfactorization is applied only to the 
expressions that are specified.

</p><p>
If one likes to unfactorized all expressions except for a few 
ones, one can use the unfactorize statement without arguments and then 
exclude the few expressions that should not be treated with the 
nunfactorize statement (see <a href="#substanunfactorize">7.95</a>).
<br>
<br>
<br> 

</p><p>

</p><h1><a name="SECTION0081460000000000000000"></a>
<a name="substaunhide"></a>
<br>
unhide
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Specification statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">unhide;</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">unhide <tt>&lt;</tt>list of expressions<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">hide (<a href="#substahide">7.59</a>),
              nhide (<a href="#substanhide">7.88</a>),
              nunhide (<a href="#substanunhide">7.96</a>),
              pushhide (<a href="#substapushhide">7.110</a>),
              pophide (<a href="#substapophide">7.104</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
In its<a name="6686"></a> first variety this statement causes all 
statements in the hide<a name="6687"></a> file<a name="6688"></a> to become 
active<a name="6689"></a> expressions again. In its second variety only the 
specified expressions are taken from the hide system and become active 
again. An expression that is made active again can be manipulated again in 
the module in which the unhide statement occurs. For more information one 
should look at the hide statement in <a href="#substahide">7.59</a>. <br>
<br>

</p><p>
Note that if only a number of expressions is taken from the hide 
system, the hide file may be left with `holes', i.e. space between the 
remaining expressions that contain no relevant information any longer. 
FORM contains no mechanism to use the space in these holes. Hence if 
space is at a premium and many holes develop one should unhide all 
expressions (this causes the hide system to be started from zero size 
again) and then send the relevant expressions back to the hide system. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081470000000000000000"></a>
<a name="substaunittrace"></a>
<br>
unittrace
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">u[nittrace] <tt>&lt;</tt>value<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">trace4 (<a href="#substatrace">7.141</a>), tracen (<a href="#substatracen">7.142</a>),
    chisholm (<a href="#substachisholm">7.14</a>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">and the chapter on gamma algebra (<a href="#gammaalgebra">14</a>).</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Sets<a name="6706"></a> the value of the trace of the 
unit<a name="6707"></a> matrix<a name="6708"></a> in the Dirac<a name="6709"></a> 
algebra<a name="6710"></a> (i.e. the object <code>g1_(n)</code> for trace line 
<code>n</code>)). The parameter <code>value</code> can be either a short positive 
number or any symbol with the exception of <code>i_</code>. See also 
chapter&nbsp;<a href="#gammaalgebra">14</a>. <br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081480000000000000000"></a>
<a name="substavectors"></a>
<br>
vectors
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">v[ectors] <tt>&lt;</tt>list of vectors to be declared<tt>&gt;</tt>;</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
Used for the declaration of vectors<a name="6721"></a>. Example:
</p><pre>   Vectors p,q,q1,q2,q3;
</pre>
<br>
<br>
<br>

<p>

</p><h1><a name="SECTION0081490000000000000000"></a>
<a name="substawhile"></a>
<br>
while
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Executable statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">while ( condition );</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">endwhile (<a href="#substaendwhile">7.43</a>), repeat (<a href="#substarepeat">7.116</a>),
            if (<a href="#substaif">7.63</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="6734"></a> starts the while 
environment<a name="6735"></a>. It should be paired with an 
endwhile<a name="6736"></a> statement (see <a href="#substaendwhile">7.43</a>) which 
terminates the while environment. The statements between the while and the 
endwhile statements will be executed as long as the condition is met. For 
the description of the condition one should consult the if<a name="6738"></a> 
statement (see <a href="#substaif">7.63</a>). The while/endwhile combination is 
equivalent to the construction
</p><pre>   repeat;
      if ( condition );


      endif;
   endrepeat;
</pre>
If only a single statement is inside the environment one can also use
<pre>   while ( condition ) statement;
</pre>
Of course one should try to avoid infinite<a name="6744"></a> 
loops<a name="6745"></a>. In order to maximize the speed of FORM not 
all internal stacks are protected and hence the result may be that FORM 
may crash. It is also possible that FORM may detect a shortage of buffer 
space and quit with an error message. <br>
<br>

<p>
For each term for which execution reaches the endwhile statement, 
control is brought back to the while statement. For each term that reaches 
the while statement the condition is checked and if it is met, the 
statements inside the environment are executed again on this term. If the 
condition is not met, execution continues after the endwhile statement. 
<br>
<br>
<br>

</p><p>

</p><h1><a name="SECTION0081500000000000000000"></a>
<a name="substawrite"></a>
<br>
write
</h1>

<p>
<table cellpadding="3">
<tbody><tr><td align="LEFT">Type</td>
<td align="LEFT">Declaration statement</td>
</tr>
<tr><td align="LEFT">Syntax</td>
<td align="LEFT">w[rite] <tt>&lt;</tt>keyword<tt>&gt;</tt>;</td>
</tr>
<tr><td align="LEFT">See also</td>
<td align="LEFT">on (<a href="#substaon">7.99</a>), off (<a href="#substaoff">7.98</a>)</td>
</tr>
</tbody></table> <br>
<br>

</p><p>
This statement<a name="6761"></a> is considered 
obsolete<a name="6762"></a>. All its varieties have been taken over by the 
on<a name="6763"></a> statement (see <a href="#substaon">7.99</a>) and the off<a name="6765"></a> 
statement (see <a href="#substaoff">7.98</a>). The current version of FORM will still 
recognize it, but the user is advised to avoid its usage. In future 
versions of FORM it is scheduled to be used for a different kind of 
writing and hence its syntax may change considerably. The conversion 
program conv2to3 should help in the conversion of programs written for 
version 2. For completeness we still give the syntax and how it should be 
converted. The keywords are: <br>
<br>

</p><p>
<table width="159">
<tbody><tr><td>allnames<a name="10591"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On allnames;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>allwarnings<a name="10604"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On allwarnings;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>highfirst<a name="10617"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On highfirst;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>lowfirst<a name="10630"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On lowfirst;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>names<a name="10643"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On names;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>powerfirst<a name="10656"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On powerfirst;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>setup<a name="10669"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On setup;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstatistics<a name="10682"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On shortstatistics;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>shortstats<a name="10695"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On shortstats;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>statistics<a name="10708"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On statistics;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>stats<a name="10721"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On stats;</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="159">
<tbody><tr><td>warnings<a name="10734"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>Same as: On warnings;</td></tr>
</tbody></table>
    <br>

</p><p>
<br>
<br>
<br>

</p><p>

</p><p>

</p><h1><a name="SECTION00900000000000000000"></a>
<a name="functions"></a>
<br>
Functions
</h1>

<p>
Functions<a name="13645"></a> are objects that can have arguments. 
There exist several types of functions in FORM. First there is the 
distinction between commuting<a name="13646"></a> and 
noncommuting<a name="13647"></a> functions. Commuting functions commute 
with all other objects. This property is used by the normalization routines 
that bring terms into standard form. Noncommuting functions do not commute 
necessarily with other noncommuting functions. They do however commute with 
objects that are considered to be commuting, like symbols, vectors and 
commuting functions. Various instances of the same noncommuting function 
but with different arguments do not commute either.

</p><p>
The next subdivision of the category of functions is in regular 
functions<a name="13648"></a>, tensors<a name="13649"></a> and 
tables<a name="13650"></a>. Tensors are special functions that can have only 
indices or vectors for their arguments. If an argument is a vector, it is 
assumed that this vector is there as the result of an index contraction. 
Tables are functions with automatic substitution rules. A table must have 
at least one table<a name="13651"></a> index<a name="13652"></a>. Each time 
during normalization FORM will check whether an instance of a table can be 
substituted. This means that undefined table elements will slow the program 
down somewhat.

</p><p>
All the various types of functions are declared with their own 
declaration statements. These are described in the chapter for the 
statements (see chapter&nbsp;<a href="#statements">7</a>).

</p><p>
One of the useful properties of functions is the 
wildcarding<a name="13654"></a> of their arguments during pattern matching. The 
following argument wildcards are possible:

</p><p>
<table width="91">
<tbody><tr><td>x?
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Here x is a symbol. This symbol can match either a 
symbol, any numerical argument, or a complete subexpression argument that 
is not vectorlike or indexlike.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td>i?
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Here i is an index. This index can match either an index, 
a vector (actually the dummy<a name="14211"></a> index<a name="14212"></a> of the 
vector that was contracted), or a complete subexpression that is vector like 
(again actually the contracted dummy index).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td>v?
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Here v is a vector. This vector can match either a vector 
or a complete subexpression that is vector like.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td>f?
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>Here f is any functiontype. This function can match any 
function. It is the responsibility of the user to avoid problems in the 
right-hand side if f happens to match a tensor.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="91">
<tbody><tr><td>?a
</td></tr>
</tbody></table>
<br>
<table width="635">
<tbody><tr><td>This is an argument<a name="14249"></a> field 
wildcard<a name="14250"></a>. This can match a 
complete set of arguments. The set can be empty. Argument field wildcards 
have a name that starts with a question mark followed by a name. They do 
not have to be declared as there cannot be confusion.</td></tr>
</tbody></table>
    <br>

</p><p>
In addition to the above syntax FORM knows a number of special 
functions with well defined properties. All these functions have a name 
that ends in an underscore. In addition the names of these built in objects 
are case insensitive. This means for instance that the factorial function 
can be referred to as <code>fac_</code>, <code>Fac_</code> or <code>FAC_</code> or whatever 
the user considers more readable. The built in functions are:

</p><p>

</p><h1><a name="SECTION00910000000000000000"></a><a name="13678"></a><a name="13679"></a>
<a name="funabs"></a>
<br>
abs_
</h1>
With one argument that is numerical it evaluates into the 
absolute value of the argument.

<p>

</p><h1><a name="SECTION00920000000000000000"></a><a name="13682"></a><a name="13683"></a>
<a name="funbernoulli"></a>
<br>
bernoulli_
</h1>
If it has one nonzero integer argument n, it evaluates into 
the n-th coefficient in the power series expansion of <img width="86" height="33" align="MIDDLE" border="0" src="./online_files/img86.png" alt="$x/(1-e^{-x})$">.

<p>

</p><h1><a name="SECTION00930000000000000000"></a><a name="13687"></a><a name="13688"></a>
<a name="funbinom"></a>
<br>
binom_
</h1>
binom_(n,i) <!-- MATH
 $= n!/(i!(n-i)!)$
 -->
<img width="116" height="31" align="MIDDLE" border="0" src="./online_files/img87.png" alt="$= n!/(i!(n-i)!)$">. If the arguments are non 
integer or negative, no substitution is made.

<p>

</p><h1><a name="SECTION00940000000000000000"></a><a name="13691"></a><a name="13692"></a>
<a name="funconjg"></a>
<br>
conjg_
</h1>
Currently not doing anything.

<p>

</p><h1><a name="SECTION00950000000000000000"></a><a name="13695"></a><a name="13696"></a>
<a name="funcontent"></a>
<br>
content_
</h1>
This function expects the name of a single expression or a dollar 
variable for its 
argument. If it finds this the content of this expression or dollar 
variable is returned. The 
content is defined as a term that has

<ul>
<li>for its numerator the GCD of the numerators of all terms in the 
expression.
</li>
<li>for its denominator the LCM of the denominators of all terms in the 
expression.
</li>
<li>all the common subexpressions in all terms of the expression.
</li>
<li>the most negative powers of all symbols and dotproducts with negative 
powers in the terms of the expression.
</li>
</ul>
When there are no negative powers and no denominators in the coefficients, 
this definition of the content coïncides with the classical definition 
of the content of a polynomial over the integers. Our content has the 
property that if we divide the expression by it, we are left with an 
expression of which the coefficients are all integer, there are no negative 
powers and the GCD of all terms combined is one.

<p>
This function has one limitation. It will not consider 
noncommuting objects. Neither will it consider denominator functions.

</p><p>
Caveat: this function is evaluated each time it is encountered. 
Therefore the best thing is to evaluate it once in the definition of a 
dollar variable or an expression as in
</p><pre>   #$x = content_(F);
   Local G = (a+b)^10*$x;
</pre>
Here the content is computed only once. In
<pre>   Local G = (a+b)^10*content_(F);
</pre>
11 terms are generated and the content is only worked out when the 
terms are normalized. This means that it will be evaluated 11 times. If one 
does not like dollar variables and still wants to evaluate the content only 
once the code would be
<pre>   Local G = ab^10*content_(F);
   id ab = a+b;
</pre>
because now the term will be normalized before the substitution makes it 
into eleven terms. This assumes of course that the content does not contain 
the variable ab.

<p>

</p><h1><a name="SECTION00960000000000000000"></a><a name="13708"></a><a name="13709"></a>
<a name="funcount"></a>
<br>
count_
</h1>
Similar to the count object in the if statement (see 
<a href="#substaif">7.63</a>). This function expects the same arguments as the count 
object and returns the corresponding count value for the current term.

<p>

</p><h1><a name="SECTION00970000000000000000"></a><a name="13713"></a><a name="13714"></a>
<a name="fund"></a>
<br>
d_
</h1>
The kronecker<a name="13716"></a> delta<a name="13717"></a>. 
Should have two indices for arguments. Often indicated as 
<!-- MATH
 $\delta^{\mu\nu}$
 -->
<img width="27" height="14" align="BOTTOM" border="0" src="./online_files/img88.png" alt="$\delta^{\mu\nu}$">. In automatic summation over the indices the d_ often 
vanishes again as in
<code>d_(mu,nu)*p(mu)*q(nu)</code> <img width="20" height="13" align="BOTTOM" border="0" src="./online_files/img89.png" alt="$\rightarrow$"> <code>p.q</code> and similar 
replacements. Internally this object is treated in a rather special way. 
Hence it will not match a function wildcard.

<p>

</p><h1><a name="SECTION00980000000000000000"></a><a name="13720"></a><a name="13721"></a>
<a name="fundd"></a>
<br>
dd_
</h1>
This is a combinatorics<a name="13723"></a> function. The tensor 
dd_ with an even number of indices is equal to the totally symmetric 
tensor built up from products of kronecker delta's. Each term in this 
symmetric combination is normalized to one. In principle there are 
<!-- MATH
 $n!/(2^{n/2}(n/2)!$
 -->
<img width="104" height="36" align="MIDDLE" border="0" src="./online_files/img90.png" alt="$n!/(2^{n/2}(n/2)!$"> terms in this combination. The profit comes when some 
or all the indices are contracted with vectors and some of these vectors 
are identical. In that case FORM will use combinatorics to generate only 
different terms, each with the proper prefactor. This can result in great 
time and space savings.

<p>

</p><h1><a name="SECTION00990000000000000000"></a><a name="13726"></a><a name="13727"></a>
<a name="fundelta"></a>
<br>
delta_
</h1>
With one numerical argument the result is one if 
the argument is zero and zero otherwise. With two arguments the result is 
one if the arguments are numerical and identical. If they are numerical and 
they differ the result is zero. In all other cases nothing is done.

<p>

</p><h1><a name="SECTION009100000000000000000"></a><a name="13730"></a><a name="13731"></a>
<a name="fundeltap"></a>
<br>
deltap_
</h1>
If one argument and it is numerical the result is zero if 
the argument is zero and one otherwise. If two arguments, the result is 
zero if the arguments are numerical and identical. If they are numerical and 
they differ the result is one. In all other cases nothing is done.

<p>

</p><h1><a name="SECTION009110000000000000000"></a><a name="13734"></a><a name="13735"></a>
<a name="fundenom"></a>
<br>
denom_
</h1>
Internal function to describe denominators. Has a single 
argument. <code>den(a+b)</code> is printed as <code>1/(a+b)</code>.

<p>

</p><h1><a name="SECTION009120000000000000000"></a><a name="13738"></a><a name="13739"></a>
<a name="fundistrib"></a>
<br>
distrib_
</h1>
This is a combinatorics<a name="13741"></a> function. It should 
have at least five arguments. If we have
<pre>    distrib_(type,n,f1,f2,x1,...,xm)
</pre>
with type and n integers, f1 and f2 functions and then a number of 
arguments there can be action if <img width="41" height="28" align="MIDDLE" border="0" src="./online_files/img91.png" alt="$-2 \le$"> type <img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img92.png" alt="$\le 2$">. The typical action 
is that the arguments <code>x1,...,xm</code> will be divided over the two 
functions in all possible ways. For each possibility a new term is 
generated. The relative order of the arguments is kept. If type is negative 
it is assumed that the collection of x-arguments is 
antisymmetric<a name="13744"></a> and hence the number of permutations 
needed to make the split will determine whether there will be a minus sign 
on the resulting term. When type is zero all possible divisions are 
generated. Hence there will be <img width="24" height="14" align="BOTTOM" border="0" src="./online_files/img93.png" alt="$2^m$"> divisions. The second argument is then 
not relevant. If type is 1 or -1 the second parameter says that the first 
function should obtain n arguments. The remaining arguments go to the 
second function. If type is 2 or -2 the second function should obtain n 
arguments. Example:
<pre>    Symbols x1,...,x4;
    CFunctions f,f1,f2;
    Local F = f(x1,...,x4);
    id  f(?a) = distrib_(-1,2,f1,f2,?a);
    Print +s;
    .end

   F =
       + f1(x1,x2)*f2(x3,x4)
       - f1(x1,x3)*f2(x2,x4)
       + f1(x1,x4)*f2(x2,x3)
       + f1(x2,x3)*f2(x1,x4)
       - f1(x2,x4)*f2(x1,x3)
       + f1(x3,x4)*f2(x1,x2)
      ;
</pre>
When adjacent x-arguments are identical FORM uses combinatorics to avoid 
generating more terms than necessary.

<p>

</p><h1><a name="SECTION009130000000000000000"></a><a name="13748"></a><a name="13749"></a>
<a name="fundiv"></a>
<br>
div_
</h1>
<code>div_(x1,x2)</code> is replaced by the quotient of the arguments. 
The arguments can be any valid subexpressions, provided the whole function 
fits inside a term. When an argument is only an active expression or a 
$-expression it is only expanded during the division. This way the 
contents of such expressions can exceed the maximum term size. One should 
however realize that in that case the operation takes place in allocated 
memory. This function replaces the experimental function 
polydiv_<a name="13751"></a><a name="13752"></a> that existed in 
version 3.

<p>

</p><h1><a name="SECTION009140000000000000000"></a><a name="13754"></a><a name="13755"></a>
<a name="fundum"></a>
<br>
dum_
</h1>
Special function for printing virtual<a name="13757"></a> 
brackets<a name="13758"></a>. <code>dum_(a+b)</code> is printed as <code>(a+b)</code>: the 
name of this function is not printed!

<p>

</p><h1><a name="SECTION009150000000000000000"></a><a name="13760"></a><a name="13761"></a>
<a name="fundummy"></a>
<br>
dummy_
</h1>
For internal use only.

<p>

</p><h1><a name="SECTION009160000000000000000"></a><a name="13764"></a><a name="13765"></a>
<a name="fundummyten"></a>
<br>
dummyten_
</h1>
For internal use only.

<p>

</p><h1><a name="SECTION009170000000000000000"></a><a name="13768"></a><a name="13769"></a>
<a name="fune"></a>
<br>
e_
</h1>
The Levi-Civita<a name="13771"></a> 
tensor<a name="13772"></a>. It is a totally 
antisymmetric<a name="13773"></a> tensor with well defined contraction 
rules (see <a href="#substacontract">7.20</a>).

<p>

</p><h1><a name="SECTION009180000000000000000"></a><a name="13776"></a><a name="13777"></a>
<a name="funexp"></a>
<br>
exp_
</h1>
Internal function with two arguments. Represents 
argument1 to the power argument2. Of course it is printed in the standard 
power notation.

<p>

</p><h1><a name="SECTION009190000000000000000"></a><a name="13780"></a><a name="13781"></a>
<a name="funexteuclidean"></a>
<br>
exteuclidean_
</h1>

<p>
This is a number function. It expects two positive integer 
arguments. It then computes the Greatest Common Divider of these arguments 
with the use of the extended Euclidean algoritm. The answer will be in the 
same function but now there will be four arguments as in:
</p><pre>    Symbols x1,x2,x3,x4;
    Local F = exteuclidean_(54,84);
    Print;
    .sort

   F =
      exteuclidean_(54,84,-3,2);

    id exteuclidean_(x1?,x2?,x3?,x4?) = x1*x3+x2*x4;
    Print;
    .end

   F =
      6;
</pre>
We can see that we obtain the GCD with the relation that is 
characteristic for the extended Euclidean algorithm. When the two arguments 
are relative prime, one obtains the so-called modinverses of these numbers:
<pre>    Symbols x1,x2,x3,x4,a,b;
    Local F = exteuclidean_(97,101);
    Print;
    .sort

   F =
      exteuclidean_(97,101,25,-24);

    id exteuclidean_(x1?,x2?,x3?,x4?) = x1*x3+x2*x4
        +a*mod2_(1/97,101)+b*mod2_(1/101,97);
    Print;
    .end

   F =
      1 - 24*b + 25*a;
</pre>
Here 25 is the inverse of 97 when we calculate modulus 101 and 
-24 is the inverse of 101 when we calculate modulus 97.

<p>
This function can be very handy when a calculation has been done 
modulus various prime numbers and one would like to know the result modulus 
the product of these numbers. This combination is done with the aid of the 
Chinese remainder theorem<a name="13787"></a>:
</p><pre>   #procedure ChineseRemainder(NAME,NAME1,NAME2,M1,M2,PAR)
   *
   *   Assumes that NAME1 is an expression mod $M1
   *   Assumes that NAME2 is an expression mod $M2
   *   Creates $ch1r and $ch2r with the property that
   *   the expression NAME = NAME1*$ch1r+NAME2*$ch2rn
   *   is the corresponding equation mod $M1*$M2
   *
   Modulus 0; * we need to switch off previous settings.
   #$ch1r = exteuclidean_($`M1',$`M2');
   #inside $ch1r;
       id exteuclidean_(xxx1?,xxx2?,xxx3?,xxx4?) = xxx2*xxx4;
   #endinside;
   #$ch2r = exteuclidean_($`M1',$`M2');
   #inside $ch2r;
       id exteuclidean_(xxx1?,xxx2?,xxx3?,xxx4?) = xxx1*xxx3;
   #endinside;
   #$MM12 = $`M1'*$`M2';
   Modulus,plusmin,`$MM12';
   Local `NAME' = `NAME1i'*$ch1r+`NAME2i'*$ch2r;
   .sort
   *
   #endprocedure
</pre>

<p>

</p><h1><a name="SECTION009200000000000000000"></a><a name="13791"></a><a name="13792"></a>
<a name="funextrasymbol"></a>
<br>
extrasymbol_
</h1>

<p>
This function expects a single argument. This argument can be a 
number or an extra symbol(see <a href="#extrasymbols">2.11</a>). In either case the 
function is replaced by the expression that the corresponding extra symbol 
stands for.

</p><p>
If there are more arguments or the argument does not represent a 
legal extra symbol, no substitution is made.

</p><p>

</p><h1><a name="SECTION009210000000000000000"></a><a name="13796"></a><a name="13797"></a>
<a name="funfac"></a>
<br>
fac_
</h1>
The factorial<a name="13799"></a> function. If it has a single nonzero 
integer argument n it is replaced by n! but if the result is bigger than 
the maximum allowable number an error will result.

<p>

</p><h1><a name="SECTION009220000000000000000"></a><a name="13801"></a><a name="13802"></a>
<a name="funfactorin"></a>
<br>
factorin_
</h1>
When the argument is a single $-variable<a name="13804"></a> or 
an expression<a name="13805"></a> the function is replaced by the common 
factor in the terms of that <code>$</code>-variable or expression. This common 
factor consists in the first place of all symbolic objects that occur in 
all terms. In addition the numerical factor consists of the GCD<a name="13806"></a> 
of all numerators and the LCM<a name="13807"></a> of all denominators. Hence if the 
<code>$</code>-variable or expression is divided by the result of factorin_ all 
coefficients become integer.

<p>

</p><h1><a name="SECTION009230000000000000000"></a><a name="13809"></a><a name="13810"></a>
<a name="funfarg"></a>
<br>
farg_
</h1>
For internal use only.

<p>

</p><h1><a name="SECTION009240000000000000000"></a><a name="13813"></a><a name="13814"></a>
<a name="funfirstbracket"></a>
<br>
firstbracket_
</h1>
In the case that there is a single argument and this 
single argument is the name of an expression, this function is replaced by 
the part that is outside brackets in the first term of the expression. If 
there are no brackets the function is replaced by one.

<p>

</p><h1><a name="SECTION009250000000000000000"></a><a name="13817"></a><a name="13818"></a>
<a name="funfirstterm"></a>
<br>
firstterm_
</h1>

<p>
This function expects the name of an expression or a dollar 
variable for its (single) argument. It will return the first term in this 
expression or dollar variable. When it has to obtain the first term of an 
expression, FORM uses the expression in the representation in which it was 
stored at the end of the previous module. If the expression did not exist 
in the previous module, it will attempt to use the expression as defined 
and processed in the current expression. If the expression has only been 
defined in the current module and has not yet been processed (as is the 
case when referring to the first term in the current expression) the answer 
will be unspecified. This use is considered illegal, even though it does 
not generate an error message.

</p><p>

</p><h1><a name="SECTION009260000000000000000"></a><a name="13821"></a><a name="13822"></a>
<a name="fungfive"></a>
<br>
g5_
</h1>
The <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> Dirac gamma matrix. We assume here that it 
anticommutes with the other Dirac<a name="13824"></a> gamma<a name="13825"></a> 
matrices. Anybody who does not like that should program private libraries 
(this should not be too difficult with the cycle symmetric functions 
(see <a href="#substafunctions">7.54</a>)). There should be a single index to indicate 
the spinline.

<p>

</p><h1><a name="SECTION009270000000000000000"></a><a name="13828"></a><a name="13829"></a>
<a name="fungsix"></a>
<br>
g6_
</h1>
There should be a single index to indicate the spinline. 
As in Schoonschip<a name="13831"></a> we use <!-- MATH
 $\gamma_6 = 1+\gamma_5$
 -->
<img width="84" height="28" align="MIDDLE" border="0" src="./online_files/img46.png" alt="$\gamma_6 = 1+\gamma_5$">.

<p>

</p><h1><a name="SECTION009280000000000000000"></a><a name="13833"></a><a name="13834"></a>
<a name="fungseven"></a>
<br>
g7_
</h1>
There should be a single index to indicate the spinline. 
As in Schoonschip<a name="13836"></a> we use <!-- MATH
 $\gamma_7 = 1-\gamma_5$
 -->
<img width="84" height="28" align="MIDDLE" border="0" src="./online_files/img47.png" alt="$\gamma_7 = 1-\gamma_5$">.

<p>

</p><h1><a name="SECTION009290000000000000000"></a><a name="13838"></a><a name="13839"></a>
<a name="fung"></a>
<br>
g_
</h1>
The Dirac<a name="13841"></a> gamma<a name="13842"></a> matrix. Its 
first argument should be an index (either symbolic or numeric). Then follow 
zero, one or more indices to indicate a string of gamma matrices that 
belong together. Gamma matrices with the same first index are considered to 
belong together, but as long as the indices are symbolic no assumptions are 
made about whether they go together or not. Hence no commutation or 
anticommutation properties are applied for different spin lines unless the 
spinline indices are both numeric.

<p>

</p><h1><a name="SECTION009300000000000000000"></a><a name="13844"></a><a name="13845"></a>
<a name="fungcd"></a>
<br>
gcd_
</h1>
<code>gcd_(x1,...,xn)</code> is replaced by the greatest common divisor 
of the arguments. The arguments can be any valid subexpressions, provided 
the whole function fits inside a term. When an argument is only an active 
expression or a $-expression it is only expanded during evaluation of the 
GCD. This way the contents of such expressions can exceed the maximum term 
size. One should however realize that in that case the operation takes 
place in allocated memory.
This function replaces the experimental function 
polygcd_<a name="13847"></a><a name="13848"></a> that existed in 
version 3.

<p>

</p><h1><a name="SECTION009310000000000000000"></a><a name="13850"></a><a name="13851"></a>
<a name="fungi"></a>
<br>
gi_
</h1>
The unit Dirac gamma matrix. Should have a single index 
to indicate its spin line. Its is identical to a regular gamma matrix with 
no Lorenz indices: <code>gi_(n) = g_(n)</code>

<p>

</p><h1><a name="SECTION009320000000000000000"></a><a name="13854"></a><a name="13855"></a>
<a name="funid"></a>
<br>
id_
</h1>
This function is a crossbreed between the 
replace_<a name="13857"></a><a href="#funreplace">8.53</a> function and the id 
statement<a name="13859"></a><a href="#substaidentify">7.60</a>. To become active it 
needs an even number of arguments. The odd numbered arguments can be 
anything of the types:
<dl>
<dt></dt>
<dd>a single symbol, possibly to an integer power.
</dd>
<dt></dt>
<dd>a single dotproducts, possibly to an integer power.
</dd>
<dt></dt>
<dd>a single function, possibly with any number and type of arguments.
</dd>
</dl>
When FORMencounters an id_ function the last step of normalizing a term 
is to replace the id function by a number substitutions in which the odd 
arguments are replaced by the following even arguments. These are not 
wildcard substitutions as in the replace_ function, but substitutions as 
in regular id statements. The matching of the odd arguemnts is done in a 
single step as in an id-al construction<a href="#substaalso">7.2</a>. Hence
<pre>    id_(x^2,y+z,y,u+v,x,z+u)
</pre>
effectively becomes
<pre>    id x^2 = y+z;
    al y = u+v;
    al x = z+u;
</pre>
FORMtreats multiple occurrences of the id_ function one at a time. It 
takes the leftmost occurrence first, takes the patterns from the term, 
expands the right hand sides, tries to normalize the resulting terms and 
only then continues with the next id_ function. For this reason the id_ 
function is noncommuting.

<p>

</p><h1><a name="SECTION009330000000000000000"></a><a name="13869"></a><a name="13870"></a>
<a name="funinteger"></a>
<br>
integer_
</h1>
This is a rounding<a name="13872"></a> function. It should have 
either one or two arguments. If there is a single argument and it is 
numeric, it will be rounded down to become an integer. If there are two 
arguments of which the first is numeric and the second is either 1, 0 or 
-1, the result will be the rounded value of the first argument. If the 
second argument is 1, the rounding will be down, when it is -1, the 
rounding will be up and when it is zero the rounding will be towards zero. 
In all other cases nothing is done.

<p>

</p><h1><a name="SECTION009340000000000000000"></a><a name="13874"></a><a name="13875"></a>
<a name="funinverse"></a>
<br>
inverse_
</h1>
<code>inverse_(x1,x2)</code> expects two arguments which are 
polynomials in the same single variable. The return expression <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img94.png" alt="$x_3$"> 
has the property that <img width="37" height="28" align="MIDDLE" border="0" src="./online_files/img95.png" alt="$x_1 x_3$"> divided by <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img96.png" alt="$x_2$"> has remainder 1. Or in 
other words: <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img94.png" alt="$x_3$"> is the inverse of <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img97.png" alt="$x_1$"> modulus <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img96.png" alt="$x_2$">.
The arguments can be any valid subexpressions, provided the whole function 
fits inside a term. When an argument is an active expression or a 
$-expression it is only expanded during the division. This way the 
contents of such expressions can exceed the maximum term size. One should 
however realize that in that case the operation takes place in allocated 
memory. 

<p>

</p><h1><a name="SECTION009350000000000000000"></a><a name="13878"></a><a name="13879"></a>
<a name="funinvfac"></a>
<br>
invfac_
</h1>
One divided by the factorial<a name="13881"></a> function. If it has 
a single nonzero integer argument n, it is replaced by 1/n!, but if this 
results in a number bigger than the maximum allowable number an error will 
result.

<p>

</p><h1><a name="SECTION009360000000000000000"></a><a name="13883"></a><a name="13884"></a>
<a name="funmakerational"></a>
<br>
makerational_
</h1>

<p>
This function takes two arguments. Both are integers. We assume 
calculus modulus the second argument. The function is then replaced by a 
fraction of which both elements are less than the square root of the second 
argument and that, in calculus modulus this second number would give the 
same result as the first number modulus the second number. Example:
</p><pre>    #$m = prime_(1);
    #write &lt;&gt; "The prime number is %$",$m
The prime number is 2147483587
    L	F = MakeRational_(12345678,$m);
    Print;
    .sort

   F =
      9719/38790;

    Modulus `$m';
    Print;
    .end

   F =
      12345678;
</pre>
This function can be used to reconstruct fractions when calculus 
has been done modulus one or more prime numbers.

<p>

</p><h1><a name="SECTION009370000000000000000"></a><a name="13889"></a><a name="13890"></a>
<a name="funmatch"></a>
<br>
match_
</h1>
Currently not active. Replaced automatically by 1.

<p>

</p><h1><a name="SECTION009380000000000000000"></a><a name="13893"></a><a name="13894"></a>
<a name="funmax"></a>
<br>
max_
</h1>
If all its arguments are numeric, this function returns 
the maximum value of these arguments.

<p>

</p><h1><a name="SECTION009390000000000000000"></a><a name="13897"></a><a name="13898"></a>
<a name="funmaxpowerof"></a>
<br>
maxpowerof_
</h1>
If this function has a single argument that is a symbol, it 
returns the maximum power restriction of this symbol. If none was given it 
will be the installation dependent value MAXPOWER which is 10000 on 
32<a name="13900"></a> bit machines and 500000000 on 64<a name="13901"></a> bit 
machines.

<p>

</p><h1><a name="SECTION009400000000000000000"></a><a name="13903"></a><a name="13904"></a>
<a name="funmin"></a>
<br>
min_
</h1>
If all its arguments are numeric, this function returns 
the minimum value of these arguments.

<p>

</p><h1><a name="SECTION009410000000000000000"></a><a name="13907"></a><a name="13908"></a>
<a name="funminpowerof"></a>
<br>
minpowerof_
</h1>
If this function has a single argument that is a symbol, it 
returns the minimum power restriction of this symbol. If none was given it 
will be the installation dependent value -MAXPOWER which is -10000 on 32 bit 
machines.

<p>

</p><h1><a name="SECTION009420000000000000000"></a><a name="13911"></a><a name="13912"></a>
<a name="funmod"></a>
<br>
mod_
</h1>
If there are two integer arguments and the second 
argument is a positive short integer (less than <img width="26" height="16" align="BOTTOM" border="0" src="./online_files/img51.png" alt="$2^{15}$"> on 32 bit 
computers and less than <img width="26" height="16" align="BOTTOM" border="0" src="./online_files/img52.png" alt="$2^{31}$"> on 64 bit computers) the return value is 
the first argument modulus the second. Note that if the second argument is 
not a prime number and the first argument contains a denominator, division 
by zero could occur. It is up to the user to avoid such cases. See also the 
mod2_ function&nbsp;<a href="#funmod2">8.43</a> and the rem_ function&nbsp;<a href="#funrem">8.52</a>.

<p>
The function has one peculiarity: when the second argument is one, the 
function is left untouched.

</p><p>

</p><h1><a name="SECTION009430000000000000000"></a><a name="13919"></a><a name="13920"></a>
<a name="funmod2"></a>
<br>
mod2_
</h1>
This gives basically the same action as the mod_ function (see 
<a href="#funmod">8.42</a>), but the answer will be in the range <img width="89" height="31" align="MIDDLE" border="0" src="./online_files/img98.png" alt="$-[(p-1)/2]$"> to 
<img width="89" height="31" align="MIDDLE" border="0" src="./online_files/img99.png" alt="$+[(p+1)/2]$">.

<p>

</p><h1><a name="SECTION009440000000000000000"></a><a name="13924"></a><a name="13925"></a>
<a name="funnargs"></a>
<br>
nargs_
</h1>
Is replaced by an integer indicating the number of 
arguments that the function has.

<p>

</p><h1><a name="SECTION009450000000000000000"></a><a name="13928"></a><a name="13929"></a>
<a name="funnterms"></a>
<br>
nterms_
</h1>
If this function has only one argument it is replaced by 
the number of terms inside this argument.

<p>

</p><h1><a name="SECTION009460000000000000000"></a><a name="13932"></a><a name="13933"></a>
<a name="funnumfactors"></a>
<br>
numfactors_
</h1>

<p>
This function returns the number of factors in a factorized 
expression (see the chapter on polynomials&nbsp;<a href="#polynomials">10</a>) or dollar 
variable&nbsp;<a href="#dollars">6</a>. It expects a single argument which should be the 
name of an expression or a dollar variable. If the expression or dollar 
variable has not been factorized, the function returns zero.

</p><p>

</p><h1><a name="SECTION009470000000000000000"></a><a name="13938"></a><a name="13939"></a>
<a name="funpattern"></a>
<br>
pattern_
</h1>
Currently not active. Replaced automatically by 1.

<p>

</p><h1><a name="SECTION009480000000000000000"></a><a name="13942"></a><a name="13943"></a>
<a name="funpoly"></a>
<br>
poly_
</h1>
This was an experimental function in version 3. It was for 
internal use with a whole category of other experimental functions of which 
the functionality has been replaced by better working functions that are 
more general. This category included the functions 
polyadd_<a name="13945"></a><a name="13946"></a>,
polydiv_<a name="13947"></a><a name="13948"></a>,
polygcd_<a name="13949"></a><a name="13950"></a>,
polyintfac_<a name="13951"></a><a name="13952"></a>,
polymul_<a name="13953"></a><a name="13954"></a>,
polynorm_<a name="13955"></a><a name="13956"></a>,
polyrem_<a name="13957"></a><a name="13958"></a> and
polysub_<a name="13959"></a><a name="13960"></a>.
See also the chapter on polynomials<a href="#polynomials">10</a> and the functions 
gcd_<a href="#fungcd">8.30</a>, div_<a href="#fundiv">8.13</a> and rem_<a href="#funrem">8.52</a>.

<p>

</p><h1><a name="SECTION009490000000000000000"></a><a name="13966"></a><a name="13967"></a>
<a name="funprime"></a>
<br>
prime_
</h1>

<p>
For a number of internal operations FORM needs prime numbers that 
are neither very large nor very small. Hence it generates, when needed 
prime numbers that still fit inside a single FORM word, but are maximal 
within that limitation. Hence for a 64-bits computer in which the largest 
positive `small' integer in FORM is <img width="53" height="33" align="MIDDLE" border="0" src="./online_files/img18.png" alt="$2^{31}-1$">, it works its way down from 
there. Once it has determined that a number is prime it stores it in a 
list. The function prime_ gives access to this list. The single argument 
n (n a positive integer) makes that <code>prime_(n)</code> will be replaced by 
the n-th member of the list. There is a limitation to the size of the list 
which is implementation dependent. The number will anyway never be smaller 
than the maximum power that is allowed for symbols. Example:
</p><pre>    Symbols x1,x2,x3,x4;
    ON highfirst;
    Local F = x1*prime_(1)+x2*prime_(2)
             +x3*prime_(3)+x4*prime_(4);
    Print;
    .end

   F =
      2147483587*x1 + 2147483579*x2 + 2147483563*x3 + 2147483549*x4;
</pre>
This function is useful when calculations generate very large intermediate 
coefficients, but in the end the answer is relatively simple again. In that 
case one can do the calculation modulus one or more prime numbers. If more 
prime numbers are used the Chinese remainder theorem<a name="13972"></a>. can be used (see the exteuclidean_ 
function&nbsp;<a href="#funexteuclidean">8.19</a> to combine the results and the 
makerational_ function&nbsp;<a href="#funmakerational">8.36</a> can be used if fractions have 
to be reconstructed. An example of this kind of use is given in the simple 
Groebner basis procedure that is in the packages library in the FORM site.

<p>

</p><h1><a name="SECTION009500000000000000000"></a><a name="13976"></a><a name="13977"></a>
<a name="funrandom"></a>
<br>
random_
</h1>
A random number generator. When the function has a single 
positive integer argument, the function will return a pseudo random number 
in the range of one to that number inclusive. Hence one can imitate a die 
roll with the call random_(6). The program uses a random number generator 
as described in vol 2 of the "Art of computer programming, vol2" by D. 
Knuth with the parameters set at 89,38 to give as long a cycle as possible. 
For very large numbers the program pastes several random numbers together. 
The generator can be initialized with the preprocessor 
#setrandom<a href="#presetrandom" name="13980">3.52</a> instruction. When running 
with TFORM or ParFORM each worker runs an independent generator with its 
own seed. The seeds of the workers are derived from the seed of the master 
and the number of the worker in a non-trivial way. It should be noted 
however that with workers it may be impossible to reproduce previous runs 
as it is non-deterministic which term ends up in which worker.

<p>

</p><h1><a name="SECTION009510000000000000000"></a><a name="13982"></a><a name="13983"></a>
<a name="funranperm"></a>
<br>
ranperm_
</h1>
Generates a random permutation of the arguments, with exception 
of the first argument which should be the name of a function. This function 
will then have the permuted arguments as in:
<pre>    CFunction f;
    Symbols x1,...,x5;
    Local F = ranperm_(f,1,2,3,4,5,6)
             +ranperm_(f,x1,x2,x3+x1,x4,x5);
    Print +s;
    .end

   F =
       + f(x5,x1,x3 + x1,x4,x2)
       + f(3,1,6,2,4,5)
      ;
</pre>
The permutation is generated with the same random number generator that is 
used by the function 
random_&nbsp;<a href="#funrandom" name="13988">8.50</a><a name="13989"></a> and hence 
is susceptible to the same initialization procedure that can be executed 
with the #setrandom&nbsp;<a href="#presetrandom" name="13991">3.52</a> instruction.

<p>

</p><h1><a name="SECTION009520000000000000000"></a><a name="13993"></a><a name="13994"></a>
<a name="funrem"></a>
<br>
rem_
</h1>
<code>rem_(x1,x2)</code> is replaced by the remainder of the division 
of <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img97.png" alt="$x_1$"> by <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img96.png" alt="$x_2$">. The arguments can be any valid subexpressions, provided 
the whole function fits inside a term. When an argument is only an active 
expression or a $-expression it is only expanded during the division. This 
way the contents of such expressions can exceed the maximum term size. One 
should however realize that in that case the operation takes place in 
allocated memory.
This function replaces the experimental function 
polyrem_<a name="13996"></a><a name="13997"></a> that existed in 
version 3.

<p>

</p><h1><a name="SECTION009530000000000000000"></a><a name="13999"></a><a name="14000"></a>
<a name="funreplace"></a>
<br>
replace_
</h1>
This function defines a rather general purpose 
replacement<a name="14002"></a> mechanism. It should have pairs of 
arguments. Each pair consists of a single symbol, index, vector or 
function, followed by what this object should be replaced by in the entire 
term. Functions can only be replaced by functions, indices only by indices. 
A vector can be replaced by a single vector or by a vector like expression. 
A symbol can be replaced by a single symbol, a numerical expression or a 
complete subexpression that is not index like or vector like. This 
mechanism is sometimes needed to make replacements in ways that are very 
hard with the id<a name="14003"></a> statements because those do not make 
replacements automatically inside function arguments (see 
<a href="#substaidnew">7.61</a>). It also allows to exchange two variables as the 
replacements are executed simultaneously by the wildcard substitution 
mechanism.
<pre>    Multiply replace_(x,y,y,x);
</pre>
will exchange x and y. Because there is no definite order in which multiple 
replace_ functions are treated, one should not use more than a single one 
at the same time inside a term. At times multiple replace_ functions may 
lead to confusion inside FORM.

<p>

</p><h1><a name="SECTION009540000000000000000"></a><a name="14008"></a><a name="14009"></a>
<a name="funreverse"></a>
<br>
reverse_
</h1>
Can only occur as an argument of a function. Is replaced 
by the reversed string of its own arguments.

<p>

</p><h1><a name="SECTION009550000000000000000"></a><a name="14012"></a><a name="14013"></a>
<a name="funroot"></a>
<br>
root_
</h1>
If we have <code>root_(n,x)</code> and <code>n</code> is a positive 
integer and <code>x</code> is a rational number and <code>y</code> is a rational number 
with <img width="51" height="29" align="MIDDLE" border="0" src="./online_files/img100.png" alt="$y^n = x$"> (no imaginary numbers are considered and negative numbers 
are avoided if possible. Only one root is given) then <code>root_(n,x)</code> is 
replaced by <code>y</code>. This function was originally intended for internal 
use. Do not hold it against the author that <code>root_(2,1)</code> is replaced 
by <code>1</code>. In the case that it is needed the user should manipulate the 
sign or the complexity properties externally.

<p>

</p><h1><a name="SECTION009560000000000000000"></a><a name="14016"></a><a name="14017"></a>
<a name="funsetfun"></a>
<br>
setfun_
</h1>
Currently not active.

<p>

</p><h1><a name="SECTION009570000000000000000"></a><a name="14020"></a><a name="14021"></a>
<a name="funsig"></a>
<br>
sig_
</h1>
Is replaced by the sign of the (numerical) argument, i.e. by -1 
if there is a single negative argument and by +1 if there is a single 
numerical argument that is greater or equal to zero.

<p>

</p><h1><a name="SECTION009580000000000000000"></a><a name="14024"></a><a name="14025"></a>
<a name="funsign"></a>
<br>
sign_
</h1>
<code>sign_(n)</code> is replaced by <code>(-1)^n</code> if n is an 
integer.

<p>

</p><h1><a name="SECTION009590000000000000000"></a><a name="14028"></a><a name="14029"></a>
<a name="funsum"></a>
<br>
sum_
</h1>
General purpose sum<a name="14031"></a> function. The first argument should 
be the summation parameter (a symbol). The second argument is the starting 
point of summation, the third argument the `upper' limit and a potential 
fourth argument the increment. These numbers should all be integers. 
Summation stops when the summation parameter obtains a value that has 
passed the upper limit. The last argument is the summand, the object to be 
summed over. It can be any subexpression. If it contains the summation 
parameter, it will be replaced by its value for each generated term. 
Examples:
<pre>    sum_(j,1,4,sign_(j)*x^j/j)
    sum_(i,1,9,2,sign_((i-1)/2)*x^i*invfac_(i))
</pre>

<p>

</p><h1><a name="SECTION009600000000000000000"></a><a name="14035"></a><a name="14036"></a>
<a name="funsump"></a>
<br>
sump_
</h1>
Special sum function. Its arguments are like for the 
sum_ function, but each new term is the product of the previously 
generated term with the last argument in which the current value of the 
summation parameter has been substituted. The first term is always one. 
Example:
<pre>    Symbol i,x;
    Local F = sump_(i,0,5,x/i);
    Print;
    .end

   F =
      1 + x + 1/2*x^2 + 1/6*x^3 + 1/24*x^4 + 1/120*x^5;
</pre>
This function is a leftover from the Schoonschip<a name="14040"></a> days. 
The ordinary sum_ function is much more readable.

<p>

</p><h1><a name="SECTION009610000000000000000"></a><a name="14042"></a><a name="14043"></a>
<a name="funtable"></a>
<br>
table_
</h1>
For action the arguments should be the name of a table and then 
either the name of a function or one symbol for each dimension of the 
table. In the case of the list of symbols the return value will be a 
monomial in the given symbols in which the powers of the symbols correspond 
to the table indices of the defined table elements with the coefficients 
the table contents corresponding to those indices. In the case of a 
function name the return value will be a sum over terms in which the table 
elements are indicated by arguments in the given function while these 
functions are then multiplied by the corresponding table elements. This is 
one way to put a complete table inside an expression and store it (with the 
save statement of <a href="#substasave">7.118</a>) in a binary way for a future run in 
which the table can be filled again with the 
fillexpression<a name="14046"></a> (see <a href="#substafillexpression">7.50</a>) 
statement. Note that for obvious reasons one should avoid using symbols or 
functions that also occur inside the table definitions.

<p>

</p><h1><a name="SECTION009620000000000000000"></a><a name="14049"></a><a name="14050"></a>
<a name="funtbl"></a>
<br>
tbl_
</h1>
This function is the `table stub function' as used by the 
tablebase<a name="14052"></a> construction. This is explained in chapter 
<a href="#tablebase">12</a>. It is mainly for internal use, but it could occur in the 
output.

<p>

</p><h1><a name="SECTION009630000000000000000"></a><a name="14055"></a><a name="14056"></a>
<a name="funterm"></a>
<br>
term_
</h1>
This function has no arguments. It is replaced by the current 
term. It can be used to load the current term into a dollar variable as in
<pre>   $x = term_;
</pre>

<p>

</p><h1><a name="SECTION009640000000000000000"></a><a name="14061"></a><a name="14062"></a>
<a name="funtermsin"></a>
<br>
termsin_
</h1>
If there is a single argument and this argument is the name of an 
active (or previously active during the current job) expression, the 
function is replaced by the number<a name="14064"></a> of terms in this 
expression. Stored expressions that were entered via a load statement (see 
<a href="#substaload">7.75</a>) are excluded from this because for them FORM would have 
to actually count the terms.

<p>

</p><h1><a name="SECTION009650000000000000000"></a><a name="14067"></a><a name="14068"></a>
<a name="funtermsinbracket"></a>
<br>
termsinbracket_
</h1>
If there is no argument, or the single argument is zero, the 
function is replaced by the number of terms in the current 
bracket<a name="14070"></a>, provided the expression has been bracketed at its 
last sort and a keep brackets statement (see <a href="#substakeep">7.72</a>) has been 
used. Note that the terms have to be counted. Hence this is a relatively 
expensive command. More options will be implemented in the future.

<p>

</p><h1><a name="SECTION009660000000000000000"></a><a name="14073"></a><a name="14074"></a>
<a name="funtheta"></a>
<br>
theta_
</h1>
If there is a single numerical argument x the function is 
replaced by one if <img width="42" height="28" align="MIDDLE" border="0" src="./online_files/img101.png" alt="$x \ge 0$"> and by zero if <img width="42" height="28" align="MIDDLE" border="0" src="./online_files/img102.png" alt="$x &lt; 0$">. If there are two 
numerical arguments <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img97.png" alt="$x_1$"> and <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img96.png" alt="$x_2$"> the function is replaced by one if <img width="58" height="28" align="MIDDLE" border="0" src="./online_files/img103.png" alt="$x_1
= x_2$"> or if the arguments are in natural order (if theta_ would be a 
symmetric function there would be no reason to exchange the arguments) and 
by zero if the arguments are not in natural order (they would be exchanged 
in a symmetric function). In all other cases nothing is done.

<p>

</p><h1><a name="SECTION009670000000000000000"></a><a name="14077"></a><a name="14078"></a>
<a name="funthetap"></a>
<br>
thetap_
</h1>
If there is a single numerical argument x the function is 
replaced by one if <img width="42" height="28" align="MIDDLE" border="0" src="./online_files/img104.png" alt="$x &gt; 0$"> and by zero if <img width="42" height="28" align="MIDDLE" border="0" src="./online_files/img105.png" alt="$x \le 0$">. If there are two 
numerical arguments <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img97.png" alt="$x_1$"> and <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img96.png" alt="$x_2$"> the function is replaced by zero if <img width="58" height="28" align="MIDDLE" border="0" src="./online_files/img103.png" alt="$x_1
= x_2$"> or if the arguments are not in natural order. If the arguments are 
in natural order the function is replaced by one. In all other cases 
nothing is done.

<p>

</p><h1><a name="SECTION009680000000000000000">
Extra reserved names</a>
</h1>

<p>
In addition there are some names that have been reserved for 
future use. At the moment these functions do not do very much. It is hoped 
that in the future some simplifications of the arguments can be 
implemented. These functions are:

</p><p>
<table width="136">
<tbody><tr><td>sqrt_
</td></tr>
</tbody></table>
<br><a name="14083"></a><a name="14084"></a>
<table width="590">
<tbody><tr><td>The regular square root.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>ln_
</td></tr>
</tbody></table>
<br><a name="14089"></a><a name="14090"></a>
<table width="590">
<tbody><tr><td>The natural logarithm.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>sin_
</td></tr>
</tbody></table>
<br><a name="14095"></a><a name="14096"></a>
<table width="590">
<tbody><tr><td>The sine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>cos_
</td></tr>
</tbody></table>
<br><a name="14101"></a><a name="14102"></a>
<table width="590">
<tbody><tr><td>The cosine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>tan_
</td></tr>
</tbody></table>
<br><a name="14107"></a><a name="14108"></a>
<table width="590">
<tbody><tr><td>The tangent function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>asin_
</td></tr>
</tbody></table>
<br><a name="14113"></a><a name="14114"></a>
<table width="590">
<tbody><tr><td>The inverse of the sine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>acos_
</td></tr>
</tbody></table>
<br><a name="14119"></a><a name="14120"></a>
<table width="590">
<tbody><tr><td>The inverse of the cosine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>atan_
</td></tr>
</tbody></table>
<br><a name="14125"></a><a name="14126"></a>
<table width="590">
<tbody><tr><td>The inverse of the tangent function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>atan2_
</td></tr>
</tbody></table>
<br><a name="14131"></a><a name="14132"></a>
<table width="590">
<tbody><tr><td>Another inverse of the tangent function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>sinh_
</td></tr>
</tbody></table>
<br><a name="14137"></a><a name="14138"></a>
<table width="590">
<tbody><tr><td>The hyperbolic sine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>cosh_
</td></tr>
</tbody></table>
<br><a name="14143"></a><a name="14144"></a>
<table width="590">
<tbody><tr><td>The hyperbolic cosine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>tanh_
</td></tr>
</tbody></table>
<br><a name="14149"></a><a name="14150"></a>
<table width="590">
<tbody><tr><td>The hyperbolic tangent function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>asinh_
</td></tr>
</tbody></table>
<br><a name="14155"></a><a name="14156"></a>
<table width="590">
<tbody><tr><td>The inverse of the hyperbolic sine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>acosh_
</td></tr>
</tbody></table>
<br><a name="14161"></a><a name="14162"></a>
<table width="590">
<tbody><tr><td>The inverse of the hyperbolic cosine function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>atanh_
</td></tr>
</tbody></table>
<br><a name="14167"></a><a name="14168"></a>
<table width="590">
<tbody><tr><td>The inverse of the hyperbolic tangent function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>li2_
</td></tr>
</tbody></table>
<br><a name="14173"></a><a name="14174"></a>
<table width="590">
<tbody><tr><td>The dilogarithm function.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>lin_
</td></tr>
</tbody></table>
<br><a name="14179"></a><a name="14180"></a>
<table width="590">
<tbody><tr><td>The polylogarithm function.</td></tr>
</tbody></table>
    <br>

</p><p>
The user is allowed to use these functions, but it could be that 
in the future they will develop a nontrivial behaviour. Hence caution is 
required.

</p><p>

</p><h1><a name="SECTION001000000000000000000"></a>
<a name="brackets"></a>
<br>
Brackets
</h1>

<p>
At times one would like to order the output in a specific way. In an 
expression which is for instance a polynomial in terms of the symbol <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$">, 
one might want to make this behaviour in terms of <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$"> more apparent by 
printing the output in such a way, that all powers of <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$"> are outside 
parentheses<a name="14754"></a>, and the whole rest is inside parentheses. 
This is done with the bracket<a name="14755"></a> statement:
</p><pre>    Bracket x;
</pre>
or in short notation
<pre>    B x;
</pre>
One can specify more than one object in the bracket statement, but only a 
single bracket statement (the last one) is considered. Bracket statements 
belong to the module in which they occur. Hence they are forgotten after 
the next end-of-module.

<p>
If a vector is mentioned in a bracket statement, 
all occurrences of this vector as a loose vector, a vector with any index, 
inside a dotproduct, or inside a tensor are taken outside brackets. If the 
vector occurs inside a non-commuting tensor, all other non commuting 
objects that are to the left of this tensor will also be taken outside the 
parentheses.

</p><p>
When a function or tensor is mentioned in a bracket statement, it is not 
allowed to have any arguments in the bracket statement. All occurrences of 
this function will be pulled outside brackets. If the function is 
non-commuting, all other functions and/or tensors that are non-commuting 
and are to the left of the specific function(s) or tensor(s) will also be 
outside parentheses.

</p><p>
The opposite of the bracket statement is the antibracket<a name="14760"></a> 
statement:
</p><pre>    AntiBracket x;
</pre>
or
<pre>    ABracket x;
</pre>
or
<pre>    AB x;
</pre>
This statement causes also brackets in the output, but now everything is 
put outside brackets, except for powers of x and coefficients. This way one 
can make the <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$">-dependence apparent differently.

<p>
Because the bracket statement causes a different ordering of the terms when 
storing the expression, one can use this ordering in the next module. There 
are various ways to do this.

</p><p>
One can use the contents of a given bracket in a r.h.s. expression as in
</p><pre>    Symbols a,b,c,x;
    L  F = a*x^2+b*x+c;
    B x;
    .sort
    L  Discriminant = F[x]^2-4*F[x^2]*F[1];
    Print;
    .end
</pre>
The outside of the bracket is placed between braces<a name="14769"></a> after the 
name of the expression. The bracket that has nothing outside is referred to 
with the number 1. If a bracket is empty, its contents will be represented 
by the value zero.

<p>
The regular algorithm by which FORM finds brackets in an expression, is 
to start from the beginning and inspect each term until it finds the 
appropriate bracket. This is fully in the spirit of the sequential 
treatment of expressions in FORM. This can however be rather 
slow<a name="14772"></a> in big 
expressions that reside on a disk. Hence there is the bracket<a name="14773"></a> 
index<a name="14774"></a> 
feature. It is invoked by putting a <img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$">-sign after the bracket (or B) 
statement as in 
</p><pre>    Bracket+ x;
</pre>
or
<pre>    B+ x;
</pre>
This option causes FORM to build a tree of (disk) positions for the 
different brackets, with the condition that the whole storage of this tree 
of brackets does not exceed a given maximum space, named 
`bracketindexsize'<a name="14780"></a> 
(see chapter&nbsp;<a href="#setup">16</a> on the setup parameters). 
If the index would need more space FORM will start 
skipping brackets in the index. This means that it will have to look for 
the bracket in a sequential fashion, but starting from the position 
indicated by the previous bracket in the index. This will still be very 
fast, provided the index is not very small.

<p>
When the bracket index option is used, FORM will not compress the 
expressions that use such an index with the zlib compression, even if the 
user asked for this in an earlier statement. The use of the index indicates 
that the brackets are going to be used intensively, and hence the 
continuous decompression that would result would destroy most of the profit 
that comes from the index. If the brackets are only for cosmetics in the 
output, it is better not to use the index option. It does use resources to 
construct the index<a name="14783"></a> tree<a name="14784"></a>. Also when 
brackets are only used sequentially as in the features discussed below, the 
presence of the index is not beneficial. It should only be applied when 
contents of brackets are used in the above way (like with the 
discriminant).

</p><p>
There are several statements that make use of the bracket ordering:

</p><ul>
<li>Keep<a name="14786"></a> Brackets;
	This statement takes from the input one term at a time as usual, but 
then it takes the part outside the brackets, executes the statements of the 
module only on that part of the term, and then, when all statements of the 
module have had their effect, the resulting term(s) is/are multiplied by 
the full content of the bracket. The next term taken from the input will be 
the first term of the next bracket. This way one can hide part of the terms 
for the pattern matcher. Also one can avoid that the same matching will 
occur many times, as in an expression of the type
<pre>      + f(y)*(x+x^2+x^3+x^4+1)
</pre>
If we would want to make a replacement of the type
<pre>    Keep Brackets;
    id f?{f1,f2,f3}(u?) = f(u+1)/u;
</pre>
the pattern matching and the substitution would have to be done only once, 
rather than 5 times, as would be the case if the Keep bracket statement 
would not be used.
</li>
<li>Collect<a name="14791"></a> FunctionName;
	The contents of the various brackets will be placed inside a function 
with the given name. Hence
<pre>      + f(y)*(x+x^2+x^3+x^4+1)
      + f(y^2)*(x+2*x^2+3*x^3+4*x^4+1)
</pre>
with
<pre>    Collect h;
</pre>
would result in:
<pre>      + f(y)*h(x+x^2+x^3+x^4+1)
      + f(y^2)*h(x+2*x^2+3*x^3+4*x^4+1)
</pre>
This can be very useful to locate <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$">-dependence even further, because 
bracketing the new expression in terms of <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img107.png" alt="$h$"> could make very clear 
whether a given polynomial in <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$"> would factor the whole expression, or 
which factors are occurring. To bring <code>h(x+1)</code> and <code>h(2*x+2)</code> to 
multiples of the same objects one should consult the pages on the 
normalize<a name="14798"></a> 
(<a href="#substanormalize">7.89</a>) 
and makeinteger<a name="14800"></a> (<a href="#substamakeinteger">7.77</a>) statements.

<p>
The Collect statement, together with the PolyFun<a name="14802"></a> statement, 
can also be very useful, if the variable <img width="13" height="14" align="BOTTOM" border="0" src="./online_files/img106.png" alt="$x$"> (or other variables) is 
temporarily not playing much of a role in the pattern matching. It can make 
the program much faster.

</p><p>
For more information on the collect statement one should consult 
section&nbsp;<a href="#substacollect">7.16</a>.
</p></li>
</ul>

<p>
Restrictions: The bracket index can only be used with active expressions. 
Hence the access of specific brackets in stored expressions will always be 
of the slow variety. To make it faster, one can copy the expression into a 
local expression with indexed brackets, use it, and drop the expression 
when it is not needed any longer.

</p><p>
The brackets can also be used to save space on the disk in problems in 
which the expressions become rather large. Let us assume the following 
simple problem:
</p><pre>    Symbols x1,...,x12;
    Local F = (x1+...+x12)^10;
    .sort
    id  x1 = x4+x7;
    .end
</pre>
If the program is run like this the expression F contains 352716 terms 
after the sort and after the id the sorting in the .end results in a final 
stage sort<a name="14807"></a> of which the statistics are:
<pre>Time =      46.87 sec
                F        Terms active    =     504240
                         Bytes used      =   13462248

Time =      52.09 sec    Generated terms =     646646
                F        Terms in output =     184756
                         Bytes used      =    4883306
</pre>
We see, that the intermediate sort file still contains more than 500000 
terms and more than 13 Mbytes, while the final result contains less than 5 
Mbytes. Why is this? When the terms in FORM are sorted first come the 
powers of <code>x1</code>, because this is the variable that was declared first. 
Hence the terms that do not have powers of <code>x1</code> come much later in the 
input and will not be compared with the terms generated by the substitution 
of for instance a single power of <code>x1</code> until very late in the sorting. 
What can we do about this? We can try to group the terms in the first sort 
such that after the substitution like terms will be `very close' to each 
other and hence will add quickly. This is done in the program
<pre>    Symbols x1,...,x12;
    Local F = (x1+...+x12)^10;
    AntiBracket x1,x4,x7;
    .sort
    id  x1 = x4+x7;
    .end
</pre>
Now all powers of the mentioned variables will be inside the brackets and 
all other variables will be outside. Because the terms inside the brackets 
are all following each other in the input of the second module, terms that 
will add will be generated closely together.
The result is visible in the final statistics:
<pre>Time =      47.23 sec
                F        Terms active    =     184761
                         Bytes used      =    4928008

Time =      48.40 sec    Generated terms =     646646
                F        Terms in output =     184756
                         Bytes used      =    4883306
</pre>
Now the final step of the sorting has already almost the proper number of 
terms. The difference is due to brackets that are half in one `patch' on 
the disk and half in the next `patch' (for the meaning of the patches, one 
should read the part about sorting<a name="14814"></a> in chapter&nbsp;<a href="#setup">16</a> on 
the setup file. It should be rather clear now that this saves disk space 
and the corresponding amount of time. These early cancellations can also be 
seen in the first statistics message of the second module. In the first 
case it is
<pre>Time =      19.76 sec    Generated terms =      10431
                F   5216 Terms left      =       8065
                         Bytes used      =     239406
</pre>
and in the second case it is
<pre>Time =      22.82 sec    Generated terms =      10124
                F   5835 Terms left      =       3186
                         Bytes used      =      96678
</pre>
This also causes a more efficient use of the large buffer and again a 
better use of the disk. There have been cases in which this `trick' was 
essential to keep the sort file inside the available disk space.

<p>

</p><h1><a name="SECTION001100000000000000000"></a>
<a name="polynomials"></a>
<br>
Polynomials and Factorization
</h1>

<p>
Starting with version 4, FORM is equipped with powerful handling 
of rational polynomials and with factorization capabilities. Because this 
creates many new possibilities, it brings a whole new category of commands 
with it. We will list most of these here.

</p><p>
First there are the rational polynomials. These work a bit like 
the PolyFun<a href="#substapolyfun">7.102</a>, but now with two arguments: a numerator and 
a denominator. Instead of PolyFun the function is designated as 
PolyRatFun<a href="#substapolyratfun">7.103</a> as in the example below:
</p><pre>    Symbol x,y;
    CFunction rat;
    PolyRatFun rat;
    L   F = rat(x+y,x-y)+rat(x-y,x+y);
    Print;
    .end

   F =
      rat(2*x^2 + 2*y^2,x^2 - y^2);
</pre>
Dealing with a PolyRatFun can be very handy, but one should realize that 
there is a limit to the size of the arguments, because the PolyRatFun with 
its arguments is part of a term and hence is limited by the maximum size of 
a term<a href="#setupmaxtermsize">16</a>. One should also take into account that the 
manipulation of multivariate polynomials, and in particular the GCD 
operation, can be rather time consuming.

<p>
The PolyRatFun has one limitation as compared to the regular 
PolyFun: in its arguments one may use only symbols. Of course FORM is 
equipped with a mechanism to replace other objects by extra internally 
generated symbols<a href="#substaextrasymbols">7.45</a>. One could imagine FORM to 
automatically convert these objects to symbols, do the polynomial 
arithmetic and then convert back. This is done with factorization and the 
gcd_<a href="#fungcd" name="14879">8.30</a><a name="14880"></a>, 
div_<a href="#fundiv" name="14882">8.13</a><a name="14883"></a> 
and rem_<a href="#funrem" name="14885">8.52</a><a name="14886"></a> functions. But 
because the addition of PolyRatFun's is such a frequent event, this would 
be very costly in time. Hence it is better that the user does this once 
in a controlled way.

</p><p>
The PolyFun and PolyRatFun declarations are mutually exclusive. 
The PolyRatFun is considered a special type of PolyFun and there can be 
only one PolyFun at any moment. If one wants to switch back to a mode in 
which there is neither a PolyFun nor a PolyRatFun one can use
</p><pre>   PolyRatFun;
</pre>
to indicate that after this there is no function with that status.

<p>
When a PolyRatFun has only a single argument, this argument is 
interpreted as the numerator of a fraction. FORM will add automatically a 
second argument which has the value 1.

</p><p>
The second important polynomial facility is factorization. This 
is not necessarily something trivial. First of all, with very lengthy 
multivariate input, this can be unpractically slow. Second of all, there 
are various types of objects that we may factorize and each has its special 
needs. One of those needs is access to the factors, which is different for 
the factors of function arguments, of $-expressions or even complete 
expressions. In addition $-expressions should be factorizable either from 
the preprocessor or on a term by term basis. Let us start with function 
arguments.

</p><p>
One can factorize function arguments with the FactArg 
statement<a href="#substafactarg">7.46</a>. The factors are each represented by a 
separate argument as in
</p><pre>    Symbol x,y;
    CFunction f1,f2;
    Local F = f1(x^4-y^4)+f2(3*y^4-3*x^4);
    FactArg,f1,f2;
    Print;
    .end

   F=
      f1(y-x,y+x,y^2+x^2,-1)+f2(y-x,y+x,y^2+x^2,3);
</pre>
Overall constants and overall signs are taken separately as one can see. If 
one wants the factors in separate functions one can use the 
ChainOut<a href="#substachainout">7.13</a> command as in
<pre>    Symbol x,y;
    CFunction f1,f2;
    Local F = f2(3*y^4-3*x^4);
    FactArg,f2;
    Print;
    .sort

   F=
      f2(y-x,y+x,y^2+x^2,3);

    ChainOut,f2;
    id f2(x?number_) = x;
    Print;
    .end

   F=
      3*f2(y-x)*f2(y+x)*f2(y^2+x^2);
</pre>

<p>
Factorization of expressions is a bit more complicated. Clearly 
this cannot be a command at the term level. Hence we had two options on how 
to implement this. One would have been as a preprocessor instruction, which 
we did not select, and the other is as some type of format statement, which 
is what we did opt for. In the case we factorize an expression, the 
original unfactorized expression is replaced by the factorized version. 
After that we keep the factorized version only and that may bring some 
restrictions with it. Of course, in the same way one can factorize an 
expression, one can unfactorize it. The corresponding statements are 
Factorize<a href="#substafactorize">7.48</a>, NFactorize<a href="#substanfactorize">7.86</a>, 
UnFactorize<a href="#substaunfactorize">7.145</a> and 
NUnFactorize<a href="#substanunfactorize">7.95</a>. These statements are used at the end 
of the module in the same place as one might use the bracket 
statement<a href="#substabracket">7.10</a>. It should be noticed however that a 
factorized expression will never apply the bracket mechanism. They are 
mutually exclusive, because internally we use the bracket mechanism with a 
built in symbol factor_ to indicate the factors. Here is an example:
</p><pre>    Symbol x,y;
    Local F = x^4-y^4;
    Print;
    .sort

Time =       0.00 sec    Generated terms =          2
               F         Terms in output =          2
                         Bytes used      =         64

   F=
      -y^4+x^4;

    Print;
    Factorize F;
    .end

Time =       0.00 sec    Generated terms =          2
               F         Terms in output =          2
                         Bytes used      =         64

Time =       0.00 sec    Generated terms =          7
               F         Terms in output =          7
               factorize Bytes used      =        288

   F=
       (-1)
      *(y-x)
      *(y+x)
      *(y^2+x^2);
</pre>
We have printed the statistics in this example to show that the 
factorization prints its own statistics. This factorization is executed 
after the expression has been completed and before manipulations on the 
next expression start. This way it is possible to overwrite the first 
output by the factorized output and we do not loose diskspace 
unnecessarily.

<p>
The next question is of course how to find out how many factors 
an expression has and how to access individual factors. There is a function 
numfactors_ which gives the number of factors in an expression:
</p><pre>    Symbol x,y;
    Local F1 = x^4-y^4;
    Local F2 = 0;
    Local F3 = 1;
    Local F4 = x^4-y^4;
    Print;
    Factorize F1,F2,F3;
    .sort

   F1=
       (-1)
      *(y-x)
      *(y+x)
      *(y^2+x^2);
    
   F2=0;

   F3=
       (1);

   F4=
      -y^4+x^4;
    #do i = 1,4
    #$n`i' = numfactors_(F`i');
    #message expression F`i' has `$n`i'' factors
~~~expression F1 has 4 factors
    #enddo
~~~expression F2 has 1 factors
~~~expression F3 has 1 factors
~~~expression F4 has 0 factors
    .end
</pre>
As we see, an expression that is zero still gives one factor when it is 
factorized. When the expression is not factorized it will return 0 in all 
cases. The factors can be accessed easily once one knows that the factors 
are stored by means of the bracket mechanism and the n-th factor is the 
bracket with the n-th power of the symbol factor_ outside the bracket:
<pre>    Symbol x,y;
    Local F = x^4-y^4;
    Factorize F;
    .sort
    #$n = numfactors_(F);
    #do i = 1,`$n'
    Local F`i' = F[factor_^`i'];
    #enddo
    Print;
    .end

   F=
       (-1)
      *(y-x)
      *(y+x)
      *(y^2+x^2);

   F1=
      -1;

   F2=
      y-x;

   F3=
      y+x;

   F4=
      y^2+x^2;
</pre>

<p>
It is also possible to put an expression in the input in a 
factorized format. For this we have the 
LocalFactorized<a href="#substalfactorized">7.74</a> and 
GlobalFactorized<a href="#substagfactorized">7.56</a> commands. These commands can 
be abbreviated to LFactorized, GFactorized or even LF and GF. One should 
notice that these commands do not execute a factorization. They accept the 
factors as the user provides them:
</p><pre>    Symbol x,y;
    LocalFactorize E = -(x+1)*(x+2)*((x+3)*(x+4));
    Print;
    .end

   E =
         (  - 1 )
       * ( 1 + x )
       * ( 2 + x )
       * ( 12 + 7*x + x^2 );
</pre>
This can go to some extremes when we feed in expressions 
containing powers and expressions that are potentially already factorized:
<pre>    Symbol x,y;
    LocalFactorize E = -(x+1)*(x+2)*((x+3)*(x+4));
    Local   F = -(x+1)*(x+2)*((x+3)*(x+4));
    Print;
    .sort

   E=
       (-1)
      *(1+x)
      *(2+x)
      *(12+7*x+x^2);

   F=
      -24-50*x-35*x^2-10*x^3-x^4;

    LF G = (x-1)*(x+2)^2*E^2*F^2;
    Print G;
    .end

   G=
       (-1+x)
      *(2+x)
      *(2+x)
      *(-1)
      *(1+x)
      *(2+x)
      *(12+7*x+x^2)
      *(-1)
      *(1+x)
      *(2+x)
      *(12+7*x+x^2)
      *(-24-50*x-35*x^2-10*x^3-x^4)
      *(-24-50*x-35*x^2-10*x^3-x^4);
</pre>
To put some order in this one may factorize the new expression 
again:
<pre>    Symbol x,y;
    LocalFactorize E = -(x+1)*(x+2)*((x+3)*(x+4));
    Local   F = -(x+1)*(x+2)*((x+3)*(x+4));
    .sort
    LF G = (x-1)*(x+2)^2*E^2*F^2;
    Print G;
    Factorize G;
    .end

   G=
       (-1+x)
      *(1+x)
      *(1+x)
      *(1+x)
      *(1+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(3+x)
      *(3+x)
      *(3+x)
      *(3+x)
      *(4+x)
      *(4+x)
      *(4+x)
      *(4+x);
</pre>
In this case all constants are multiplied, all factors are 
factorized, and all factors in the new format are sorted.

<p>
The case that one or more factors are zero is special. In 
principle the zero factors are kept as in:
</p><pre>    Symbol x,y;
    LocalFactorize E = -0*(x+1)*(x+2)*0*((x+3)*(x+4));
    Print;
    .end

   E=
       (-1)
      *(0)
      *(1+x)
      *(2+x)
      *(0)
      *(12+7*x+x^2);
</pre>
This way one can see what has happened when a substitution makes 
a factor zero. When we factorize this expression again however the whole 
expression becomes zero. If this is not intended and one would like to 
continue with the factors that are nonzero we have the keepzero option in 
the factorize statement as in:
<pre>    Symbol x,y;
    Format Nospaces;
    LocalFactorize E = -0*3*(x+1)*(x+2)/2*0*((x+3)*(x+4));
    Print;
    .sort

   E=
       (-1)
      *(0)
      *(3)
      *(1+x)
      *(2+x)
      *(1/2)
      *(0)
      *(12+7*x+x^2);
    Print;
    Factorize(keepzero) E;
    .end

   E=
       (0)
      *(-3/2)
      *(1+x)
      *(2+x)
      *(3+x)
      *(4+x);
</pre>
We see here that first all constants are separate factors and the 
new factorization combines them. The keepzero option does the same with the 
factors that are zero. The zero factor will always be the first. Hence it 
is rather easy to test for whether the total expression should actually be 
zero. We just have to look whether <code>E[factor_]</code> is zero.

<p>
The unfactorize<a href="#substaunfactorize">7.145</a> statement is the opposite 
of the factorize statement. It takes the factorized expression and 
multiplies out the factors. It also uses the current brackets for 
formatting the output.
</p><pre>    Symbol x,y;
    LFactorized F = (x+1)*(x+y)*(y+1);
    Print;
    .sort

   F=
       (1+x)
      *(y+x)
      *(1+y);

    Print;
    Bracket x;
    UnFactorize F;
    .end

   F=
      +x*(1+2*y+y^2)
      +x^2*(1+y)
      +y+y^2;
</pre>
In principle there are various models by which the 
unfactorization can be done in an efficient way. In addition it would be 
less efficient when the master would do all the work as is the case with 
the factorize statement. Currently this statement is still being developed 
internally. It is possible to make ones own emulation of it. Here we give 
the `brute force' way:
<pre>    Symbol x,y;
    LFactorized F = (x+1)*(x+y)*(y+1);
    Print;
    .sort

   F=
       (1+x)
      *(y+x)
      *(1+y);

    #$num = numfactors_(F);
    Local   G = &lt;F[factor_^1]&gt;*...*&lt;F[factor_^`$num']&gt;;
    Bracket x;
    Print;
    .end

   F=
       (1+x)
      *(y+x)
      *(1+y);

   G=
      +x*(1+2*y+y^2)
      +x^2*(1+y)
      +y+y^2;
</pre>

<p>
Factorization of $-expressions is yet a different thing. The 
$-expressions do not have a bracket mechanism. Hence we need different 
ways of storing the factors. In the case of expressions we have to work in 
a way that is potentially disk based. With $-expressions we work in 
allocated memory. Hence we also store the factors in allocated memory. In 
that case we can keep both the original and the factors. The factors are 
accessed by referring to their number between braces. The number zero 
refers to the number of factors:
</p><pre>    Symbol x,y;
    CFunction f;
    Off Statistics;
    #$a = x^4-y^4;
    Local F = f(x^4-y^4)+f(x^6-y^6);
    Print;
    .sort

   F=
      f(-y^4+x^4)+f(-y^6+x^6);
    #factdollar $a;
    #do i = 1,`$a[0]'
    #write &lt;&gt; "Factor `i' of `$a' is `$a[`i']'"
Factor 1 of -y^4+x^4 is -1
    #enddo
Factor 2 of -y^4+x^4 is y-x
Factor 3 of -y^4+x^4 is y+x
Factor 4 of -y^4+x^4 is y^2+x^2
    id  f(x?$b) = f(x);
    FactDollar $b;
    do $i = 1,$b[0];
      Print "Factor %$ of %$ is %$",$i,$b,$b[$i];
    enddo;
    Print;
    .end
Factor 1 of -y^4+x^4 is -1
Factor 2 of -y^4+x^4 is y-x
Factor 3 of -y^4+x^4 is y+x
Factor 4 of -y^4+x^4 is y^2+x^2
Factor 1 of -y^6+x^6 is -1
Factor 2 of -y^6+x^6 is y-x
Factor 3 of -y^6+x^6 is y+x
Factor 4 of -y^6+x^6 is y^2-x*y+x^2
Factor 5 of -y^6+x^6 is y^2+x*y+x^2

   F=
      f(-y^4+x^4)+f(-y^6+x^6);
</pre>
We see here a variety of new features. The preprocessor can 
factorize $a with the #FactDollar instruction. We do indeed pick up the 
number of factors in the preprocessor as `$a[0]' and the factors 
themselves as `$a[1]' etc. For the $-variable that needs to be 
manipulated during running time things as a bit more complicated. We define 
$b as part of a wildcard pattern matching. This is still rather normal. 
Then we use the FactDollar statement. Notice that for each term we will 
have a different $b. To access the factors we cannot use the preprocessor 
methods because those are only available at compile time. Hence we cannot 
use the preprocessor #do instruction and therefore we need an execution 
time do statement. The loop parameter will have to be a $-variable as 
well. The do statement and the print statement show now how one can use the 
factors. In the output one can see that indeed we had two different 
contents for $b. And the arguments of the function f remain unaffected.

<p>
One may also ask for the number of factors in a $-expression 
with the numfactors_ function as in:
</p><pre>    Symbol x,y;
    CFunction f;
    Format Nospaces;
    #$a = x^4-y^4;
    #factdollar $a;
    Local F = f(numfactors_($a))
        +f(&lt;$a[1]&gt;,...,&lt;$a[`$a[0]']&gt;);
    Print;
    .end

   F=
      f(-1,y-x,y+x,y^2+x^2)+f(4);
</pre>
Note that in the second case we need to use the construction 
`$a[0]' because the preprocessor needs to substitute the number 
immediately in order to expand the triple dot operator. This cannot wait 
till execution time.

<p>
Some remarks.

</p><p>
The time needed for a factorization depends strongly on the 
number of variables used. For example factorization of <img width="54" height="33" align="MIDDLE" border="0" src="./online_files/img108.png" alt="$x^{60}-1$"> is much 
faster than factorization of <img width="68" height="33" align="MIDDLE" border="0" src="./online_files/img109.png" alt="$x^{60}-y^{60}$">. One could argue that the 
second formula can be converted into the first, but there is a limit to 
what FORM should do and what the user should do.
</p><pre>    Symbol x,y;
    Format NoSpaces;
    On ShortStats;
    Local F1 = x^60-1;
    Local F2 = y^60-x^60;
    Factorize F1,F2;
    Print;
    .end
      0.00s        1&gt;         2--&gt;         2:        52 F1 
      0.07s        1&gt;        51--&gt;        51:      1524 F1 factorize
      0.07s        1&gt;         2--&gt;         2:        64 F2 
      1.17s        1&gt;        51--&gt;        51:      1944 F2 factorize

   F1=
       (-1+x)
      *(1-x+x^2)
      *(1-x+x^2-x^3+x^4)
      *(1-x+x^3-x^4+x^5-x^7+x^8)
      *(1+x)
      *(1+x+x^2)
      *(1+x+x^2+x^3+x^4)
      *(1+x-x^3-x^4-x^5+x^7+x^8)
      *(1-x^2+x^4)
      *(1-x^2+x^4-x^6+x^8)
      *(1+x^2)
      *(1+x^2-x^6-x^8-x^10+x^14+x^16);

   F2=
       (y-x)
      *(y+x)
      *(y^2-x*y+x^2)
      *(y^4-x*y^3+x^2*y^2-x^3*y+x^4)
      *(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
      *(y^2+x*y+x^2)
      *(y^2+x^2)
      *(y^8-x*y^7+x^3*y^5-x^4*y^4+x^5*y^3-x^7*y+x^8)
      *(y^8+x*y^7-x^3*y^5-x^4*y^4-x^5*y^3+x^7*y+x^8)
      *(y^8-x^2*y^6+x^4*y^4-x^6*y^2+x^8)
      *(y^4-x^2*y^2+x^4)
      *(y^16+x^2*y^14-x^6*y^10-x^8*y^8-x^10*y^6+x^14*y^2+x^16);
</pre>

<p>
When one has a factorized expression and one uses the multiply 
statement, all terms in the factorized expression are multiplied the 
specified amount. This may lead to a counterintuitive result:
</p><pre>    Symbols a,b;
    LF F = (a+b)^2;
    multiply 2;
    Print;
    .end

   F =
       ( 2*b + 2*a )
       * ( 2*b + 2*a );
</pre>
This is a consequence of the way we store the factors. This way each factor 
will be multiplied by two. If one would like to add a factor one can do 
this by the following simple mechanism:
<pre>    Symbols a,b;
    LF F = (a+b)^2;
    .sort
    LF F = 2*F;
    Print;
    .end

   F =
         ( 2 )
       * ( b + a )
       * ( b + a );
</pre>

<p>
In version 3 there were some experimental polynomial functions 
like polygcd_<a name="14936"></a><a name="14937"></a>. These have been 
removed as their functionality has been completely taken over by the new 
functions gcd_<a href="#fungcd">8.30</a>, div_<a href="#fundiv">8.13</a> and rem_<a href="#funrem">8.52</a> and 
some statements like normalize<a href="#substanormalize">7.89</a>, 
makeinteger<a href="#substamakeinteger">7.77</a> and factarg<a href="#substafactarg">7.46</a>. Unlike 
regular functions, the functions gcd_. div_ and rem_ have the 
peculiarity that if one of the arguments is just an expression or a 
$-expression, this expression is not evaluated until the function is 
evaluated. This means that the evaluated expression does not have to fit 
inside the maximum size reserved for a single term. In some cases, when the 
gcd_ function is invoked with many arguments, the expression may not have 
to be evaluated at all! The GCD of the other arguments may be one already.

</p><p>

</p><p>

</p><h1><a name="SECTION001200000000000000000"></a>
<a name="optimization"></a>
<br>
Output optimization
</h1>

<p>
One of the uses of symbolic programs is to prepare formulas for further 
numerical processing<a name="14990"></a>. Technically speaking such 
processing is not part of computer algebra, although some packages may 
provide facilities for this. In FORM such facilities, like for instance 
Monte Carlo integration, do not exist at the moment, but, starting with 
version 4.1, FORM does provide statements to construct outputs in C or 
Fortran that are highly optimized with respect to the number of arithmetic 
operations<a name="14991"></a> that are needed for their 
evaluation. The algorithms used for this are described in the paper "Code 
Optimization in FORM" which can be found in the FORM pages under 
documentation. There are also some example programs. Here the precise 
format of the commands that concern the optimizations will be described.

</p><p>
In optimized output FORM needs temporary variables<a name="14992"></a>. In order to avoid conflicts with user defined objects FORM 
uses the extra symbols <a href="#substaextrasymbols" name="14994">7.45</a> for 
these variables. This means that the user can control their output 
representation in the standard way. In addition there are preprocessor 
variables that tell how many of these extra symbols were needed:
</p><dl>
<dt><strong>optimminvar_</strong></dt>
<dd>The number of extra symbols before the optimization 
process started<a name="14996"></a>.
</dd>
<dt><strong>optimmaxvar_</strong></dt>
<dd>The number of extra symbols after the optimization 
process finished<a name="14997"></a>.
</dd>
</dl>
Each new optimization will remove the old optimization results and start 
the extra symbols from the number there were before the optimization 
started. Because this may cause interference with the functioning of the 
extrasymbol statement, regular printing with output optimization and the 
extrasymbol statement cannot occur inside the same module. Such occurrence 
would result in an error message.

<p>
Because the output optimization is done for expressions that contain only 
symbols<a name="14999"></a>, FORM has to convert all non-symbols and negative 
powers of symbols to extra symbols<a name="15000"></a> before it starts 
the optimization. This is another reason why interference between the 
extrasymbol <a href="#substaextrasymbols" name="15002">7.45</a> statement and 
output optimizations is forbidden. When the results are printed, the 
definition of the extra symbols that are introduced this way are printed as 
well.

</p><p>
FORM has two ways to perform optimizations. The first and easiest is in 
the regular output. If one asks for optimization (by specifying the proper 
format for this) and follows this by a print statement, the output printed 
will be in optimized form. This is however just a representation of the 
expression and the next module will obtain the original expression for its 
input.

</p><p>
The more useful way to obtain an optimized output is with the #optimize 
instruction. To use this instruction properly one should understand what 
FORM does when it optimizes an expression. The whole process of 
optimization takes place inside the memory. Hence, FORM cannot optimize 
expressions that do not fit inside the CPU memory. The notation is however 
fairly compact and FORM needs far less space than for instance the 
compiler (and gives better results). The result of the optimization is 
stored inside a buffer. There is only a single optimization 
buffer<a name="15003"></a> and the preprocessor variables 
optimminvar_<a name="15004"></a> and optimmaxvar_<a name="15005"></a> 
refer to the contents of this buffer. When the #optimize instruction is 
used it loads this buffer and the contents stay around until either a 
#clearoptimize instruction is used or a new #optimize instruction is 
issued.

</p><p>
The #optimize instruction changes the original expression to its optimized 
shape in which it is usually a very short expression that refers to one or 
more extra symbols. The optimization information is automatically erased, 
and with it the expression that was optimized, when a second #optimize 
instruction is issued. Clearing the optimization buffer means that the 
information of the first expression is irretrievably lost and the contents 
of the first expression become meaningless, because its extra symbols have 
been erased. Hence if the user still needs this expression it is necessary 
to make a copy of it before optimization.

</p><p>
The optimization buffers, and the optimized expression, can be removed by 
the user with the #clearoptimize instruction. This is mandatory before the 
use of a ToPolynomial <a href="#substatopolynomial" name="15007">7.138</a> 
statement, because that may introduce new extra symbols.

</p><p>
The contents of the optimization buffer<a name="15008"></a> can be 
written with the %O combination in the format string in the #write 
instruction. This means that it is easy to write this output to file. 
Consider for instance the following program:
</p><pre>   CF  f;
   S   a,b,c;
   L   H = f(a)+f(b)+(a+b+c)^2;
   L   G = f(c)+(a+b+c)^3;
   Format O2;
   Print +f;
   .sort
   ExtraSymbols,array,w;
   Format Fortran;
   #optimize G
   #write &lt;outg.f&gt; "      REAL*8 w(`optimmaxvar_')"
   #write &lt;outg.f&gt; "%O"
   #write &lt;outg.f&gt; "      G = %e",G
   #clearoptimize
   .sort
   #optimize H
   #write &lt;outh.f&gt; "      REAL*8 w(`optimmaxvar_')"
   #write &lt;outh.f&gt; "%O"
   #write &lt;outh.f&gt; "      H = %e",H
   .end
</pre>
This program shows the two different methods and shows what is left of the 
expressions G and H. It also shows that we have to deal with the 
expressions one by one when we use the #optimize instruction, while in the 
regular printing of the output this is not needed because the expression 
itself remains in its unoptimized version.

<p>

</p><h2><a name="SECTION001201000000000000000">
Optimization options of the Format statement</a>
</h2>

<p>
The <code>Format</code> statement has a number of options to control the
code optimization. The easiest to use are the following:

</p><p>
</p><dl>
<dt><strong>O0</strong></dt>
<dd>Switches off all optimizations and prints the output the
  normal FORM way. This is the default.

<p>
</p></dd>
<dt><strong>O1</strong></dt>
<dd>Activates the lowest level of optimization. It is very fast,
  i.e., linear in the size of the expression, and gives reasonably
  efficient code.

<p>
</p></dd>
<dt><strong>O2</strong></dt>
<dd>Activates the medium level of optimization. This is slower
  than the previous setting, but usually gives better results.

<p>
</p></dd>
<dt><strong>O3</strong></dt>
<dd>Activates the highest level of optimization. It can be
  rather slow, but usually gives even better results.
</dd>
</dl>

<p>
These levels of optimization refer to some default settings of all
controlling parameters. These default values are in
Tab.&nbsp;<a href="#tbl:defaults">11.1</a>. It is also possible to set each parameter
individually to fine-tune the optimization process. The parameters
that can be set are divided in several categories. First, it is
possible to set which Horner schemes<a name="15015"></a> are tried:

</p><p>
</p><dl>
<dt><strong>Horner=(Occurrence <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> MCTS)</strong></dt>
<dd>Determines whether an 
  occurrence order<a name="15017"></a> Horner scheme is used
  or whether MCTS<a name="15018"></a><a name="15019"></a> is employed to
  find Horner schemes.

<p>
</p></dd>
<dt><strong>HornerDirection=(Forward <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> Backward <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> ForwardOrBackward <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"></strong></dt>
<dd>
  <b>ForwardAndBackward)</b>
  Forward makes that the MCTS search in the O3 option will 
  determine the outermost variables in the multivariate Horner scheme first 
  and then work its way inward.
  In the case of backward, the tree search determines the innermost variable 
  first. In some cases this can give much better results when there are 
  many common subexpressions involving a limited number of variables.
  ForwardOrBackward tries both of these
  schemes. ForwardAndBackward fills the order from both sides
  simultaneously, resulting in more options, but also a much larger
  search tree. If there are many variables, it could make the search tree 
  too large to obtain good results. 
<br>
When the option Horner=Occurrence is used the option backward will switch 
  to something called `anti-occurrence' which means that the most frequent 
  variable corresponds to the innermost brackets.
</dd>
</dl>

<p>
In the case of MCTS<a name="15022"></a><a name="15023"></a> there are 
various parameters that can control thesearch process:

</p><p>
</p><dl>
<dt><strong>MCTSConstant=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>This sets the constant <img width="26" height="29" align="MIDDLE" border="0" src="./online_files/img110.png" alt="$C_P$"> in the UCT formula that governs 
  the Monte Carlo tree search. It is supposed to be given as a real number 
  with a decimal point (no floating point notation that includes powers).
</dd>
<dt><strong>MCTSNumExpand=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>The number of times the tree
  is traversed and hence the number of times that a Horner scheme is
  constructed.
</dd>
<dt><strong>MCTSNumKeep=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>During the MCTS procedure FORM only tries to construct 
  a proper ordering for the Horner scheme, followed by a common subexpression 
  elimination in the style of the O1 option. The best `value' schemes are 
  remembered and for those a common subexpression elimination in the style of 
  the O2 option is done afterward. This second style elimination is far more 
  costly. In nearly all cases the best O2-style scheme is in the very few top 
  O1-style schemes.
</dd>
<dt><strong>MCTSNumRepeat=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>Sometimes it is more advantageous to run
  a new tree search several times, each with a smaller number of
  expansions. This parameter tells how many times we will run with a
  new tree. The total number of tree traversals is the product of 
  MCTSNumRepeat and MCTSNumExpand.
</dd>
<dt><strong>MCTSNumExpand=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value1*value2</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>Makes FORM to run `value1' trees, each with `value2' Horner scheme
  constructions. Hence this option is equivalent to the combination 
<br>
MCTSNumRepeat=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value1</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">, MCTSNumExpand=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value2</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$">.
</dd>
<dt><strong>MCTSTimeLimit=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>The maximum time in seconds
  that is used when searching through the tree.
</dd>
</dl>

<p>
The Horner methods generate a number of Horner schemes: one or two in
the case of occurrence order schemes, depending of the direction
parameter, and a number equal to MCTSNumKeep in the case of
MCTS. Next, for each stored Horner scheme other optimizations are
performed as determined by the following parameter:

</p><p>
</p><dl>
<dt><strong>Method=(None <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> CSE <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> Greedy <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> CSEGreedy)</strong></dt>
<dd>Determines what
method is used for optimizing the generated Horner schemes. 
CSE<a name="15035"></a><a name="15036"></a> performs a simple 
common subexpression elimination and Greedy performs greedy 
optimizations<a name="15037"></a> (see the paper for more 
explanations) which are more sophisticated versions of CSE's. CSEGreedy 
performs CSE followed by greedy optimizations; usually this is somewhat 
faster than just greedy optimizations, but it gives slightly worse results. 
The option None does nothing after applying the Horner scheme and is only 
useful for debugging purposes.
</dd>
</dl>

<p>
When the method of greedy optimizations is used, repeatedly all
potential optimizations are determined and a few of them are performed. The 
following parameters are used to tune the greedy method:
</p><dl>
<dt><strong>GreedyMaxPerc</strong></dt>
<dd>The percentage of the possible optimizations that is
  performed.
</dd>
<dt><strong>GreedyMinNum</strong></dt>
<dd>The minimum number of possible optimizations that
  is performed.
</dd>
<dt><strong>GreedyTimeLimit</strong></dt>
<dd>The maximum time in seconds that is spent in
  the process of greedy optimization.
</dd>
</dl>

<p>
There are also two more general settings:
</p><dl>
<dt><strong>Stats=(On <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> Off)</strong></dt>
<dd>This parameter determines whether statistics
  of the optimization are shown. Statistics are printed in the format

<p>
<tt>*** STATS: original  1P 16M 5A : 23</tt>

</p><p>
<tt>*** STATS: optimized 0P 10M 5A : 15</tt>

</p><p>
in which P indicates power operations (at least a third power), M the 
number of multiplications and A the number of additions/subtractions. The 
last number is the total number of operations in which an <img width="14" height="14" align="BOTTOM" border="0" src="./online_files/img84.png" alt="$n$">-th power counts 
as <img width="41" height="28" align="MIDDLE" border="0" src="./online_files/img85.png" alt="$n-1$"> operations.
</p></dd>
<dt><strong>TimeLimit=<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img23.png" alt="$&lt;$"><i>value</i><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img24.png" alt="$&gt;$"></strong></dt>
<dd>This set both the MCTSTimeLimit
  and the GreedyTimeLimit to half of the given value.
</dd>
</dl>

<p>
Finally there are some parameters that are of a rather specialized nature. 
They can be used for debugging<a name="15046"></a> purposes or in the case 
that one knows already what is the best Horner scheme. Their default values 
are Off.

</p><p>
</p><dl>
<dt><strong>DebugFlag=(On <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> Off)</strong></dt>
<dd><a name="optimdebugflag"></a>In the case that the value is On, the list of temporary variables is 
printed in reverse order with the string "id " in front. This makes 
them into a set of FORM substitutions that undo the optimizations. One 
can use this for instance to make sure that the optimized code is identical 
to the original.
</dd>
<dt><strong>PrintScheme=(On <img width="8" height="31" align="MIDDLE" border="0" src="./online_files/img12.png" alt="$\vert$"> Off)</strong></dt>
<dd>This option (when On) will print the Horner scheme. That is the order in 
which the variables were taken outside parentheses.
</dd>
<dt><strong>Scheme=(list of symbols)</strong></dt>
<dd>The list should be enclosed by parentheses 
and the symbols should be separated by either blanks or comma's. This 
option will fix the Horner scheme<a name="15049"></a> to be used. One 
could for instance use the output of the PrintScheme option for this to 
avoid a lengthy search when a good order of the variables is already known. 
Things become a bit tricky when extra symbols are involved. One should make 
sure that their labelling is identical to when the scheme was created! When 
extra symbols are used in their array/vector notation, one needs to 
separate them by comma's, because blank spaces next to parentheses are 
eliminated by the preprocessor. If one specifies the wrong number of 
variables, the results can be quite unpredictable. At the moment of 
compilation FORM does not know the variables that are actually used. The 
safe thing is to verify the actual variables with a testrun using the 
PrintScheme option in the O1 mode.
</dd>
</dl>

<p>
 <br></p><p></p>
<div align="CENTER"><a name="15055"></a>
<table>
<caption><strong>Table 11.1:</strong>
Values for the various parameters in the predefined
  optimization levels. OR stands for ForwardOrBackward.</caption>
<tbody><tr><td>
<div align="CENTER"><table cellpadding="3" border="1">
<tbody><tr><td align="LEFT">&nbsp;</td>
<td align="CENTER">O1</td>
<td align="CENTER">O2</td>
<td align="CENTER">O3 (default)</td>
</tr>
<tr><td align="LEFT">Horner</td>
<td align="CENTER">occurrence</td>
<td align="CENTER">occurrence</td>
<td align="CENTER">MCTS</td>
</tr>
<tr><td align="LEFT">HornerDirection</td>
<td align="CENTER">OR</td>
<td align="CENTER">OR</td>
<td align="CENTER">OR</td>
</tr>
<tr><td align="LEFT">MCTSConstant</td>
<td align="CENTER">--</td>
<td align="CENTER">--</td>
<td align="CENTER">1.0</td>
</tr>
<tr><td align="LEFT">MCTSNumExpand</td>
<td align="CENTER">--</td>
<td align="CENTER">--</td>
<td align="CENTER">1000</td>
</tr>
<tr><td align="LEFT">MCTSNumKeep</td>
<td align="CENTER">--</td>
<td align="CENTER">--</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="LEFT">MCTSNumRepeat</td>
<td align="CENTER">--</td>
<td align="CENTER">--</td>
<td align="CENTER">1</td>
</tr>
<tr><td align="LEFT">MCTSTimeLimit</td>
<td align="CENTER">--</td>
<td align="CENTER">--</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="LEFT">Method</td>
<td align="CENTER">cse</td>
<td align="CENTER">greedy</td>
<td align="CENTER">greedy</td>
</tr>
<tr><td align="LEFT">GreedyMinNum</td>
<td align="CENTER">--</td>
<td align="CENTER">10</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="LEFT">GreedyMaxPerc</td>
<td align="CENTER">--</td>
<td align="CENTER">5</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="LEFT">GreedyTimeLimit</td>
<td align="CENTER">--</td>
<td align="CENTER">0</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="LEFT">Stats</td>
<td align="CENTER">off</td>
<td align="CENTER">off</td>
<td align="CENTER">off</td>
</tr>
<tr><td align="LEFT">TimeLimit</td>
<td align="CENTER">0</td>
<td align="CENTER">0</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>

<a name="tbl:defaults"></a></div></td></tr>
</tbody></table>
</div><p></p>
<br> 

<p>
All options should be specified in a single format statement and be
separated either by commas or blank spaces. When
<code>Format Optimize</code> is used, first the default settings are taken
and then the options that are specified overwrite them. It is allowed
to have the O1, O2, O3 optimization specifications followed by
options. In that case the program first sets the values of those
specifications and then modifies according to what it encounters in
the rest of the statement.

</p><p>

</p><h1><a name="SECTION001300000000000000000"></a>
<a name="tablebase"></a>
<br>
The TableBase
</h1>

<p>
The tablebase<a name="15212"></a> statement controls a 
database<a name="15213"></a>-like structure that allows FORM to control massive 
amounts of data in the form of tables and
table<a name="15214"></a><a name="15215"></a> elements.
The contents of a tablebase are formed by one or more table declarations 
and a number of fill<a name="15216"></a> statements. These fill statements however 
are not immediately compiled. For each fill statement a special fill 
statement is generated and compiled that is of the form
</p><pre>    Fill tablename(indices) = tbl_(tablename,indices,arguments);
</pre>
The function tbl_<a name="15219"></a> is a special function to make a temporary 
table substitution. It indicates that the corresponding element can be 
found in a tablebase that has been opened. At a later stage one can tell 
FORM to see which table elements are actually needed and then only those 
will be loaded from the tablebase and compiled.

<p>
Tablebases have a special internal structure and the right hand sides of 
the fill statements are actually stored in a compressed<a name="15220"></a> 
state. These tablebases can be created with special statements and uploaded 
with any previously compiled table. Hence one can prepare a tablebase in a 
previous job, to be used at a later stage, without the time penalty of 
loading the whole table at that later stage.

</p><p>
Assume we have a file named no11fill.h that loooks like
</p><pre>    Symbols ...;
    Table,sparse,no11fill(11,N?);
    Fill no11fill(-3,1,1,1,1,1,1,1,0,0,0) = ....
    Fill no11fill(-2,1,1,1,1,1,1,1,0,0,0) = ....
    etc.
</pre>
It should be noted that only sparse<a name="15223"></a> tables can be stored 
inside a tablebase. The right hand sides could be typically a few kilobytes 
of formulas and there could be a few thousand of these fill statements. To 
make this into a tablebase one would use the program
<pre>    #-
    #include no11fill.h
    #+
    TableBase "no11.tbl" create;
    TableBase "no11.tbl" addto no11fill;
    .end
</pre>
The include<a name="15226"></a> instruction makes that FORM reads and compiles 
the table. Then the first tablebase statement creates a new tablebase file 
by the name no11.tbl. If such a file existed already, the old version will 
be lost. If one would like to add to an existing tablebase, one should use 
the `open'<a name="15227"></a> keyword. The second tablebase statement adds the 
table no11fill to the tablebase file no11.tbl. This takes care of declaring 
the table, making an index of all elements that have been filled and 
putting their right hand sides, in compressed form, into the tablebase. The 
compression is based on the zlib<a name="15228"></a> library, provided by Jean-loup 
Gailly<a name="15229"></a> and Mark Adler<a name="15230"></a> (version 
1.2.3, July 18, 2005) and it strikes a nice balance between speed and 
compression ratio.

<p>
The tablebase can be loaded in a different program as in
</p><pre>    TableBase "no11.tbl" open;
</pre>
This loads the main index<a name="15233"></a> of the file into memory.

<p>
If one would like to compile the short version of the fill statements (the 
normal action at this point) one needs to use the load<a name="15234"></a> option. 
Without any names of tables it will read the index of all tables. If tables 
are specied, only the index of those tables is taken and the proper 
tbl_ fill statements are generated:
</p><pre>    TableBase "no11.tbl" open;
    TableBase "no11.tbl" load no11fill;
</pre>

<p>
If one would like to compile<a name="15237"></a> the complete tables, rather 
than just the shortened versions, one can use the enter option as in:
</p><pre>    TableBase "no11.tbl" open;
    TableBase "no11.tbl" enter no11fill;
</pre>

<p>
Let us assume we used the load option. Hence now an occurrence of a table 
element will be replaced by the stub<a name="15240"></a>-function 
tbl_<a name="15241"></a>. In order to have this replaced by the actual right hand 
side of the original fill statement we have to do some more work. At a 
given moment we have to make FORM look which elements are actually needed. 
This is done with the TestUse<a name="15242"></a> statement as in
</p><pre>    TestUse no11fill;
</pre>
This does nothing visible. It just marks internally which elements will be 
needed and have not been entered yet.

<p>
The actual entering of the needed elements is done with the use<a name="15245"></a> 
option:</p><pre>    TableBase "no11.tbl" use;
</pre>
If many elements are needed, this statement may need some compilation time. 
Note however that this is time at a moment that it is clear that the 
elements are needed, which is entirely different from a fixed time at the 
startup of a program when the whole table is loaded as would have to be 
done before the tablebase statement existed. Usually however only a 
part of the table is needed, and in the extreme case only one or two 
elements. In that case the profit is obvious.

<p>
At this point the proper elements are available inside the system, but 
because we have two versions of the table (one the short version with 
tbl_, the other the complete elements) we have to tell FORM to apply 
the proper definitions with the `apply'<a name="15248"></a> statement.
</p><pre>    Apply;
</pre>
Now the actual rhs will be inserted.

<p>
One may wonder why this has to be done in such a `slow' way with this much 
control over the process. The point is that at the moment the table 
elements are recognized, one may not want the rhs yet, because it may be 
many lines. Yet one may want to take the elements away from the main stream 
of action. Similarly, having a table element recognized at a certain stage, 
may not mean automatically that it will be needed. The coefficient may 
still become zero during additional manipulations. Hence the user is left 
with full control over the process, even though that may lead to slightly 
more programming. It will allow for the fastest program.

</p><p>
For the name of a tablebase we advise the use of the extension 
.tbl<a name="15251"></a> to avoid confusion.

</p><p>
Note that the above scheme may need several applications, if table elements 
refer in their definition to other table elements. This can be done with a 
construction like:
</p><pre>    #do i = 1,1
        TestUse;
        .sort
        TableBase "basename.tbl" use;
        Apply;
        if ( count(tbl_,1) ) Redefine i "0";
        .sort
    #enddo
</pre>
It will stay in the loop until there are no more tbl_ functions to be 
resolved.

<p>

</p><p>
<br>
The complete syntax (more is planned):

</p><p>

</p><h1><a name="SECTION001310000000000000000"></a>
<a name="tbladdto"></a>
<br>
addto
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" addto tablename;

</p><p>
TableBase "file.tbl" addto tablename(tableelement);

</p><p>
See also open (<a href="#tblopen">12.9</a>) and create (<a href="#tblcreate">12.4</a>).

</p><p>
Adds<a name="15258"></a> the contents of a (sparse<a name="15259"></a>) table 
to a tablebase. The base must be either an existing tablebase (made 
accessible with an open statement) or a new tablebase (made available with 
a create statement). In the first version what is added is the collection 
of all fill statements that have been used to define elements of the 
indicated table, in addition to a definition of the table (if that had not 
been done yet). In the second version only individual elements of the 
indicated table are added. These elements are indicated as it should be in 
the left hand side of a fill<a name="15260"></a> statement.

</p><p>
One is allowed to specify more than one table, or more than one 
element. If one likes to specify anything after an element, it should be 
realized that one needs to use a comma for a separator, because blank 
spaces after a parenthesis are seen as irrelevant.

</p><p>
Examples:
</p><pre>    TableBase "no11.tbl" open;
    TableBase "no11.tbl" load;
    TableBase "no11.tbl" addto no11filb;
    TableBase "no11.tbl" addto no11fill(-3,1,1,1,1,2,1,1,0,0,0),
                               no11fill(-2,1,1,2,1,1,1,1,0,0,0);
</pre>

<p>

</p><h1><a name="SECTION001320000000000000000"></a>
<a name="tblapply"></a>
<br>
apply
</h1>

<p>
Syntax:

</p><p>
Apply [number] [tablename(s)];

</p><p>
See also testuse (<a href="#tbltestuse">12.10</a>) and use (<a href="#tbluse">12.11</a>).

</p><p>
The actual application<a name="15267"></a> of fill<a name="15268"></a> 
statements that were taken from the tablebases. If no tables are specified, 
this is done for all tables, otherwise only for the tables whose names are 
mentioned. The elements must have been registered as used before with the 
application of a testuse<a name="15269"></a> statement, and they must have been 
compiled from the tablebase with the use<a name="15270"></a> option of the tablebase 
statement. The number refers to the maximum number of table elements that 
can be substituted in each term. This way one can choose to replace only 
one element at a time. If no number is present all occurrences will be 
replaced. This refers also to occurrences inside function arguments. If only 
a limited number is specified in the apply statement, the occurrences 
inside function arguments have priority.

</p><p>

</p><h1><a name="SECTION001330000000000000000"></a>
<a name="tblaudit"></a>
<br>
audit
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" audit;

</p><p>
See also open (<a href="#tblopen">12.9</a>)

</p><p>
Prints<a name="15274"></a> a list of all tables and table elements that 
are defined in the specified tablebase. This tablebase needs to be opened 
first. As of the moment there are no options for the audit. Future options 
might include formatting of the output.

</p><p>

</p><h1><a name="SECTION001340000000000000000"></a>
<a name="tblcreate"></a>
<br>
create
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" create;

</p><p>
See also open (<a href="#tblopen">12.9</a>)

</p><p>
This creates<a name="15278"></a> a new file<a name="15279"></a> with the 
indicated name. This file will be initialized as a tablebase. If there was 
already a file with the given name, its old contents will be lost. If one 
would like to add to an existing tablebase, one should use the 
`open'<a name="15280"></a> option.

</p><p>

</p><h1><a name="SECTION001350000000000000000"></a>
<a name="tblenter"></a>
<br>
enter
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" enter;

</p><p>
TableBase "file.tbl" enter tablename(s);

</p><p>
See also open (<a href="#tblenter">12.5</a>) and load (<a href="#tblload">12.6</a>).

</p><p>
Scans<a name="15285"></a> the specified tablebase and (in the first 
variety) creates for all elements of all tables in the tablebase a 
fill<a name="15286"></a> statement with its full contents. This is at times faster 
than reading the fill statements from a regular input 
file<a name="15287"></a>, because the tablebase has its contents 
compressed<a name="15288"></a>. 
Hence this costs less file access time. When table names are specified, 
only the tables that are mentioned have their elements treated this way.

</p><p>
The tablebase must of course be open for its contents to be 
available.

</p><p>
If one would like FORM to only see what elements are available 
and load that information one should use the load<a name="15289"></a> option.

</p><p>

</p><h1><a name="SECTION001360000000000000000"></a>
<a name="tblload"></a>
<br>
load
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" load;

</p><p>
TableBase "file.tbl" load tablename(s);

</p><p>
See also open (<a href="#tblopen">12.9</a>) and enter (<a href="#tblenter">12.5</a>).

</p><p>
Scans<a name="15294"></a> the index of the specified tablebase and (in 
the first variety) creates for all elements of all tables in the tablebase 
a fill<a name="15295"></a> statement of the type
</p><pre>    Fill tablename(indices) = tbl_(tablename,indices,arguments);
</pre>
This is the fill statement that will be used when elements of one of these 
tables are encountered. The function tbl_ is called the (table)stub 
function. When table names are specified, only the tables that are 
mentioned have their elements treated this way.

<p>
The tablebase must of course be open for its contents to be 
available.

</p><p>
If one would like to actually load the complete fill statements, 
one should use the enter option.

</p><p>

</p><h1><a name="SECTION001370000000000000000"></a>
<a name="tbloff"></a>
<br>
off
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" off subkey;

</p><p>
See also addto (<a href="#tbladdto">12.1</a>) and off (<a href="#tblon">12.8</a>).

</p><p>
Currently<a name="15302"></a> only the subkey `compress'<a name="15303"></a> 
is recognized. It makes sure that no compression is used when elements are 
being stored in a tablebase with the addto<a name="15304"></a> option. This could 
be interesting when the right hand sides of the fill statements are 
relatively short.

</p><p>

</p><h1><a name="SECTION001380000000000000000"></a>
<a name="tblon"></a>
<br>
on
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" on subkey;

</p><p>
See also addto (<a href="#tbladdto">12.1</a>) and off (<a href="#tbloff">12.7</a>).

</p><p>
Currently<a name="15309"></a> only the subkey `compress'<a name="15310"></a> is 
recognized. It makes sure that compression with the gzip<a name="15311"></a> 
algorithms is used when elements are being stored in a tablebase with the 
addto<a name="15312"></a> option. This is the default.

</p><p>

</p><h1><a name="SECTION001390000000000000000"></a>
<a name="tblopen"></a>
<br>
open
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" open;

</p><p>
See also create (<a href="#tblcreate">12.4</a>)

</p><p>
This opens<a name="15316"></a> an existing file with the indicated name. 
It is assumed that the file has been created<a name="15317"></a> with the 
`create' option in a previous FORM program. It gives the user access to the 
contents of the tablebase. In addition it allows the user to add to its 
contents.

</p><p>
Just like with other files, FORM will look for the file in in 
current directory and in all other directories mentioned in the environment 
variable `FORMPATH'<a name="15318"></a> (see for instance the 
#call<a name="15319"></a> (<a href="#precall">3.9</a>) and the #include<a name="15321"></a> 
(<a href="#preinclude">3.33</a>) instructions).

</p><p>

</p><h1><a name="SECTION0013100000000000000000"></a>
<a name="tbltestuse"></a>
<br>
testuse
</h1>

<p>
Syntax:

</p><p>
TestUse;

</p><p>
TestUse tablename(s);

</p><p>
See also use (<a href="#tbluse">12.11</a>).

</p><p>
Tests<a name="15326"></a> for all elements of the specified tables (if 
no tables are mentioned, this is done for all tables) whether they are used 
in a stub<a name="15327"></a> function tbl_<a name="15328"></a>. If so, this indicates 
that these elements must be compiled from a tablebase, provided this has 
not been done already. The compilation will have to be done at a time, 
specified by the user. This can be done with the use<a name="15329"></a> option. All 
this statement does is set some flags in the internals of FORM for the 
table elements that are encountered in the currently active expressions.

</p><p>

</p><h1><a name="SECTION0013110000000000000000"></a>
<a name="tbluse"></a>
<br>
use
</h1>

<p>
Syntax:

</p><p>
TableBase "file.tbl" use;

</p><p>
TableBase "file.tbl" use tablename(s);

</p><p>
See also testuse (<a href="#tbltestuse">12.10</a>) and apply (<a href="#tblapply">12.2</a>).

</p><p>
Causes<a name="15334"></a> those elements of the specified tables to be 
compiled, that a previous testuse<a name="15335"></a> statement has encountered 
and that have not yet been compiled before. If no tables are mentioned this 
is done for all tables. The right hand sides of the definition of the table 
elements will not yet be substituted. That is done with an 
apply<a name="15336"></a> statement.

</p><p>

</p><p>

</p><h1><a name="SECTION001400000000000000000"></a>
<a name="dictionaries"></a>
<br>
Dictionaries
</h1>

<p>
At times one would like to manipulate the output to facilitate further 
processing. A standard example is that the output formula should be 
included in a L<sup><small>A</small></sup>T<small>E</small>X file. Also the use of terms in the output as 
patterns with wildcards in the LHS of an id-statements needs textual 
translation. Another example is the representation of 
fractions in a numerical program that works with floating point numbers. 
Complete solutions for such problems are not included in FORM, but with 
the partial solution of `dictionaries'<a name="15516"></a> one can do quite 
a lot already.

</p><p>
In FORM a dictionary is a collection of `words'<a name="15518"></a> together with 
their translation<a name="15519"></a>. The word can be a number, a variable, 
a function with its arguments or a special output token like a 
multiplication sign or a power indicator. The translation can be any 
string. Generic patterns have not been implemented. That would be more like 
grammar and involves special complications. As shown later, currently there 
is one exception to this rule.

</p><p>
A dictionary is defined with the preprocessor<a name="15520"></a> 
instruction
</p><pre>    #opendictionary name
</pre>
in which `name' is the name of the dictionary. There can be more 
dictionaries, provided they have different names. It is allowed to open 
already existing dictionaries. Only one dictionary can be open at a given 
time. Dictionaries are closed with the instruction<a name="15523"></a>
<pre>    #closedictionary
</pre>
and because there can be only one open dictionary, it is clear which 
dictionary should be closed.

<p>
A dictionary is opened to add words to it. This is done with the #add 
instruction<a name="15526"></a> as in
</p><pre>    #add x1: "x_1"
    #add *: "\ "
    #add mu: "\mu"
</pre>
which would tell the system that when the dictionary is in use, the 
variable <code>x1</code> should be printed as the string <code>x_1</code> and a 
multiplication sign should become a backslash character followed by a 
blank space. The (index) mu would be printed as the string <code>\mu</code>.

<p>
A dictionary can be used<a name="15529"></a> with the
</p><pre>    #usedictionary name &lt;(options)&gt;
</pre>
instruction. At the moment a dictionary is being used there cannot be any 
open dictionaries. Hence we can stop using a dictionary with the
<pre>    #closedictionary
</pre>
instruction<a name="15534"></a> without running into inconsistencies. 
The options control partial use of a dictionary, as for instance only for 
individual variables, or only for numbers. They can also control whether 
translations should be made inside function arguments or inside dollar 
variables (when used as preprocessor variables).

<p>
What words are allowed?
</p><dl>
<dt><strong>variable</strong></dt>
<dd>This can be the name of a symbol, a vector, an index or a 
function (this includes commuting functions, non-commuting functions, 
tensors and tables).
</dd>
<dt><strong>number</strong></dt>
<dd>This must be a positive integer number.
</dd>
<dt><strong>fraction</strong></dt>
<dd>This must be a positive rational number.
</dd>
<dt><strong>special character</strong></dt>
<dd>Currently this can be the multiplication sign 
(<code>*</code>), or the power sign (<code>^</code> or <code>**</code>).
</dd>
<dt><strong>a range</strong></dt>
<dd>Indicated between parentheses, this is a range<a name="15536"></a> 
of extra symbols. There can be more than one range.
</dd>
<dt><strong>a function with arguments</strong></dt>
<dd>This would be a complete function subterm. 
</dd>
</dl>

<p>
The options in the #usedictionary should be enclosed between parentheses 
and separated by comma's. They can be:
</p><dl>
<dt><strong>allnumbers</strong></dt>
<dd>All numbers will be looked up in the dictionary.
</dd>
<dt><strong>integersonly</strong></dt>
<dd>Only integer numbers will be looked up.
</dd>
<dt><strong>nonumbers</strong></dt>
<dd>Numbers will not be looked up.
</dd>
<dt><strong>numbersonly</strong></dt>
<dd>Only numbers will be looked up.
</dd>
<dt><strong>novariables</strong></dt>
<dd>Loose variables will not be looked up.
</dd>
<dt><strong>variablesonly</strong></dt>
<dd>Only loose variables will be looked up.
</dd>
<dt><strong>nospecials</strong></dt>
<dd>Specials (multiplication signs and power signs) will 
not be looked up.
</dd>
<dt><strong>specialsonly</strong></dt>
<dd>Only specials (multiplication signs and power signs) will 
be looked up.
</dd>
<dt><strong>nofunwithargs</strong></dt>
<dd>Functions with arguments will not be looked up.
</dd>
<dt><strong>funwithargsonly</strong></dt>
<dd>Only functions with arguments will be looked up.
</dd>
<dt><strong>warnings</strong></dt>
<dd>Warnings<a name="15539"></a> concern the look up of 
numbers. If a fortran or C format is being used and the dictionary cannot 
be used in such a way that floating point notation and/or decimal points 
can be avoided, a warning will be given.
</dd>
<dt><strong>nowarnings</strong></dt>
<dd>No floating point warnings are given.
</dd>
<dt><strong>infunctions</strong></dt>
<dd>Substitutions are also made inside function arguments.
</dd>
<dt><strong>notinfunctions</strong></dt>
<dd>No substitutions are made inside function arguments.
</dd>
<dt><strong>$</strong></dt>
<dd>Substitutions are made also when dollar variables are expanded. 
The default is that this is not done.
</dd>
</dl>
The defaults are that all potential objects are looked up (also inside 
function arguments) and no warnings are given.

<p>
The use is best illustrated with a few examples.
</p><pre>    Symbols x1,y2,z3,N;
    Indices mu,nu,ro,si;
    Tensor tens;
    CFunction S,R,f;
    ExtraSymbols array w;
    #OpenDictionary test
      #add x1: "x_1"
      #add y2: "y^{(2)}"
      #add z3: "{\cal Z}"
      #add *: " "
      #add S(R(1),N): "S_1(N)"
      #add S(R(2),N): "S_2(N)"
      #add S(R(1,1),N): "S_{1,1}(N)"
      #add f: "\ln"
      #add mu: "\mu"
      #add nu: "\nu"
      #add ro: "\rho"
      #add si: "\sigma"
      #add tens: "T"
    #CloseDictionary
    Local F = x1*y2*z3
         + S(R(1),N) + S(R(1,1),N) + S(R(2),N)
         + tens(mu,nu,ro,si) + f(x1+1);
    #usedictionary test
    Print +s;
    .end
</pre>
This program gives for its output
<pre>       F =
           + x_1 y^2 {\cal Z}
           + T(\mu,\nu,\rho,\sigma)
           + S_1(N)
           + S_{1,1}(N)
           + S_2(N)
           + \ln(1 + x_1)
          ;
</pre>
Of course, there is nothing here that could not have been done with a good 
text editor, but having this inside the FORM program makes that if there 
are changes in the FORM program, it will be less work to implement them in 
the eventual L<sup><small>A</small></sup>T<small>E</small>X files.

<p>
Things become different when numerical<a name="15548"></a> output is 
involved. Take for instance the fraction <img width="28" height="31" align="MIDDLE" border="0" src="./online_files/img111.png" alt="$1/3$"> inside a 
FORTRAN<a name="15549"></a> program. 
Using the option
</p><pre>    Format Fortran;
</pre>
one would obtain
<pre>    1./3.
</pre>
and with<a name="15554"></a>
<pre>    Format DoubleFortran;
</pre>
one would obtain
<pre>    1.D0/3.D0
</pre>
while using<a name="15559"></a>
<pre>    Format QuadFortran;
</pre>
one would obtain
<pre>    1.Q0/3.Q0
</pre>
which means that one might have three varieties of the same program, 
depending on the precision in which one would like run it. It would be far 
better to have a single version and only determine in the make file what 
the precision should be. The FORTRAN code for such a program could look 
like
<pre>      REAL one,three,third
      PARAMETER (one=1,three=3,third=one/three)
</pre>
after which one should either use the name 'third' or a construction like 
'one/three'. Let us take a simple program like
<pre>    Symbol x,n;
    Format DoubleFortran;
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    Print;
    .end
      F =
     &amp; 1.D0/7.D0*x + 1.D0/2.D0*x**2 + x**3 + 5.D0/4.D0*x**4 + x**5 + 1.D
     &amp; 0/2.D0*x**6 + 1.D0/7.D0*x**7 + 1.D0/56.D0*x**8
</pre>
If we define a dictionary we can make this into
<pre>    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "TWO"
      #add 5: "FIVE"
      #add 7: "SEVEN"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers
    Print;
    .end
      F =
     &amp; 1/SEVEN*x + 1/TWO*x**2 + x**3 + FIVE/4*x**4 + x**5 + 1/TWO*x**6
     &amp;  + 1/SEVEN*x**7 + 1.D0/56.D0*x**8
</pre>
one can see that some of the numbers have been replaced by text strings. In 
particular these are the numbers 2, 5 and 7. The output is now presented in 
such a way that the compiler can do the rest, provided we do this with all 
numbers that occur, and we feed the proper information to the compiler.

<p>
One can also replace complete fractions as in
</p><pre>    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "TWO"
      #add 5: "FIVE"
      #add 7: "SEVEN"
      #add 1/2: "HALF"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers
    Print;
    .end
      F =
     &amp; 1/SEVEN*x + HALF*x**2 + x**3 + FIVE/4*x**4 + x**5 + HALF*x**6 + 
     &amp; 1/SEVEN*x**7 + 1.D0/56.D0*x**8
</pre>
because the fractions take precedence.

<p>
The next question is how one makes sure to have all numbers that need 
replacement? For that one can use the warnings option:
</p><pre>    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "TWO"
      #add 5: "FIVE"
      #add 7: "SEVEN"
      #add 1/2: "HALF"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers (warnings)
    Print;
    .end

Time =       0.00 sec    Generated terms =          8
               F         Terms in output =          8
                         Bytes used      =        204

      F =
     &amp; 1/SEVEN*x + HALF*x**2 + x**3 + FIVE/4*x**4 + x**5 + HALF*x**6 + 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Could not translate coefficient with dictionary numbers&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
&lt;&lt;&lt;
     &amp; 1/SEVEN*x**7 + 1.D0/56.D0*x**8
</pre>
In this case the line after the warning contains a fraction that was not 
substituted. This allows one to add either <img width="20" height="14" align="BOTTOM" border="0" src="./online_files/img112.png" alt="$56$"> or <img width="36" height="31" align="MIDDLE" border="0" src="./online_files/img113.png" alt="$1/56$"> to the 
dictionary. This gives the program
<pre>    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "cd2"
      #add 5: "cd5"
      #add 7: "cd7"
      #add 56: "cd56"
      #add 1/2: "c1d2"
      #add 5/4: "c5d4"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers (warnings)
    Print;
    .end
      F =
     &amp; 1/cd7*x + c1d2*x**2 + x**3 + c5d4*x**4 + x**5 + c1d2*x**6 + 1/
     &amp; cd7*x**7 + 1/cd56*x**8
</pre>
Here we have selected a different notation that allows extension easily. 
A good way to do this now is to put the dictionary in a file numbers.hh and 
the corresponding FORTRAN definitions in a file numbers.h and then include 
these files in the proper places. The numbers.hh file would be
<pre>#OpenDictionary numbers
  #add 2: "cd2"
  #add 5: "cd5"
  #add 7: "cd7"
  #add 56: "cd56"
  #add 1/2: "c1d2"
  #add 5/4: "c5d4"
#CloseDictionary
</pre>
and the numbers.h file would be
<pre>      REAL cd2,cd5,cd7,cd56,c1d2,c5d4
      PARAMETER (cd2=2,cd5=5,cd7=7,cd56=56,c1d2=1/cd2,c5d4=cd5/4)
</pre>
and when the dictionary file is updated one may update the FORTRAN file 
simultaneously.

<p>
Setting the precision of the declaration REAL<a name="15580"></a> can be done by 
compiler options. These may depend on the compiler. One should consult the 
manpages.

</p><p>
Printing the extra symbols<a name="15581"></a> (<a href="#substaextrasymbols">7.45</a>) 
may be a bit trickier. A range<a name="15583"></a> is indicated with 
a pair of parentheses enclosing one or two (positive) numbers. If there are 
two numbers, they should be separated by a comma. There can be more than 
one range. In the substitution one can use the wildcards <code>%#</code> and 
<code>\verb</code>wildcard indicates the number of the symbol and the second starts it 
counting with 1 from the beginning of the range.
</p><pre>    Symbol x;
    CFunction f;
    #OpenDictionary ranges
      #add (1,2): "w(%#)"
      #add (3): "ww(%#)"
      #add (4,6): "www(%@)"
    #CloseDictionary
    Local F = &lt;f(1)*x^1&gt;+...+&lt;f(6)*x^6&gt;;
    ToPolynomial;
    Print;
    .sort

   F =
      x*Z1_ + x^2*Z2_ + x^3*Z3_ + x^4*Z4_ + x^5*Z5_ + x^6*Z6_;

    #UseDictionary ranges
    Print;
    .end

   F =
      x*w(1) + x^2*w(2) + x^3*ww(3) + x^4*www(1) + x^5*www(2) + x^6*www(3);
</pre>

<p>
The use of the dictionaries in dollar variables can best be shown with an 
example that has much in common with graph theory. Assume we have an 
expression that contains all topologies we are interested in, with a 
notation for the momenta. The function vx represents a vertex and we use it 
as a symmetric function. Here we show two topologies from massless two-loop 
propagators:
</p><pre>        +vx(p0,p1,-p4)*vx(-p1,p2,p5)*vx(q0,-p2,-p3)*vx(p4,p3,-p5)*topo(1)
        +vx(p0,p1,p2)*vx(-p1,p3,p4)*vx(q0,-p2,-p3,-p4)*topo(2)
</pre>
where the q0 momentum is taken to be -p0. The problem is what happens when 
in a diagram of topology one, one of the lines is removed. If for instance 
the p1 line is removed, we will end up with the second topology, but the 
question is: how should we relabel the momenta to obtain the notation of 
topology 2. Taking out p1 gives us:
<pre>        +vx(p0,-p4,p2,p5)*vx(q0,-p2,-p3)*vx(p4,p3,-p5)*topo(1)
</pre>
and to see what renaming we need is usually a major source of errors.
We can do this automatically if we can substitute the second topology into 
the remainder of the first using proper wildcards and storing the matches 
in dollar variables. This can be done with a dictionary:
<pre>    #OpenDictionary match
        #add p0: "p0?{p0,q0}$p0"
        #add q0: "q0?{p0,q0}$q0"
        #do i = 1,5
            #add p`i': "p`i'?$p`i'"
        #enddo
    #CloseDictionary
</pre>
We put the various candidate topologies that could match, one by one, into 
the variable $child as in (after using brackets on the expression with the 
topologies):
<pre>    #$child = Topologies[topo(2)];
</pre>
but generating an id-statement from it would be very laborious without the 
dictionaries:
<pre>    id `$Orig' = 1;
</pre>
would result in:
<pre>    id vx(-p2,-p3,q0)*vx(-p4,p0,p2,p5)*vx(-p5,p3,p4) = 1;
</pre>
but with the dictionary activated as in
<pre>    #inside $child
     #UseDictionary match($)
      id `$Orig' = 1;
     #CloseDictionary
    #endinside
</pre>
the generated code is
<pre>    id vx(-p2?$p2,-p3?$p3,q0?{p0,q0}$q0)*vx(-p4?$p4,p0?{p0,q0}$p0,
       p2?$p2,p5?$p5)*vx(-p5?$p5,p3?$p3,p4?$p4) = 1;
</pre>
and from the dollar variables we can generate a statement with the the 
renumbering
<pre>    id topo(1) = topo(2)*replace_(p0,-p0,p1,q1,p2,-p2,p3,-p1,p4,p3,p5,-p4);
</pre>
We used <!-- MATH
 $p_1\rightarrow q_1$
 -->
<img width="58" height="28" align="MIDDLE" border="0" src="./online_files/img114.png" alt="$p_1\rightarrow q_1$"> as initialization before the pattern matching 
and <img width="55" height="28" align="MIDDLE" border="0" src="./online_files/img115.png" alt="$p_0 = q_0$"> we can replace by <img width="56" height="28" align="MIDDLE" border="0" src="./online_files/img116.png" alt="$p_0 = p_0$">. The <img width="18" height="28" align="MIDDLE" border="0" src="./online_files/img117.png" alt="$q_1$"> should be replaced 
by means of momentum conservation, but that goes beyond the scope of this 
example.

<p>
It should be clear from the above that the dictionaries are the beginning 
of a new development. One should expect more capabilities in the future and 
suggestions are highly appreciated, provided they lead to something that 
can be implemented in a reasonable amount of time. Hence, for instance, 
there will not be a complete L<sup><small>A</small></sup>T<small>E</small>X output format that can take line length 
into account.

</p><p>

</p><h1><a name="SECTION001500000000000000000"></a>
<a name="gammaalgebra"></a>
<br>
Dirac algebra
</h1>

<p>
Для исаользования в физике высоких энергий<a name="15663"></a> 
FORM оснащен наьором встроенных функций. 
Это гамма-матрицы<a name="15664"></a> алгебры Дирака<a name="15665"></a>,  
которые всегда обозначаются g_<a name="15666"></a>. 
Гамма-матрицы удовлетворяют соотношениям:
</p><pre>     {g_(j1,mu),g_(j1,nu)} = 2 * d_(mu,nu)
     [g_(j1,mu),g_(j2,nu)] = 0    j1 не равен j2.
</pre>
Первый аргумент - это такназываемый спиновый индекс (индекс спиновой линии)<a name="15669"></a>. 
Когда гамма-матрицы имеют одну и туже спиновую линию, 
Они принадлежат одной и той же алгебре Дирака и коммутируют с другими матрицами других алгебр Дирака. 
Индексы mu и nu - по пространству времени, и следовательно обычно пробегают значения от 1 до 4 
(или от 0 до 3 в метрике Бьеркина &amp; Дрелла<a name="15670"></a>). 
Полностью антисимметричное произведение e_(m1,m2,...,mn)g_(j,m1)...g_(j,mn)/n! определяется как gamma5 или g5_(j). 
Нотация 5<a name="15671"></a> берет свои корни в 4-мерном пространстве-времени. 
Единичная матрица обозначается gi_(j). 
В четырех измерениях базис алгебры Дирака может задаваться как: 
<pre>     gi_(j)
     g_(j,mu)
     [g_(j,mu),g_(j,nu)]/2
     g5_(j)*g_(j,mu)
     g5_(j)
</pre>
При другом количестве измерений этот базис соответственно отличается. 
Мы введем следующие соглашения: 
<pre>     g6_(j) = gi(j) + g5_(j)     (from Schoonschip)
     g7_(j) = gi(j) - g5_(j)
     g_(j,mu,nu) = g_(j,mu)*g_(j,nu)  (from Reduce)
     g_(j,mu,nu,.....,ro,si) =
                      g_(j,mu,nu,.....,ro)*g_(j,si)
     g_(j,5_) = g5_(j)
     g_(j,6_) = g6_(j)
     g_(j,7_) = g7_(j)
</pre>
Общая операция над гамма-матрицами - это получение следа строки<a name="15676"></a> гамма-матриц. 
Это делается конструкцией:

<p>
<table width="181">
<tbody><tr><td>trace4<a name="15749"></a>, j
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Получение следа в 4 измерениях комбинации всех гамма-матриц со спиновой линией j в текущем терме. 
Любые некоммутирующие объекты, которые могут встретиться между этими гамма-матрицами, игнорируются. 
Ответственностью пользователя является вызов этой конструкции только после того как все функции над соответствующими функциями будут выполнены. 
Четверка ссылается на специальные трюки<a name="15756"></a>, которые могут применяться в четырех измерениях. 
Это приводит к относительно компактным выражениям. 
Для полного синтаксиса, проконсультируйтесь с <a href="#substatrace">7.141</a></td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>tracen<a name="15764"></a>, j
</td></tr>
</tbody></table>
<br>
<table width="544">
<tbody><tr><td>Берет след в пространстве с незаданным числом размерностей. 
Считается, что число измерений - четное. 
Следы вычисляются только с использованием антикоммутационных свойств сатриц. 
Т.к. число измерений не задано, появление g5_(j) приводит к фатальной ошибке. 
В общем выражения, генерируемые этим способом длиннее чем четырехмерные выражения. 
Для полного синтаксиса, консультируйтесь с <a href="#substatracen">7.142</a></td></tr>
</tbody></table>
    <br>

</p><p>
Можно изменить значение следа единичной<a name="15686"></a> матрицы gi_(j).<a name="15687"></a> 
Еге значение по умолчанию 4, но при использовании конструкции (см. <a href="#substaunittrace">7.147</a>)
</p><pre>    unittrace value;
</pre>
оно может быть изменено. Значение может быть любым положительным коротким числом 
(<img width="42" height="33" align="MIDDLE" border="0" src="./online_files/img54.png" alt="$&lt; 2^{15}$"> на 32<a name="15692"></a> битных машинах 
и <img width="42" height="33" align="MIDDLE" border="0" src="./online_files/img55.png" alt="$&lt; 2^{31}$"> на 64<a name="15694"></a> битных машинах) 
и отдельным симолом за исключением i_.<a name="15695"></a>

<p>
Есть несколько опций для 4-мерных следов. 
Эти опции находят свои истоки в соотношениях Chisholm-а<a name="15696"></a> которые действительны для 4 измерений, но не при любом количестве измерений. 
Эти соотношения можно найти в литературе. Они задаются как:
<br>
</p><div align="RIGHT">

<!-- MATH
 \begin{equation}
\gamma_\mu Tr[\gamma_\mu S] = 2(S + S^R)
\end{equation}
 -->
<table width="100%" align="CENTER">
<tbody><tr valign="MIDDLE"><td align="CENTER" nowrap=""><img width="164" height="29" border="0" src="./online_files/img118.png" alt="\begin{displaymath}
\gamma_\mu Tr[\gamma_\mu S] = 2(S + S^R)
\end{displaymath}"></td>
<td width="10" align="RIGHT">
(14.1)</td></tr>
</tbody></table>
<br clear="ALL"></div><p></p>
в которых S - строка гамма-матриц с нечетным количеством матриц (<img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> содержит четное количество гамма-матриц). 
<img width="25" height="17" align="BOTTOM" border="0" src="./online_files/img45.png" alt="$S^R$"> строка в обратном порядке. 
Это соотношение может использоваться для комбинирования матриц с общими индексами. 
Это соотношение используется по умолчанию для вычисления trace4<a name="15699"></a>. 
Если его требуется выключить, добавьте одну дополнительную опцию `nocontract':
<pre>    trace4,nocontract,j;
</pre>
Опция `contract'<a name="15702"></a> установлена по умолчанию, 
но может использоваться для улучшения читабельности программ. 
Вторая опция, которая использует это соотношение это опция `symmetrize'<a name="15703"></a>. 
Often it happens that there are two or more common indices in two spin lines. 
Without the symmetrize option (or with the 
`nosymmetrize'<a name="15704"></a> option) the first of these indices is 
taken and the relation is applied to it. With the `symmetrize' option 
the average over all possibilities is taken. This means of course that if 
there are two common indices the amount of work is doubled. There is 
however a potentially large advantage. In some traces that involve the use of 
<img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> the use of automatic algorithms results often in an avalanche of 
terms with a single Levi-Civita tensor, while symmetry arguments can show 
that these terms should add up to zero. By working out the traces in a more 
symmetric fashion FORM is often capable of eliminating all or nearly all of 
these Levi-Civita tensors. Normally such an elimination is rather 
complicated. It involves relations that have so far defied proper 
implementation, even though people have been looking for such algorithms 
already for a long time. Hence the use of the symmetry from the beginning 
seems at the moment the best bet.

<p>
It is possible to only apply the Chisholm<a name="15705"></a> identity without 
taking the trace. This is done with the chisholm statement (see 
<a href="#substachisholm">7.14</a>). 

</p><p>
The n dimensional traces can use a special feature, when the declaration 
of the indices involved will allow it. When an index has been declared 
as n-dimensional and the dimension is followed by a second symbol as in
</p><pre>    symbols n,nn;
    index mu=n:nn;
</pre>
and if the index <code>mu</code> is a contracted index in a single 
n-dimensional trace, then the formula for this trace can be shortened by 
using <code>nn</code> (one term) instead of the quantity <img width="54" height="31" align="MIDDLE" border="0" src="./online_files/img4.png" alt="$(n-4)$"> (two terms). 
This can make the taking of the n-dimensional traces significantly 
faster.

<p>
<br>
<br>

</p><p>
Algorithms<a name="15710"></a>:

</p><p>
FORM has been equipped with several built in rules to keep the 
number of generated terms to a minimum during the evaluation of a 
trace. These rules are:

</p><p>
</p><dl>
<dt><strong>rule 0</strong></dt>
<dd>Strings with an odd number of matrices (gamma5 counts for an even number 
    of matrices) have a trace that is zero, when using trace4 or tracen.
</dd>
<dt><strong>rule 1</strong></dt>
<dd>A string of gamma matrices is first scanned for adjacent 
matrices that have the same contractable index, or that are contracted with 
the same vector. If such a pair is found, the relations
<pre>      g_(1,mu,mu) = gi_(1)*d_(mu,mu)
      g_(1,p1,p1) = gi_(1)*p1.p1
</pre>
are applied.
</dd>
<dt><strong>rule 2</strong></dt>
<dd>Next there is a scan for a pair of the same contractable 
indices that has an odd number of other matrices in between. This is done 
only for 4 dimensions (trace4) and the dimension of the indices must be 4. 
If found, the Chisholm<a name="15714"></a> identity is applied:
<pre>      g_(1,mu,m1,m2,...mn,mu) = -2*g_(1,mn,...,m2,m1)
</pre>
</dd>
<dt><strong>rule 3</strong></dt>
<dd>Then (again only for trace4) there is a search for a pair 
of matrices with the same 4 dimensional index and an even number of 
matrices in between. If found, one of the following variations of the 
Chisholm<a name="15717"></a> identity is applied:
<pre>      g_(1,mu,m1,m2,mu) = 4*gi_(1)*d_(m1,m2)
      g_(1,mu,m1,m2,...,mj,mn,mu) =
                      2*g_(1,mn,m1,m2,...,mj)
                     +2*g_(1,mj,...,m2,m1,mn)
</pre>
</dd>
<dt><strong>rule 4</strong></dt>
<dd>Then there is a scan for pairs of matrices that have the 
same index or that are contracted with the same vector. If found, the 
identity:
<pre>      g_(1,mu,m1,m2,...,mj,mn,mu) =
                2*d_(mu,mn)*g_(1,mu,m1,m2,...,mj)
               -2*d_(mu,mj)*g_(1,mu,m1,m2,...,mn)
                ....
             -/+2*d_(mu,m2)*g_(1,mu,m1,...,mj,mn)
             +/-2*d_(mu,m1)*g_(1,mu,m2,...,mj,mn)
             -/+2*d_(mu,mu)*g_(1,m1,m2,...,mj,mn)
</pre>
is used to 'anticommute'<a name="15722"></a> these identical 
objects till they become adjacent and can be eliminated with the 
application of rule 1. In the case of an n-dimensional trace and when 
<code>mu</code> is an index (it might also be a vector in the above formula) for 
which the definition of the dimension involved two symbols, there is a 
shorter formula. In that case the last three terms can be combined into two 
terms:
<pre>     -/+(n-4)*g_(1,m1,m2,...,mj,mn)
     -/+4*d_(m1,m2)*g_(1,m3,m4,...,mj,mn)
</pre>
It should be clear now that this formula is only superior, when 
there is a single symbol to represent <img width="54" height="31" align="MIDDLE" border="0" src="./online_files/img4.png" alt="$(n-4)$">. After this all gamma 
matrices that are left have a different index or are contracted with 
different vectors. These are treated using:
</dd>
<dt><strong>rule5</strong></dt>
<dd>Traces in 4 dimensions for which all gamma matrices have 
a different index, or are contracted with a different four-vector are 
evaluated using the reduction formula
<pre>      g_(1,mu,nu,ro) =
                 g_(1,5_,si)*e_(mu,nu,ro,si)
                +d_(mu,nu)*g_(1,ro)
                -d_(mu,ro)*g_(1,nu)
                +d_(nu,ro)*g_(1,mu)
</pre>
For tracen the generating algorithm is based on the generation of all 
possible pairs of indices/vectors that occur in the gamma matrices in 
combination with their proper sign. When the dimension is not specified, 
there is no shorter expression.
</dd>
</dl>

<p>
Remarks:

</p><p>
When an index is declared to have dimension n and the command trace4 is 
used, the special 4 dimensional rules 2 and 3 are not applied to this 
index. The application of rule 1 or 4 will then give the correct 
results. The result will nevertheless be wrong due to rule 5, when there 
are at least 10 gamma matrices left after the application of the first 4 
rules, as the two algorithms in rule 5 give a difference only, when 
there are at least 10 gamma matrices. For counting gamma matrices the 
<img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> counts for 4 matrices with respect to this rule. The result 
is unpredictable, when both indices in four dimensions and indices in n 
dimensions occur in the same string of gamma matrices. Therefore one 
should be very careful, when using the four dimensional trace under the 
condition that the results need to be correct in n dimensions. This is 
sometimes needed, when a <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> is involved. The tracen-statement 
will not allow the presence of a <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$">. In general it is best to 
emulate n-dimensional traces with a <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> separately. The eventual 
trace, with all matrices with a different index, can be generated with 
the use of the 'distrib_' function:
</p><pre>    *
    *   Symmetric trace of a gamma5 and 12 regular matrices
    *
    I   m1,...,m12;
    F   G5,g1,g2;
    L   F = G5(m1,...,m12);
    id  G5(?a) = distrib_(-1,4,g1,g2,?a);
    id  g1(?a) = e_(?a);
    id  g2(?a) = g_(1,?a);
    tracen,1;
    .end

Time =       1.07 sec    Generated terms =      51975
                F        Terms in output =      51975
                         Bytes used      =     919164
</pre>
This rather symmetric result is in contrast to the 4-dimensional result 
which is much shorter, but it is very unsymmetric:
<pre>    *
    *   Regular trace of a gamma5 and 12 regular matrices
    *
    I   m1,...,m12;
    L   F = g_(1,5_,m1,...,m12);
    trace4,1;
    .end

Time =       0.02 sec    Generated terms =       1053
                F        Terms in output =       1029
                         Bytes used      =      20284
</pre>
The precise workings of the distrib_<a name="15732"></a> function is given in 
<a href="#fundistrib">8.12</a>.

<p>
One should be careful when using projection operators of spinors. The 
sloppy way is to write
</p><pre>    (g_(1,p)+m)
</pre>
but technically this is not correct. The correct way is
<pre>    (g_(1,p)+m*gi_(1))
</pre>
to avoid the possibility that in the end a trace will be taken over a term 
that does not have any gamma matrix. If the projection operator is however 
multiplied by other gamma matrices, it makes no difference whether the unit 
matrix is present. That is why the sloppy notation will almost always give 
the correct result. Almost always....

<p>

</p><h1><a name="SECTION001600000000000000000"></a>
<a name="metric"></a>
<br>
A few notes on the use of a metric
</h1>

<p>
When FORM was designed, it was decided to make its syntax more or 
less independent of a choice of the metric<a name="15828"></a>. Hence statements 
and facilities that programs like Schoonschip<a name="15829"></a> or 
REDUCE<a name="15830"></a> provide but which depend on the choice of a metric 
have been left out. Instead there are facilities to implement any choice of 
the metric, when the need really arises. When one makes a proper study of 
it, it turns out that one usually has to do very little or nothing. 
<br>

</p><p>
First one should realize that FORM does not know any specific 
metric by itself. Dotproducts are just objects of manipulation. It is 
assumed that when a common index of two vectors is contracted, this works 
out properly into a scalar object. This means that if one has a metric with 
upper and lower indices<a name="15832"></a><a name="15833"></a>, one 
index is supposed to be an upper index and the other is supposed to be a 
lower index. If the user does not like this, it is his/her responsibility 
to force the system into a different action. This is reflected in the fact 
that FORM does not have an internal metric tensor<a name="15834"></a> 
<img width="28" height="28" align="MIDDLE" border="0" src="./online_files/img119.png" alt="$\eta_{\mu\nu}$">. It has only a Kronecker<a name="15836"></a> 
delta<a name="15837"></a> <!-- MATH
 $\delta_{\mu\nu} =$
 -->
<img width="44" height="29" align="MIDDLE" border="0" src="./online_files/img120.png" alt="$\delta_{\mu\nu} =$"> <code>d_(mu,nu)</code> with 
<code>p(mu)*d_(mu,nu)*q(nu)</code> <img width="20" height="13" align="BOTTOM" border="0" src="./online_files/img89.png" alt="$\rightarrow$"> <code>p.q</code> when mu and nu are 
summable indices<a name="15839"></a>. <br>

</p><p>
The dependency of a metric usually enters with statements like 
<img width="74" height="33" align="MIDDLE" border="0" src="./online_files/img121.png" alt="$p^2 = \pm m^2$">, which the user should provide anyway, because FORM does 
not have such knowledge. Connected to this is the choice of a 
propagator<a name="15841"></a> as either <!-- MATH
 $\gamma_\mu p_\mu + m$
 -->
<img width="71" height="28" align="MIDDLE" border="0" src="./online_files/img122.png" alt="$\gamma_\mu p_\mu + m$"> or 
<!-- MATH
 $\gamma_\mu p_\mu + i\ m$
 -->
<img width="82" height="28" align="MIDDLE" border="0" src="./online_files/img123.png" alt="$\gamma_\mu p_\mu + i m$">. This is also something the user should provide. 
The only objects that FORM recognizes and that could be considered as 
metric-dependent are the gamma matrices<a name="15842"></a> and the 
Levi-Civita<a name="15843"></a> tensor<a name="15844"></a> 
<code>e_</code>. Because the trace of a <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> involves a Levi-Civita tensor, 
the two are intimately connected. The anticommutator of two gamma matrices 
is defined with the Kronecker delta. Amazingly enough that works out well, 
provided that, if such Kronecker delta's survive in the output, they are 
interpreted as a metric tensor. This should be done with great care, 
because at such a point one does something that depends of the metric; one 
may have to select whether the indices are upper or lower indices. One 
should check carefully that the way the output is interpreted leads indeed 
to the results that are expected. This is anyway coupled to how one should 
interpret the input, because in such a case one would also have an input 
with `open' indices and give them a proper interpretation. The rule is that 
generally one does not have to do anything. The upper indices in the input 
will be upper indices in the output and the same for lower indices. 
<br>

</p><p>
The contraction<a name="15846"></a> of two Levi-Civita tensors will give products of 
Kronecker delta's. This means that formally there could be an error of the 
sign of the determinant of the metric tensor, if one would like the 
Kronecker delta to play the role of a metric tensor. Hence it is best to 
try to avoid such a situation. <br>

</p><p>
In FORM the <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> is an object that anticommutes with 
the <img width="21" height="28" align="MIDDLE" border="0" src="./online_files/img124.png" alt="$\gamma_\mu$"> and has <!-- MATH
 $\gamma_5\gamma_5 = 1$
 -->
<img width="64" height="28" align="MIDDLE" border="0" src="./online_files/img125.png" alt="$\gamma_5\gamma_5 = 1$">. Its properties 
in the trace are 
<br>
</p><div align="CENTER">

<!-- MATH
 \begin{eqnarray}
Tr[\gamma_5\gamma_{m_1}\gamma_{m_2}\gamma_{m_3}\gamma_{m_4}] & = &
		4 \epsilon_{\mu_1\mu_2\mu_3\mu_4} \nonumber
\end{eqnarray}
 -->
<table align="CENTER" cellpadding="0" width="100%">
<tbody><tr valign="MIDDLE"><td nowrap="" align="RIGHT"><img width="154" height="31" align="MIDDLE" border="0" src="./online_files/img126.png" alt="$\displaystyle Tr[\gamma_5\gamma_{m_1}\gamma_{m_2}\gamma_{m_3}\gamma_{m_4}]$"></td>
<td align="CENTER" nowrap=""><img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img42.png" alt="$\textstyle =$"></td>
<td align="LEFT" nowrap=""><img width="75" height="28" align="MIDDLE" border="0" src="./online_files/img127.png" alt="$\displaystyle 4 \epsilon_{\mu_1\mu_2\mu_3\mu_4}$"></td>
<td width="10" align="RIGHT">
&nbsp;</td></tr>
</tbody></table></div>
<br clear="ALL"><p></p>
This has a number of interesting consequences. The V-A and V+A currents are 
represented by <!-- MATH
 $\gamma_7\gamma_\mu = (1-\gamma_5)\gamma_\mu$
 -->
<img width="129" height="31" align="MIDDLE" border="0" src="./online_files/img128.png" alt="$\gamma_7\gamma_\mu = (1-\gamma_5)\gamma_\mu$"> and 
<!-- MATH
 $\gamma_6\gamma_\mu = (1+\gamma_5)\gamma_\mu$
 -->
<img width="129" height="31" align="MIDDLE" border="0" src="./online_files/img129.png" alt="$\gamma_6\gamma_\mu = (1+\gamma_5)\gamma_\mu$"> respectively. Under 
conjugation we have to replace <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> by <img width="32" height="28" align="MIDDLE" border="0" src="./online_files/img130.png" alt="$-\gamma_5$"> as is not 
uncommon. <br>

<p>
There was a time that a conjugation<a name="15856"></a> operation 
was planned in FORM. As time progressed, it was realized that this would 
introduce problems with some of the internal objects. Hence some objects 
have the property that they are considered imaginary<a name="15857"></a>. In 
practise FORM does not do anything with this. Neither does it do anything 
with the declarations real<a name="15858"></a>, complex<a name="15859"></a> and 
imaginary<a name="15860"></a>. If ever a way is found to implement a conjugation 
operator that will make everybody happy, it may still be built in. 
<br>

</p><p>
The above should give the user enough information to convert any 
specific metric to what is needed to make FORM do what is expected from it. 
Afterwards one can convert back, provided no metric<a name="15862"></a> specific 
operations are done. Such metric specific things are for instance needed in 
some types of approximations in which one substitutes objects by 
(vector)components halfway the calculation. In that case one cannot rely on 
that the conversions at the beginning and the end will be compensating each 
other. For this case FORM allows the user to define a private metric. All 
the tools exist to make this a success with the exception of a loss in 
speed of course. Let us have a look at the contraction of two Levi-Civita 
tensors in an arbitrary metric:
</p><pre>    Indices m1,m2,m3,n1,n2,n3,i1,i2,i3;
    Cfunction eta(symmetric),e(antisymmetric);
    Off Statistics;
    *
    *   We have our own Levi-Civita tensor e
    *
    Local F = e(m1,m2,m3)*e(m1,m2,m3);
    *
    *   We write the contraction as
    *
    id  e(m1?,m2?,m3?)*e(n1?,n2?,n3?) =
            e_(m1,m2,m3)*e_(i1,i2,i3)*
                eta(n1,i1)*eta(n2,i2)*eta(n3,i3);
    *
    *   Now we can use the internal workings of the contract:
    *
    Contract;
    Print +s;
    .sort

   F =
       + eta(i1,i1)*eta(i2,i2)*eta(i3,i3)
       - eta(i1,i1)*eta(i2,i3)^2
       - eta(i1,i2)^2*eta(i3,i3)
       + 2*eta(i1,i2)*eta(i1,i3)*eta(i2,i3)
       - eta(i1,i3)^2*eta(i2,i2)
      ;

    *
    *   For specifying a metric we need individual components:
    *
    Sum i1,1,2,3;
    Sum i2,1,2,3;
    Sum i3,1,2,3;
    Print +s;
    .sort

   F =
       + 6*eta(1,1)*eta(2,2)*eta(3,3)
       - 6*eta(1,1)*eta(2,3)^2
       - 6*eta(1,2)^2*eta(3,3)
       + 12*eta(1,2)*eta(1,3)*eta(2,3)
       - 6*eta(1,3)^2*eta(2,2)
      ;

    *
    *   And now we can provide the metric tensor
    *
    id  eta(1,1) = 1;
    id  eta(2,2) = 1;
    id  eta(3,3) = -1;
    id  eta(1,2) = 0;
    id  eta(1,3) = 0;
    id  eta(2,3) = 0;
    Print +s;
    .end

   F =
       - 6
      ;
</pre>
This is the ultimate in flexibility<a name="15865"></a> of course. It can 
also be worked out in a different way. In this case we try to change the 
behaviour of the Kronecker<a name="15866"></a> delta<a name="15867"></a> a 
bit. This is dangerous<a name="15868"></a> and needs, in addition to a good 
understanding of what is happening, good testing to make sure that what the 
user wants is indeed what does happen. Here we use the 
FixIndex<a name="15869"></a> (<a href="#substafixindex">7.51</a>) statement. This one assigns 
specific values to selected diagonal elements of the Kronecker delta. Of 
course it is the responsibility of the user to make sure that the 
calculation will indeed run into those elements. This is by no means 
automatic, because when FORM uses formal indices it never writes them out 
in components. Moreover, it would not be defined what would be the 
components connected to an index. The index could run over <img width="57" height="28" align="MIDDLE" border="0" src="./online_files/img131.png" alt="$0,1,2,3$"> or 
over <img width="57" height="28" align="MIDDLE" border="0" src="./online_files/img132.png" alt="$1,2,3,4$">, or maybe even over <img width="65" height="28" align="MIDDLE" border="0" src="./online_files/img133.png" alt="$5,7,9,11$">. And what does an 
n-dimensional index run over? In the above example it is the sum 
(<a href="#substasum">7.129</a>) statement that determines this. Hence this is fully under 
the control of the user. Therefore a proper way to deal with the above 
example would be
<pre>    Indices i1,i2,i3;
    FixIndex 1:1,2:1,3:-1;
    Off Statistics;
    *
    Local F = e_(i1,i2,i3)*e_(i1,i2,i3);
    Sum i1,1,2,3;
    Sum i2,1,2,3;
    Sum i3,1,2,3;
    Print +s;
    .sort

   F =
       + 6*e_(1,2,3)*e_(1,2,3)
      ;

    Contract;
    Print +s;
    .end

   F =
       - 6
      ;
</pre>
In the case that one would like to exchange the order of the summation and 
the contraction, while using the FixIndex mechanism, one needs to be more 
careful. In that case we have to prevent the indices from being summed over 
while they are indices of a Kronecker delta, because as long as the indices 
are symbolic, FORM will replace <code>d_(i1,i1)</code> by the dimension of 
<code>i1</code>, and that is not what we want. Hence we have to declare the 
indices to be non-summable by giving them dimension zero:
<pre>    Indices i1=0,i2=0,i3=0;
    FixIndex 1:1,2:1,3:-1;
    Off Statistics;
    *
    Local F = e_(i1,i2,i3)*e_(i1,i2,i3);
    Contract;
    Print +s;
    .sort

   F =
       + d_(i1,i1)*d_(i2,i2)*d_(i3,i3)
       - d_(i1,i1)*d_(i2,i3)*d_(i2,i3)
       - d_(i1,i2)*d_(i1,i2)*d_(i3,i3)
       + 2*d_(i1,i2)*d_(i1,i3)*d_(i2,i3)
       - d_(i1,i3)*d_(i1,i3)*d_(i2,i2)
      ;

    Sum i1,1,2,3;
    Sum i2,1,2,3;
    Sum i3,1,2,3;
    Print +s;
    .end

   F =
       - 6
      ;
</pre>
As we can see, the automatic summation over the indices is not performed 
now and this gives us a chance to do the summation manually. After that the 
fixindex statement can have its effect. <br>

<p>
It should be clear from the above examples that it is usually 
much easier to manipulate the input in such a way that the terms with two 
Levi-Civita tensors have the negative sign from the beginning. This would 
give programs that are less complicated and much faster. <br>

</p><p>
Hence we are faced with the situation that in normal cases one 
does not do anything. If one wants to go beyond this and wants to interfere 
with the inner workings themselves by for instance inserting a factor <img width="10" height="14" align="BOTTOM" border="0" src="./online_files/img134.png" alt="$i$"> 
in front of the <img width="20" height="28" align="MIDDLE" border="0" src="./online_files/img48.png" alt="$\gamma_5$"> and emulating the upper and lower indices of a 
favorite metric, this leads from one problem to the next. Extreme care is 
needed. This is usually done by people who have first worked with other 
programs in which things don't work as naturally as in FORM. By the time 
one has really figured out how to deal with the metric and how to make use 
of the internal algorithms of FORM, one usually does not have to do very 
much again. <br>

</p><p>
As in the Zen<a name="15879"></a> saying: <br>

</p><p>
To the beginning student mountains<a name="15881"></a> are mountains 
and water<a name="15882"></a> is water. To the advanced student<a name="15883"></a> 
mountains stop being mountains and water stops being water. To the 
master<a name="15884"></a> mountains are mountains again and water is water 
again. <br>

</p><p>
Of course the modern master also checks that what he expects the 
system to do, is indeed what the system does.

</p><p>

</p><h1><a name="SECTION001610000000000000000"></a>
<a name="sorting"></a>
<br>
Sorting and statistics
</h1>

<p>
The sorting system is a vital part of FORM and one of the main reasons why 
the speed of FORM compares so favorably with other systems. 
A good understanding of what happens during the sorting<a name="15966"></a> of 
expressions is essential if one wants to write efficient<a name="15967"></a> 
programs. In essence the sorting is done by a tree<a name="15968"></a> sort. 
However due to the nature of mathematical expressions there is a 
complication. When two terms are identical with the possible exception of 
their coefficient, we will add their coefficients, put this new coefficient 
in the place of the coefficient of the first term, and drop the second 
term. If the new coefficient happens to be zero, both terms are dropped. 
Hence the number of terms during the sort is not fixed. For a tree sort 
this is not a major complication<a name="15969"></a>. What is more annoying 
though is that the new coefficient may take more space inside the storage 
than either of the old coefficients. Let us have a look now at what happens 
in a FORM program. Much can be seen from the statistics.
</p><pre>    S	x1,...,x4;
    L	F = (x1+...+x4)^4;
    .end

Time =       0.01 sec    Generated terms =         35
                F        Terms in output =         35
                         Bytes used      =        628
</pre>
In this case the program generated 35 terms. Whenever a term is generated 
and FORM is done with it (no more statements will act on it), FORM 
will write it into a buffer which is called the small buffer. Additionally 
it stores a pointer to the location of this term inside the small buffer. 
Next it will continue generating terms. This process will be stopped by 
either of three conditions:

<ol>
<li>FORM is finished generating terms.
</li>
<li>The last generated term does not fit inside the space remaining in 
the small buffer.
</li>
<li>There is no space for a pointer to the last generated term inside the 
array of pointers.
</li>
</ol>
In either of these three cases FORM will sort the contents of the 
small<a name="15974"></a> buffer<a name="15975"></a>. This sorting is done 
`by pointers' and hence it is important that the whole small buffer fits 
inside the physical memory of the computer. If this would not be the case, 
some very inefficient swapping of memory might be the result. During this 
sorting FORM may run into the problem that the coefficient of two combined 
terms does not fit in the place of one of the two old coefficients. This 
means that the combined term will need more space, but because the old 
terms might be enclosed by other terms, this space may not be available 
locally. To this end FORM has some spare space in the small buffer which is 
called the small<a name="15976"></a> extension<a name="15977"></a>. 
Actually the term SmallExtension<a name="15978"></a> is used for the 
combination of the small buffer and its extra space. The extra space is at 
least <img width="28" height="31" align="MIDDLE" border="0" src="./online_files/img135.png" alt="$1/6$"> times the size of the small buffer, but typically it will be 
about <img width="28" height="31" align="MIDDLE" border="0" src="./online_files/img111.png" alt="$1/3$"> the size of the small buffer. In some exceptional cases (with 
heavy use of a polynomial coefficient via the PolyFun<a name="15979"></a> 
command) bigger sizes might be useful.

<p>
In the case that the new combined term needs more space than each of the 
old terms, the new term is placed in the extension space. If, during the 
sort, the extension space becomes exhausted, FORM will make a 
garbage<a name="15980"></a> 
collection of the entire extended small buffer. This will always result in 
the extension space becoming empty again, because the notation of the terms 
in FORM is such the new combined term will at most occupy an amount 
of space equal to the sum of the spaces of the original two terms. In older 
versions of FORM this garbage collection was executed by means of a 
temporary disk file. In the new version it is done inside the memory by 
temporarily allocating a new buffer. Anyway such garbage collections are 
relatively rare.

</p><p>
In the above example, the sorting occurred because the generation of terms 
was finished. Hence the sorted output is written away in such a way that it 
can be used as input for a potential next module (or to be printed). 
Hence let us change the size of the small buffer:
</p><pre>    #: SmallSize 300
    S	x1,...,x4;
    L	F = (x1+...+x4)^4;
    .end

Time =       0.00 sec    Generated terms =         13
                F      1 Terms left      =         13
                         Bytes used      =        236

Time =       0.00 sec    Generated terms =         26
                F      1 Terms left      =         26
                         Bytes used      =        476

Time =       0.00 sec    Generated terms =         35
                F      1 Terms left      =         35
                         Bytes used      =        632

Time =       0.00 sec    Generated terms =         35
                F        Terms in output =         35
                         Bytes used      =        628
</pre>
Now the size of the small buffer will be only 300 bytes. As a result the 
13-th term does not fit. We can see this in the statistics: the 13-th term 
has been generated and FORM sorts the small buffer. The output of the 12 
sorted terms is written to another buffer, called the
large<a name="15983"></a> buffer<a name="15984"></a>. Inside the large 
buffer the terms are lightly compressed. This compression is related to the 
fact that in each `patch'<a name="15985"></a> the terms are already sorted and 
hence we may not have to repeat the identical beginnings of each term. 
Hence the amount of space used after this sort is less than the 300 bytes 
of the small buffer, even though the 13-th term gave an overflow for these 
300 bytes. The small buffer fills up again at the 26-th term and again it 
is sorted and the results written to the large buffer. Finally, after 35 
terms, the generation is finished. Hence the remains in the small buffer 
are also sorted and written as a third `patch' into the large buffer. Then 
the large buffer is sorted. For this a different sort technique is used. It 
is assumed that the large buffer is not always residing inside the physical 
memory. Hence parts of it may be swapped out temporarily. With the size of 
current days memories this may not happen very often, unless one sets the 
size of the buffer to something comparable to the memory size of the 
computer and several programs are running at the same time. Anyway, 
swapping will not affect the large buffer very much. FORM will merge the 
`patches' by going sequentially through them with a method called 
`tree<a name="15986"></a> of losers' in the book by Knuth<a name="15987"></a> 
(the art of computer programming, vol. 3). Because it goes sequentially 
through the patches, uses all the information it reads and never needs it 
again, this method is indeed rather well resistant to swapping.

<p>
The next complication is of course when the large buffer is full. This can 
be either because its byte space is full, or because the maximum number of 
patches is exceeded. Because the sorting method uses quite a few variables 
for each patch, there is a space allocated for them and hence there is a 
maximum number of patches. If we set this to 2 (just for demonstration 
purposes) we obtain:
</p><pre>    #: SmallSize 200
    #: LargePatches 2
    S	x1,...,x4;
    L	F = (x1+...+x4)^4;
    .end

Time =       0.00 sec    Generated terms =          9
                F      1 Terms left      =          9
                         Bytes used      =        164

Time =       0.00 sec    Generated terms =         17
                F      1 Terms left      =         17
                         Bytes used      =        312

Time =       0.00 sec    Generated terms =         26
                F      1 Terms left      =         26
                         Bytes used      =        478

Time =       0.00 sec
                F        Terms active    =         26
                         Bytes used      =        474

Time =       0.00 sec    Generated terms =         35
                F      1 Terms left      =         35
                         Bytes used      =        630

Time =       0.00 sec
                F        Terms active    =         35
                         Bytes used      =        786

Time =       0.00 sec    Generated terms =         35
                F        Terms in output =         35
                         Bytes used      =        628
</pre>
We see that after the third small buffer has been sorted, the third patch 
cannot be written to the large buffer. Hence the large buffer is sorted 
(indicated by the special statistics involving the phrase `Terms active'). 
The result of this is written as a sorted patch to the
sort<a name="15990"></a> file. This file is one of the 
temporary<a name="15991"></a> files that FORM can create. It has the 
extension .sor<a name="15992"></a>. Now the third patch can be written 
into the -by now empty- large buffer. At the end of term generation, the 
last small buffer is sorted, its results written into the large buffer, 
then that is sorted and its results written as the final patch into the 
sort file. Then, finally the patches in the sort file are merged in a 
method similar to the way the large buffer is sorted. This final sort is a 
disk<a name="15993"></a> to disk sort. Hence it can use the disk 
rather intensely and the use of the CPU may drop temporarily, although it 
is nothing so dramatic as when the computer is involved in heavy 
inefficient swapping as can be the case with many other algebra programs. 
Also, this is usually only a small fraction of the running time of the 
program. The exception may be when FORM is running several processes and 
they are all using disk sorts simultaneously. In that case some file 
systems may not be very good at handling the ensuing
traffic<a name="15994"></a> jams.

<p>
Also the disk to disk sort will have a maximum number of patches that can 
be sorted simultaneously. If this number is exceeded there will be one or 
more extra stages<a name="15995"></a> in the sorting, all of which 
will be disk to disk sorts. It is advisable to tune the setup parameters in 
such a way that one can prevent this, because it involves usually needless 
use of resources. One can try to increase the parameter 
FilePatches<a name="15996"></a>, but the problem is that FORM uses a 
caching<a name="15997"></a> system to buffer the inputs from the sort file. The 
cache buffers have to have a size that is at least twice the maximum size 
of a term. For each patch it needs a buffer and all buffers together should 
fit inside the combination of the large buffer and the small extended 
buffer. This puts an upper limit on the number of file patches. 
Additionally this buffer (SortIOsize<a name="15998"></a>) should not be very 
small, because otherwise the disk IO operations are very inefficient. Hence 
it helps often to increase the size of the small buffer and the large 
buffer first. That gives fewer patches. Additionally it in turn can allow 
for more file patches that are not too small.

</p><p>
One thing that one can see now is that if terms are to cancel or to add, it 
is advantageous if this happens already in an early stage of the sorting. 
This means that it is most efficient if these terms will end up in the 
small buffer at the same time. This should explain the example given in the 
section on brackets<a name="15999"></a>. This way fewer terms are written to 
the large buffer and/or the sort file, which means that less disk space 
will be used.

</p><p>
The sizes of buffers involved can all be tuned to a given hardware. How 
this is done is explained in the chapter on the setup<a name="16000"></a> <a href="#setup">16</a>.

</p><p>
When FORM is dealing with the arguments<a name="16002"></a> of 
functions and if an argument is a multiterm subexpression, also such 
subexpressions need to be sorted. In older versions of FORM this was done 
inside the at that moment remaining space of the small buffer and its 
extension. The reason was that such subexpressions would be rather short 
(they would have to fit inside a function argument and were hence limited 
by the maximum size of a term) and buffer space was hard to come by in 
computers with small memories. In the new version of FORM other 
subexpression sorts were added: the sorting in the term environment (see 
<a href="#substaterm">7.135</a>) and the sorting of $-expressions. Both sorts do not have 
the restriction of the maximum size of a term. They can result in 
expressions that are arbitrarily long (although that might not give 
efficient programs). Hence the sorting of subexpressions have now their own 
buffers. And more than one such set may be needed if for instance the term 
environment is used in a nested fashion. Of course the settings for the 
buffers of this `subsort' are not quite as large as for the main buffers. 
And the user can of course also influence their settings as explained in 
the chapter on the setup <a href="#setup">16</a>. This chapter gives also all default 
values.

</p><p>
When FORM is running in parallel mode (either TFORM or P<small>AR</small>FORM) each worker 
will need its own buffers. In P<small>AR</small>FORM in which the processors each control 
their own memory, the size of each of these buffers are the same as for the 
master process. In TFORM with its shared memory the sizes that the user 
selects for the sort buffers and the scratch file caches refer to the 
buffers of the master thread. The workers each get basically buffers with 
1/N times the size of the buffer of the master. They may be made a bit 
bigger when potential conflicts with MaxTermSize occur.

</p><p>

</p><h1><a name="SECTION001700000000000000000"></a>
<a name="setup"></a>
<br>
The setup
</h1>

<p>
When FORM is started, it has a number of settings<a name="16056"></a> built in 
that were determined during its installation<a name="16057"></a>. If the 
user would like to alter these settings, it is possible to either specify 
their desired values in a setup file<a name="16058"></a> or to do so at the 
beginning of the program file<a name="16059"></a>. There are two ways in 
which FORM can find a setup file. The first way is by having a file named 
`form.set'<a name="16060"></a> in the current directory. If such a file is 
present, FORM will open it and interpret its contents as setup parameters. 
If this file is not present, one may specify a setup file with the -s 
option in the command tail. This option must precede the name of the input 
file. After the -s follow one or more blanks or tabs and then the full name 
of the setup file. FORM will try to read startup parameters from this file. 
If a file `form.set' is present, FORM will ignore the -s option and its 
corresponding file name. This order of interpretation allows the user to 
define an alias with a standard setup file which can be overruled by a 
local setup file. If, in the beginning of the program file, before any 
other statements with the exception of the #- instruction and commentary 
statements, there are lines that start with #: the remaining contents of 
these lines are interpreted exactly like the lines in the setup file. The 
specifications in the program file take precedence<a name="16061"></a> over 
all other specifications. If neither of the above methods is used, FORM 
will use a built in set of parameters. Their values may depend on the 
installation and are given below. 

</p><p>
The following is a list of parameters that can be set. The syntax is rather 
simple: The full word must be specified (case insensitive), followed by one 
or more blanks or tabs and the desired number, string or character. 
Anything after this is considered to be commentary. In the setup file lines 
that do not start with an alphabetic character are seen as commentary. The 
sizes of the buffers are given in bytes, unless mentioned otherwise. A word 
is 2 bytes for 32<a name="16062"></a> bit machines and 4 bytes for 64<a name="16063"></a> bit machines.

</p><p>
In FORM version 3.3 and later, it is also allowed to define 
preprocessor variables<a name="16064"></a> (see also 
<a href="#preprovariables">3.1</a>) in the setup file. In addition one can use 
preprocessor variables in the setup, provided it is not in the name of the 
parameter/keyword.

</p><p>
<table width="181">
<tbody><tr><td>bracketindexsize<a name="16422"></a><a name="16423"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Maximum size in bytes of any individual index of a 
bracketted expression. Each expression will have its own index. The index 
starts with a relatively small size and will grow if needed. But it will 
never grow beyond the specified size. If more space is needed, FORM will 
start skipping brackets and find those back later by linear search. See 
also chapter&nbsp;<a href="#brackets">9</a> and section&nbsp;<a href="#substabracket">7.10</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>CommentChar<a name="16439"></a><a name="16440"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>This should be followed by one or more blanks and a 
single non-blank character. This character will be used to indicate 
commentary, instead of the regular <img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img3.png" alt="$*$"> in column 1.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>CompressSize<a name="16453"></a><a name="16454"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>When compressing output terms, FORM needs a compression 
buffer. This buffer deals recursively with compression and decompression of 
terms that are either written or read. Its size will be at least 
MaxTermSize but when there is heavy use of expressions in the right hand 
side of definitions or substitution it would have to be considerably 
longer. It is hoped that in the future this parameter can be eliminated. 
CompressSize should be given in bytes.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ConstIndex<a name="16468"></a><a name="16469"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>This is the number of indices that are considered to be 
constant indices like in fixed vector components (the so-called fixed 
indices). The size of this parameter is not coupled to any array space, but 
it should not go much beyond 1000 on a 32<a name="16476"></a> bit machine. On a 
64<a name="16477"></a> bit machine it can go considerably further.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ContinuationLines<a name="16484"></a><a name="16485"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The number of continuation lines that the local Fortran 
compiler will allow. This limits the number of continuation lines, when the 
output option `Format Fortran' (see <a href="#substaformat">7.52</a>) is selected.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Define<a name="16499"></a><a name="16500"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The syntax is as in the #define instruction in the 
preprocessor (see <a href="#preprovariables">3.1</a>), with the remark that in the setup 
file there should be no leading # character as that would make the line 
into commentary. Example: 
<br><tt>    define MODULUS "31991"</tt> 
<br>
which could be used 
at a later point in the program to activate a modulus statement (see 
<a href="#substamodulus">7.82</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>DotChar<a name="16516"></a><a name="16517"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>There should be a single character following this name 
(and the blank(s) after it). This character will be used instead of the _, 
when dotproducts<a name="16524"></a> are printed in Fortran<a name="16525"></a> 
output. This option is needed because some Fortran compilers do not 
recognize the underscore as a valid character. In the olden days one could 
use here the dollar character but nowadays many Fortran compilers do not 
recognize this character as belonging to a variable name.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>FunctionLevels<a name="16532"></a><a name="16533"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The maximum number of levels that may occur, when 
functions have functions in their arguments.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>HideSize<a name="16546"></a><a name="16547"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The size of the hide buffer. The size of this buffer is 
normally set equal to scratchsize (see below). If one uses the setting of 
HideSize after the setting of ScratchSize, one can give the hide buffer its 
own size. There are cases that this can make the program faster.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>IncDir<a name="16560"></a><a name="16561"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Directory (or path of directories) in which FORM will 
look for files if they are not to be found in the current directory. This 
involves files for the #include<a name="16568"></a> and #call<a name="16569"></a> 
instructions. This variable takes precedence over the 
Path<a name="16570"></a><a name="16571"></a> variable.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>InsideFirst<a name="16579"></a><a name="16580"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Not having any effect at the moment.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>MaxNumberSize<a name="16593"></a><a name="16594"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Allows the setting of the maximum size of the numbers 
in FORM. The number should be given in words. For 32<a name="16601"></a> bit 
systems a word is two bytes and for 64<a name="16602"></a> bit systems a word is 
4 bytes. The number size is always limited by the maximum size of the terms 
(see MaxTermSize). Actually it has to be less than half of MaxTermSize 
because a coefficient contains both a numerator and a denominator. It is 
not always a good idea to have the number size at its maximum value, 
especially when MaxTermSize is large. In that case it could be very long 
before a runaway algorithm runs into limitations of size (arithmetic for 
very long fractions is not very fast due to the continuous need for 
computing GCD's)</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>MaxTermSize<a name="16610"></a><a name="16611"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>This<a name="setupmaxtermsize"></a> 
is the maximum size that an individual term may occupy in words. This 
size does not affect any allocations. One should realize however that the 
larger this size is the heavier the demand can be on the workspace, because 
the workspace acts as a heap during the execution and sometimes allocations 
have to be made in advance, before FORM knows what the actual size of the 
term will be. Consequently the evaluation tree cannot be very deep, when 
WorkSpace / MaxTermSize is not very big. MaxTermSize controls mainly how 
soon FORM starts complaining about terms that are too complicated. Its 
absolute maximum is 32568 on 32<a name="16619"></a> bit systems and about <img width="27" height="16" align="BOTTOM" border="0" src="./online_files/img136.png" alt="$10^9$"> 
on 64<a name="16620"></a> bit systems (of course the workspace would have to be 
considerably larger than that....).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>MaxWildCards<a name="16629"></a><a name="16630"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The maximum number of wildcards that 
can be active in a single matching of a pattern. Under normal circumstance 
the default value of 100 should be more than enough.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>NoSpacesInNumbers<a name="16643"></a><a name="16644"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Long<a name="nospacesinnumbers"></a> numbers are usually spread over several lines 
by placing a backspace character at the end of each line and then 
continuing at the next line. For cosmetic purposes FORM puts usually a few 
blank spaces at the beginning of the new line. FORM itself can read this but 
some programs cannot. Hence one can put FORM in a mode in which these 
blanks are omitted. The values of the variable are ON or OFF. There is also 
a command to change this behaviour at runtime. See the on and off commands 
in sections <a href="#staonnospacesinnumbers">7.99</a> and <a href="#staoffnospacesinnumbers">7.98</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>NumStoreCaches<a name="16663"></a><a name="16664"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>This number determines how many store caches (see 
the description of the SizeStoreCache setup parameter below) there will 
be. In the case of parallel processing this will be the number of caches 
per processor.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>NwriteStatistics<a name="16677"></a><a name="16678"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>When this word is mentioned, the default setting for the 
statistics is that no run time statistics will be shown. Ordinarily they 
will be shown.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>NwriteThreadStatistics<a name="16691"></a>
<a name="16692"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>
<br>
<br>
This variable has the values ON or OFF. It controls for 
TFORM whether the statistics of the individual threads will be printed. The
default value is ON.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>OldOrder<a name="16708"></a><a name="16709"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>A special flag (values ON/OFF) by which one can still 
select the old option of not checking for the order of statements inside a 
module. This should be used only in the case that it is nearly impossible 
to change a program to the new mode in which the order of the statements 
(declarations etc) is relevant. In the future this old mode may not exist.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Parentheses<a name="16722"></a><a name="16723"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The maximum number of nestings of parentheses or 
functions inside functions. The variable may be eliminated in a later 
version.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Path<a name="16736"></a><a name="16737"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Directory (or path of directories) in which FORM will 
look for files if they are not to be found in the current directory. This 
involves files for the #include<a name="16744"></a> and #call<a name="16745"></a> 
instructions. FORM will test this path after a potential path specified as 
IncDir<a name="16746"></a><a name="16747"></a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ProcedureExtension<a name="16756"></a><a name="16757"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The extension that will be used by FORM for finding the 
procedures that are in separate files. Restrictions on the strings used are 
as explained in the preprocessor 
#procedureextension<a name="16764"></a> instruction in section 
<a href="#preprocedureextension">3.42</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ProcessBucketSize<a name="16773"></a><a name="16774"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td><a name="setupprocessbucketsize"></a> For the parallel version 
P<small>AR</small>FORM. It is ignored in other versions. Tells P<small>AR</small>FORM how many terms 
there should be in the buckets that are being distributed over the 
secondary processors. See also <a href="#substaprocessbucketsize">7.108</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ResetTimeOnClear<a name="16791"></a><a name="16792"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The value is ON or OFF. The default value is ON. This 
means that by default the clock is reset after each .clear<a name="16799"></a> 
(see chapter <a href="#modules">4</a> on modules) instruction at the end of a module.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ScratchSize<a name="16807"></a><a name="16808"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The size of the input and the output buffers for the 
regular algebra processing. Terms are read in in chunks this size and are 
written to the output file using buffers of this size. There are either two 
or three of these buffers, depending on whether the hide<a name="16815"></a> 
facility is being used (see <a href="#substahide">7.59</a>). These buffers must have a 
size that is at least as large as the MaxTermSize<a name="16817"></a>. These 
buffers act as caches for the files with the extension .sc1<a name="16818"></a>, 
.sc2<a name="16819"></a> and .sc3<a name="16820"></a>. See also the HideSize parameter 
above for the independent setting of the size of the hide buffer.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>SizeStoreCache<a name="16827"></a><a name="16828"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The size of the caches<a name="16835"></a> that are used for 
reading terms when stored expressions are used in the r.h.s. of a 
statement. Typically there are several such caches and they make the 
reading much faster. In the case of parallel processing these caches become 
very important because without them the different processes may all want to 
read from the .str<a name="16836"></a> file<a name="16837"></a> at the same time and 
execution speed will suffer badly. The number of store caches is determined 
by the NumStoreCaches<a name="16838"></a> setup parameter which is 
described above. The size of these caches doesn't have to be very large as 
compared to some of the other buffers. It is recommended though to have 
them at least as large as MaxTermSize<a name="16839"></a> (see above).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>SortType<a name="16846"></a><a name="16847"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Possible values are "lowfirst"<a name="16854"></a>, 
"highfirst"<a name="16855"></a> and "powerfirst"<a name="16856"></a>. "lowfirst" 
is the default. Determines the order in which the terms are placed during 
sorting. In the case of lowfirst, lower powers of symbols and dotproducts 
come before higher powers. In the case of highfirst it is the opposite. In 
the case of powerfirst the combined powers of all symbols together are 
considered and the highest combined powers come first. See also the 
on<a name="16857"></a> statement in <a href="#substaon">7.99</a>.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>TempDir<a name="16865"></a><a name="16866"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>This variable should contain the name of a directory 
that is the directory in which FORM should make its temporary files. If the 
-t (or -T) option is used when FORM is started, the TempDir variable in the 
setup file is ignored. FORM can create a number of different temporary 
files.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ThreadBucketSize<a name="16882"></a><a name="16883"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Only relevant for TFORM. The size of the number of 
terms sent to the workers simultaneously. 
For details see the chapter on the parallel version (<a href="#parallel">17</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ThreadLoadBalancing<a name="16898"></a><a name="16899"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Only relevant for TFORM. Possible values are ON 
or OFF. For details see the chapter on the parallel version (<a href="#parallel">17</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>Threads<a name="16914"></a><a name="16915"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Only relevant for TFORM (see chapter on the parallel 
version). Specifies the default number of worker threads to be used. The 
values 0 and 1 will indicate that running will only be done by the master 
thread (<a href="#parallel">17</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ThreadScratchOutSize<a name="16930"></a><a name="16931"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The size of the output scratch buffers for each of the 
worker threads. These buffers will be used when the InParallel 
statement&nbsp;<a href="#substainparallel">7.68</a> is active. They are used to catch the 
output of the expressions as processed by the individual workers before 
they are copied to the output scratch buffer/file of the master. The output 
scratch buffer/file of each worker will never contain more than one 
expression at a time.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>ThreadScratchSize<a name="16945"></a><a name="16946"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The size of the input scratch buffers for each of the 
worker threads. These buffers are only used when the main scratch buffers 
of the master process aren't sufficient and scratch files have been made. 
When the buffers of the master are big enough, the workers only use 
pointers to the buffer of the master. Once there are scratch files the 
buffer is used for caching the input from those files. In that case each 
worker has its own cache. For reading purposes it can actually be counter 
productive if these buffers are very large. This parameter sets the value 
for the input and the hide<a name="16953"></a> scratch files. The output scratch 
size for the workers is set with the ThreadScratchOutSize parameter.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>TotalSize<a name="16960"></a><a name="16961"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>Puts FORM in a mode in which it tries to determine 
the maximum space occupied by all expressions at any given moment during 
the execution of the program. This space is the sum of the 
input/output/hide scratch files, the sort file(s) and the .str file. This 
maximum is printed at the end of the program. The same can be obtained with 
the "On TotalSize" statement (see <a href="#ontotalsize">7.99</a>) or the -T option 
in the command tail when FORM is started (see <a href="#running">1</a>).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="181">
<tbody><tr><td>WorkSpace<a name="16978"></a><a name="16979"></a>
</td></tr>
</tbody></table>
<br>
<table width="571">
<tbody><tr><td>The size of the heap that is used by the algebra 
processor when it is evaluating the substitution tree. It will contain 
terms, half finished terms and other information. The size of the workspace 
may be a limitation on the depth of a substitution tree.</td></tr>
</tbody></table>
    <br>

</p><p>
Variables that take a path<a name="16275"></a> for their value expect a sequence of 
directories, separated by colon characters as in the UNIX<a name="16276"></a> way 
to define such objects.

</p><p>
The above parameters are conceptually relatively easy. The parameters that 
are still left are more complicated and are often restricted in their 
size by some relationships. Hence it is necessary to understand the 
sorting inside FORM a little bit before using them. On the other hand 
these parameters can influence the performance noticeably. See also chapter 
<a href="#sorting">15.1</a> for more details.

</p><p>
When terms are send to `output' by the main algebra engine, they are put 
inside a buffer. This buffer is called the `small<a name="16278"></a> 
buffer<a name="16279"></a>'. Its size is given by the variable <i>SmallSize<a name="16280"></a></i>. When this buffer is full, or when the number 
of terms in this buffer exceeds a given maximum, indicated by the variable 
<i>TermsInSmall<a name="16281"></a></i>, the contents of the buffer are 
sorted. The sorting is done by pointers, hence it is important that the 
small buffer resides inside the physical memory. During the sorting it may 
happen that coefficients are added. The sum of two rational numbers can 
take more space than any of the individual numbers, so there will be a 
space problem. This has been solved by the construction of an extension to 
the small buffer. The variable <i>SmallExtension<a name="16282"></a></i> 
is the size of the small buffer together with this extension. The value for 
SmallExtension will always be at least 7/6 times the value of SmallSize.

</p><p>
The result of the sorting of the small buffer is written to the 
`large<a name="16283"></a> buffer<a name="16284"></a>' (with the size <i>LargeSize<a name="16285"></a></i>) as a single object and the filling of the 
small buffer can resume. Whenever there is not enough room in the large 
buffer for the result of sorting the small buffer, or whenever there are 
already a given number of these sorted `patches' in it (controlled by the 
variable <i>LargePatches<a name="16286"></a></i>) the buffer will be sorted 
by merging the patches<a name="16287"></a> to make room for the new results. The 
output is written to the sort file as a single patch. Then the results from 
the small buffer can be written to the large buffer. This game can continue 
till no more terms are generated. In the end it will be necessary to sort 
the results in the intermediate sort file<a name="16288"></a>. This can be 
done with up to <i>FilePatches<a name="16289"></a></i> at a time. Because 
file operations are notoriously slow the combination of the small buffer, 
the small extension and the large buffer is used for caching<a name="16290"></a> 
purposes. Hence this space can be split in `FilePatches' caches. The 
limitation is that each cache should be capable to contain at least two 
terms of maximal size. This means that the sum of SmallExtension and 
LargeSize must be at least FilePatches times 2*MaxTermSize*(bytes in short 
integer). It is possible to set the size of these caches directly with the 
variable <i>SortIOsize<a name="16291"></a></i>. If the variable is too large, 
the variable FilePatches may be adjusted by FORM. If there are more than 
FilePatches patches in the sort file, a second sort file is needed for the 
output of each `superpatch'<a name="16292"></a>. When the first sort file has 
been treated, the second sort file can be treated in exactly the same way 
as its predecessor. This process will finish eventually. When there are at 
most FilePatches patches in a sort file, the output of their merging can be 
written directly to the regular output. For completeness we give a list of 
all these variables:

</p><p>
<table width="136">
<tbody><tr><td>FilePatches<a name="16994"></a><a name="16995"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The maximum number of patches that can be merged 
simultaneously, when the intermediate sort file is involved.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>LargePatches<a name="17008"></a><a name="17009"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The maximum number of patches that is allowed in the 
large buffer. The large buffer may reside in virtual memory, due to the 
nature of the sort that is applied to it.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>TermsInSmall<a name="17022"></a><a name="17023"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The maximum number of terms that is allowed in the small 
buffer before it is sorted. The sorted result is either copied to the large 
buffer or written to the intermediate sort file (when LargeSize is too 
small).</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>SmallSize<a name="17036"></a><a name="17037"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The size of the small buffer in bytes.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>SmallExtension<a name="17050"></a><a name="17051"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The size of the small buffer plus its extension.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>LargeSize<a name="17064"></a><a name="17065"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The size of the large buffer.</td></tr>
</tbody></table>
    <br>

</p><p>
<table width="136">
<tbody><tr><td>SortIOsize<a name="17078"></a><a name="17079"></a>
</td></tr>
</tbody></table>
<br>
<table width="590">
<tbody><tr><td>The size of the buffer that is used to write to the 
intermediate sorting file and to read from it. It should be noted that if 
this buffer is not very large, the sorting of large files may become rather 
slow, depending on the operating system. Hence we recommend a potential 
fourth stage in the sorting over having this number too small to fit more 
filepatches in the combined small and large buffer. Setting the small and 
large buffers to a decent size may avoid all problems by a: making more 
space for the caching, b: creating fewer file patches to start with.</td></tr>
</tbody></table>
    <br>

</p><p>
There is a second set of the above setup parameters for sorts of 
subexpressions<a name="16328"></a> as in function arguments or in the 
term environment (see <a href="#substaterm">7.135</a>). Because these things can happen 
with more than one level, whatever allocations have to be made (during 
runtime when needed) may have to be made several times. Hence one should be 
far more conservative here than with the global allocations. Anyway, those 
sorts should rarely involve anything very big. With the function arguments 
the condition is that the final result will fit inside a single term, but 
with the term environment no such restriction exists. The relevant 
variables here are subfilepatches, sublargepatches, sublargesize, 
subsmallextension, subsmallsize, subsortiosize and subtermsinsmall. Their 
meanings are the same as for the variables without the sub in front.

</p><p>
When FORM is running in parallel mode (either TFORM or P<small>AR</small>FORM) each worker 
will need its own buffers. In P<small>AR</small>FORM in which the processors each control 
their own memory, the size of each of these buffers are the same as for the 
master process. In TFORM with its shared memory the above sizes refer to 
the buffers of the master thread. The workers each get basically buffers 
with 1/N times the size of the buffer of the master. This may get made a 
bit bigger when potential conflicts with MaxTermSize occur.

</p><p>
The default settings are
</p><div align="CENTER">
<table cellpadding="3" border="1">
<tbody><tr><td align="LEFT">Variable</td>
<td align="RIGHT">32-bits</td>
<td align="RIGHT">64-bits</td>
</tr>
<tr><td align="LEFT">bracketindexsize</td>
<td align="RIGHT">200000</td>
<td align="RIGHT">200000</td>
</tr>
<tr><td align="LEFT">commentchar</td>
<td align="RIGHT"><img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img3.png" alt="$*$"></td>
<td align="RIGHT"><img width="12" height="13" align="BOTTOM" border="0" src="./online_files/img3.png" alt="$*$"></td>
</tr>
<tr><td align="LEFT">compresssize</td>
<td align="RIGHT">90000</td>
<td align="RIGHT">90000</td>
</tr>
<tr><td align="LEFT">constindex</td>
<td align="RIGHT">128</td>
<td align="RIGHT">128</td>
</tr>
<tr><td align="LEFT">continuationlines</td>
<td align="RIGHT">15</td>
<td align="RIGHT">15</td>
</tr>
<tr><td align="LEFT">dotchar</td>
<td align="RIGHT">.</td>
<td align="RIGHT">.</td>
</tr>
<tr><td align="LEFT">filepatches</td>
<td align="RIGHT">256</td>
<td align="RIGHT">256</td>
</tr>
<tr><td align="LEFT">functionlevels</td>
<td align="RIGHT">30</td>
<td align="RIGHT">30</td>
</tr>
<tr><td align="LEFT">hidesize</td>
<td align="RIGHT">50000000</td>
<td align="RIGHT">50000000</td>
</tr>
<tr><td align="LEFT">incdir</td>
<td align="RIGHT">.</td>
<td align="RIGHT">.</td>
</tr>
<tr><td align="LEFT">insidefirst</td>
<td align="RIGHT">ON</td>
<td align="RIGHT">ON</td>
</tr>
<tr><td align="LEFT">largepatches</td>
<td align="RIGHT">256</td>
<td align="RIGHT">256</td>
</tr>
<tr><td align="LEFT">largesize</td>
<td align="RIGHT">50000000</td>
<td align="RIGHT">50000000</td>
</tr>
<tr><td align="LEFT">maxnumbersize</td>
<td align="RIGHT">200</td>
<td align="RIGHT">200</td>
</tr>
<tr><td align="LEFT">maxtermsize</td>
<td align="RIGHT">10000</td>
<td align="RIGHT">40000</td>
</tr>
<tr><td align="LEFT">maxwildcards</td>
<td align="RIGHT">100</td>
<td align="RIGHT">100</td>
</tr>
<tr><td align="LEFT">nospacesinnumbers</td>
<td align="RIGHT">OFF</td>
<td align="RIGHT">OFF</td>
</tr>
<tr><td align="LEFT">numstorecaches</td>
<td align="RIGHT">4</td>
<td align="RIGHT">4</td>
</tr>
<tr><td align="LEFT">nwritefinalstatistics</td>
<td align="RIGHT">OFF</td>
<td align="RIGHT">OFF</td>
</tr>
<tr><td align="LEFT">nwritestatistics</td>
<td align="RIGHT">OFF</td>
<td align="RIGHT">OFF</td>
</tr>
<tr><td align="LEFT">nwritethreadstatistics</td>
<td align="RIGHT">OFF</td>
<td align="RIGHT">OFF</td>
</tr>
<tr><td align="LEFT">oldorder</td>
<td align="RIGHT">OFF</td>
<td align="RIGHT">OFF</td>
</tr>
<tr><td align="LEFT">parentheses</td>
<td align="RIGHT">100</td>
<td align="RIGHT">100</td>
</tr>
<tr><td align="LEFT">path</td>
<td align="RIGHT">.</td>
<td align="RIGHT">.</td>
</tr>
<tr><td align="LEFT">processbucketsize</td>
<td align="RIGHT">1000</td>
<td align="RIGHT">1000</td>
</tr>
<tr><td align="LEFT">scratchsize</td>
<td align="RIGHT">50000000</td>
<td align="RIGHT">50000000</td>
</tr>
<tr><td align="LEFT">sizestorecache</td>
<td align="RIGHT">32768</td>
<td align="RIGHT">32768</td>
</tr>
<tr><td align="LEFT">smallextension</td>
<td align="RIGHT">20000000</td>
<td align="RIGHT">20000000</td>
</tr>
<tr><td align="LEFT">smallsize</td>
<td align="RIGHT">10000000</td>
<td align="RIGHT">10000000</td>
</tr>
<tr><td align="LEFT">sortiosize</td>
<td align="RIGHT">100000</td>
<td align="RIGHT">100000</td>
</tr>
<tr><td align="LEFT">sorttype</td>
<td align="RIGHT">lowfirst</td>
<td align="RIGHT">lowfirst</td>
</tr>
<tr><td align="LEFT">subfilepatches</td>
<td align="RIGHT">64</td>
<td align="RIGHT">64</td>
</tr>
<tr><td align="LEFT">sublargepatches</td>
<td align="RIGHT">64</td>
<td align="RIGHT">64</td>
</tr>
<tr><td align="LEFT">sublargesize</td>
<td align="RIGHT">4000000</td>
<td align="RIGHT">4000000</td>
</tr>
<tr><td align="LEFT">subsmallextension</td>
<td align="RIGHT">800000</td>
<td align="RIGHT">800000</td>
</tr>
<tr><td align="LEFT">subsmallsize</td>
<td align="RIGHT">500000</td>
<td align="RIGHT">500000</td>
</tr>
<tr><td align="LEFT">subsortiosize</td>
<td align="RIGHT">32768</td>
<td align="RIGHT">32768</td>
</tr>
<tr><td align="LEFT">subtermsinsmall</td>
<td align="RIGHT">10000</td>
<td align="RIGHT">10000</td>
</tr>
<tr><td align="LEFT">tempdir</td>
<td align="RIGHT">.</td>
<td align="RIGHT">.</td>
</tr>
<tr><td align="LEFT">termsinsmall</td>
<td align="RIGHT">100000</td>
<td align="RIGHT">100000</td>
</tr>
<tr><td align="LEFT">threadbucketsize</td>
<td align="RIGHT">500</td>
<td align="RIGHT">500</td>
</tr>
<tr><td align="LEFT">threadloadbalancing</td>
<td align="RIGHT">ON</td>
<td align="RIGHT">ON</td>
</tr>
<tr><td align="LEFT">threads</td>
<td align="RIGHT">0</td>
<td align="RIGHT">0</td>
</tr>
<tr><td align="LEFT">threadsortfilesynch</td>
<td align="RIGHT">OFF</td>
<td align="RIGHT">OFF</td>
</tr>
<tr><td align="LEFT">threadscratchoutsize</td>
<td align="RIGHT">2500000</td>
<td align="RIGHT">2500000</td>
</tr>
<tr><td align="LEFT">threadscratchsize</td>
<td align="RIGHT">100000</td>
<td align="RIGHT">100000</td>
</tr>
<tr><td align="LEFT">workspace</td>
<td align="RIGHT">10000000</td>
<td align="RIGHT">40000000</td>
</tr>
</tbody></table>
</div>
If one compares these numbers with the corresponding numbers for older 
versions one will notice that here we assume that the standard computer 
will have much more memory available than in the `old time'. Basically we 
expect that a serious FORM user has at least 64 Mbytes available. If it is 
considerably less one should define a setup file with smaller settings.

<p>
More recently a new notation for large numbers has been allowed. One can 
use the characters K, M and G to indicate kilo (three zeroes), mega (6 
zeroes) and giga (9 zeroes) as in 10M for 10000000.

</p><p>
To find out what the setup values are, one can use the `ON,setup;' 
statement (<a href="#substaon">7.99</a>).

</p><p>
In version 3.3 and later one may use environment<a name="16336"></a> 
variables for the values of the setup parameters, either in the setup file 
or at the beginning of the .frm file. The environment variable is used as a 
preprocessor variable in the sense that its name is enclosed in a 
backquote-quote pair as in <code>`VARNAME'</code>. The variable will be looked 
for and if found it will be substituted. This can however not be done in a 
recursive way, because the regular routines that take care of the 
preprocessor variables are not active yet when the setups are read.

</p><p>

</p><h1><a name="SECTION001800000000000000000"></a>
<a name="parallel"></a>
<br>
The parallel version
</h1>

<p>
FORM has two versions that can make use of several processors 
simultaneously. Which version can be used profitably depends very much on 
the architecture of the computer one is using. Each version has its own 
control commands which are ignored by the other version and the sequential 
version of FORM. The parallel versions are:

</p><ul>
<li>P<small>AR</small>FORM<a name="17231"></a>: This version runs on processors that have 
their own memory and preferably their own disk. Each processor gets a copy 
of the complete program and MPI<a name="17232"></a> is used for the 
communication<a name="17233"></a>. When the network connections are very 
fast one can also use P<small>AR</small>FORM on computer clusters. P<small>AR</small>FORM was 
developed at the university of Karlsruhe<a name="17234"></a>.
</li>
<li>TFORM<a name="17235"></a>: This version uses POSIX threads and runs on computers 
which have several processors with a shared memory. Data is kept as common 
data as much as possible and only when a worker thread gets a task a 
minimal amount of data is copied to its private buffers. Currently it seems 
to perform best on computers with two or four processors.
</li>
</ul>
Both P<small>AR</small>FORM and TFORM suffer from the same bottlenecks<a name="17237"></a>. 
At the beginning of a module there is a single expression, managed by a 
master process which then has to distribute the terms over the workers. At 
the end of the module the sorted results of the workers have to be gathered 
in by the master<a name="17238"></a> and merged into a single expression again. 
Efficiency depends critically on how fast the terms can be given to the 
workers<a name="17239"></a>, how well the load for the workers is balanced and 
how much time the master has to spend in the final stages of the sorting. 
Another factor is the complexity of the operations inside the module. If 
the module has very few and simple statements, the gain in performance will 
be much less than when the module has much work to do for each term.

<p>
The P<small>AR</small>FORM and TFORM specific code is internally completely separated. 
This offers the possibility that sooner or later the two can be combined to 
allow efficient running on clusters of dual or quad processor machines. 
Whether this would give significant extra benefits needs to be 
investigated. When this project will be undertaken depends very much on the 
availability of such computers.

</p><p>
Because P<small>AR</small>FORM uses MPI<a name="17241"></a> and because different MPI 
environments are normally not binary compatible, the port to a new machine 
requires a recompilation of the source code and a relinking to the MPI 
library. Hence we do not have executables in the distribution site.
One needs to build P<small>AR</small>FORM on one's computer.
For TFORM the situation is much more favorable. Its treatment of the 
parallelization follows the standard for POSIX<a name="17243"></a> threads (or 
PThreads) for which the libraries are implemented on almost any 
UNIX<a name="17244"></a> system and many other systems.

</p><p>
The ideal of a parallel version of FORM is that it should execute nearly 
any regular FORM program, whether it was written for parallelization or 
not. And it should execute much faster on several processors than the 
sequential version on a single processor. The performance is given by the 
improvement factor which is the execution time of the sequential version 
divided by the execution time of the parallel version as measured in real 
time (not CPU time) on a computer that has no other major tasks. The ideal 
would of course be that a computer with N processors would give an 
improvement factor of N. It should be easy to see that this ideal cannot be 
reached, due to the bottlenecks described above. Also the compilation takes 
place on a single processor and the instructions of the preprocessor are 
typically also tasks for a single thread/processor. Yet for small numbers 
of processors one can do rather well. Many old calculations, when repeated 
with TFORM would give improvement<a name="17245"></a> factors above 
1.7 on a dual pentium<a name="17246"></a> machine and around 3 or a bit higher 
on a quad opteron<a name="17247"></a> machine. This was without modifying even a 
single statement in the programs. Of course these numbers depend very much 
on the type of the problem and the programming style used. As of yet there 
is very little experience with parallel versions of FORM. Hence people will 
have to discover what are good ways of getting the most out of their 
computer. It is expected that there will be much progress in the coming 
years.

</p><p>
First we will now discuss the running of the two versions. After that we 
will describe some common syntactic problems.

</p><p>

</p><h1><a name="SECTION001810000000000000000"></a>
<a name="tform"></a>
<br>
TFORM
</h1>

<p>
Let us assume that the executable of TFORM<a name="17250"></a> is called tform. It 
is used exactly the same way as the sequential version of FORM (named form) 
is used with the exception of the possibility to specify the number of 
worker<a name="17251"></a> threads with the -w option. The command
</p><pre>    tform -w4 calcdia
</pre>
would execute the program in the file calcdia.frm, using 4 worker threads, 
in addition to the one master thread. When the -w option is not given or 
when only one worker thread is asked for, tform will run the whole program 
inside the master<a name="17254"></a> thread. Because tform always has some 
overhead this is usually a little bit slower than using form. Strange 
enough there are exceptions although this may have to do with the fact that 
measuring the time of a program doesn't always give the same numbers.

<p>
It is also possible to specify the number of worker threads in the setup 
file, using the line
</p><pre>    Threads 4
</pre>
for 4 threads. And as with all setup parameters one can pass this 
information also via the environment variable FORM_threads or with the line
<pre>    #: Threads 4
</pre>
at the beginning of the program file.

<p>
When the master passes terms to the workers, it has to signal<a name="17259"></a> 
the workers that there is some data. In their turn, each worker has to send 
the master a signal when it has completed its task and it is ready for 
more. Such signals cost time. Hence it is usually best to send terms in 
groups, called buckets<a name="17260"></a>. The optimal number of terms in a 
bucket depends very much on the problem and the size of the expression. 
Bigger buckets mean less overhead in signals. If the buckets are too big 
the workers may have to wait too much. Values between 100 and 1000 are 
usually rather good. There is a default bucket size which is typically 
around 500. The user can change this value in two ways: The first is with 
the ThreadBucketSize<a name="17261"></a> setup parameter in the 
form.set file (or at the startup of the program file, or with the 
FORM_threadbucketsize environment variable) and the second is with the 
ThreadBucketSize statement (see <a href="#substathreadbucketsize">7.137</a>) which is a 
declaration like Symbol or Dimension. The first terms in an expression will 
be sent in smaller buckets to get the workers something to do as soon as 
possible.

</p><p>
Usually the bigger buckets give a better performance, but they suffer from 
a nasty side-effect. Complicated terms that need much execution time have a 
tendency to stick together. Hence there can be one bucket with most of the 
difficult terms and at the end of the module all workers and the master 
have to wait for one worker to finish. This can be improved with a 
load<a name="17263"></a> balancing mechanism. The current version will 
take terms from the buckets of workers that take more time than the others. 
By default this mechanism is on, but it can be switched on or off with the 
`on ThreadLoadBalancing<a name="17264"></a>;' and `off 
ThreadLoadBalancing;' statements. It can also be set as one of the setup 
parameters in the form.set file with
</p><pre>    ThreadLoadBalancing OFF
</pre>
or
<pre>    ThreadLoadBalancing ON
</pre>
or at the start of the program or in the environment.

<p>
The LINUX<a name="17269"></a> operating system tries to cache<a name="17270"></a> files 
that are to be written to disk. Somehow, when several big files have to be 
written it gets all confused (it is not known in what way). This means that 
if tform produces 4 large sort files<a name="17271"></a> eventually the system 
becomes intolerably slow. At one time a test program was 4.5 times slower 
with 4 worker processors than with just the master running, even though the 
master had a single even bigger sort file. This has been improved by having 
the file-to-file sort of the threads changed into a 
file-to-masterbuffers-to-combined-output. Yet the writing and subsequent 
merging of the 4 files at the same time can be disastrous. Work is done to 
improve this, but it may not be easy to circumvent facilities of the 
operating system. Apparently the quality of the drivers is crucial here. 

</p><p>
One can switch the parallel processing on or off (for the complete module) 
at any moment in the program with the 
statements<a name="17272"></a><a name="17273"></a>
</p><pre>    On Threads;
    Off Threads;
</pre>
or using the moduleoption statement (<a href="#substamoduleoption">7.81</a>) that
affects TFORM's behaviour for just the current module:
<pre>    ModuleOption Parallel;
    ModuleOption NoParallel;
</pre>
Additionally one can switch the statistics per thread on or off with
<pre>    On ThreadStats;
    Off ThreadStats;
</pre>
When the thread<a name="17282"></a><a name="17283"></a> statistics are 
switched off only the statistics of the master thread are printed which is 
usually only the final statistics for each of the expressions.

<p>
The timing information in the statistics is the CPU<a name="17284"></a> time 
spent by the thread that prints the statistics. Hence the total CPU time 
spent is the sum of the time of all workers and the time of the master. In 
good running the time of the master should be the smallest number. When the 
statistics per thread are switched off, only the statistics of the master 
process will be printed with this `small' number. Hence it may look like 
the program isn't progressing very much.

</p><p>
For debugging purposes the term by term print<a name="17285"></a> statement (see 
<a href="#substaprint">7.105</a>) is equipped with the <code>%W</code> and <code>%w</code> format 
strings. The first will cause the printing of the number of the current 
thread and the CPU-time used thus far in that thread. The second will only 
print the number of the current thread. The thread with the number zero is 
the master thread. Putting a statement like
</p><pre>    Print +f "&lt;%W&gt; %t";
</pre>
would show which thread is processing which term and when.

<p>
These are all the commands that specifically concern TFORM. When more 
experience is gained using TFORM, more parameters and commands may become 
available.

</p><p>
The fact that the threads need private<a name="17289"></a> data makes that TFORM 
will use more memory than FORM. Most of the buffers are not very large, but 
of course there are some buffers which need to be large, like the sort 
buffers and the scratch input<a name="17290"></a>/hide<a name="17291"></a> buffers. The 
sizes that the user specifies for these buffers are for the corresponding 
buffers of the master. The workers get each 1/N times the size for these 
buffers, when there are N workers. In the case that makes these buffers too 
small because of for instance MaxTermSize, the buffers may become larger.

</p><p>

</p><h1><a name="SECTION001820000000000000000"></a>
<a name="parform"></a>
<br>
ParFORM
</h1>

<p>
Let us call the executable of P<small>AR</small>FORM<a name="17294"></a> parform.
The user must execute parform as an MPI<a name="17295"></a> application.
In many MPI implementations, this is done by using the mpirun<a name="17296"></a>
command:
</p><pre>    mpirun -np 4 parform calcdia
</pre>
This example executes the program in the file calcdia.frm, using 4 
processes,in which one process is the master process and the other 3 
processes are the worker processes.
One has to keep in mind that in some MPI implementations environment 
variables will not be passed to an MPI application. Alternatively extra 
options are needed for passing them.
If one wants to run P<small>AR</small>FORM under a job scheduler on a computer cluster
environment, one may need to write a job script, which depends to a great 
extent on the environment.

<p>
P<small>AR</small>FORM uses MPI for communications between the master and workers. 
Actually terms are distributed by using point-to-point send/receive 
operations of MPI. Since there is some latency for establishing a 
connection between processes, especially between those running on different 
computers, it is best to send terms in groups, like buckets in TFORM. 
The default number of terms in a bucket is currently 1000 in P<small>AR</small>FORM. It 
can be changed with the ProcessBucketSize statement 
(<a href="#substaprocessbucketsize" name="17304">7.108</a>) if this is deemed 
necessary. It can also be changed for the current module with the statement 
(<a href="#substamoduleoption" name="17306">7.81</a>).
</p><pre>    ModuleOption ProcessBucketSize number;
</pre>
And finally it can also be changed in the setup, using the 
ProcessBucketSize (<a href="#setupprocessbucketsize">16</a>) setup parameter.
The first terms in an expression will be sent in smaller buckets to get the 
workers something to do as soon as possible.

<p>
One can switch the parallel processing on or off (for the complete module) 
at any moment in the program with the statements<a name="17310"></a><a name="17311"></a>
</p><pre>    On Parallel;
    Off Parallel;
</pre>
or using the moduleoption statement (<a href="#substamoduleoption">7.81</a>) that
affects P<small>AR</small>FORM's behaviour for just the current module:
<pre>    ModuleOption Parallel;
    ModuleOption NoParallel;
</pre>
Additionally one can switch the statistics per process on or off with
<pre>    On ProcessStats;
    Off ProcessStats;
</pre>
When the process<a name="17320"></a><a name="17321"></a> statistics 
are switched off only the statistics of the master process are printed 
which are usually only the final statistics for each of the expressions.

<p>
As in TFORM, <code>%W</code> and <code>%w</code> in the term by term 
print<a name="17323"></a> statement (see <a href="#substaprint">7.105</a>) are available in 
P<small>AR</small>FORM. They print the number of the current process and the 
CPU-time used thus far in that process.

</p><p>
In principle one can run all FORM or TFORM programs with P<small>AR</small>FORM.
In practice P<small>AR</small>FORM is not so efficient for some problems, in which
more data have to be synchronized between the master and the workers.
The cases for which P<small>AR</small>FORM needs to send data via MPI include:

</p><ul>
<li>The redefine statements, which modify preprocessor variables
        on the workers.
</li>
<li>Modifying $-variables in regular statements with a moduleoption
        statement (see <a href="#pardollars">6.1</a>, <a href="#substamoduleoption">7.81</a>
        and&nbsp;<a href="#dollars-in-parallel">17.3</a>).
</li>
<li>Expression names appearing in right hand sides of definition or
        substitution statements.
</li>
</ul>
The last case may need more explanation.
Consider the following code:
<pre>    Local G = F;
    id a = F;
</pre>
where the expression F is supposed to be already defined. The point is that 
these substitutions of the expression F are performed on the workers. The 
workers, however, do not know the contents of the expression F because it 
is stored on the master. Therefore, before executing this module P<small>AR</small>FORM 
needs to make the master broadcast the expression F to the workers. This 
may be quite time-consuming because the expression could be very large.

<p>

</p><h1><a name="SECTION001830000000000000000"></a>
<a name="dollars-in-parallel"></a>
<br>
Some problems
</h1>

<p>
Both parallel versions share a number of problems which are inherent to 
running in an environment in which the order<a name="17341"></a> in which 
terms are processed isn't deterministic<a name="17342"></a>. Most of these 
problems concern <code>$</code>-variables. They present a mix between private and 
common information. Consider the code
</p><pre>    id  f(x?$xvar) = g(x);
    id  ......
    id  a^n? = b^n*h($var);
</pre>
Of course one could do this simple example differently, but we are 
discussing the principle. What we have here is that each term that passes 
the first statement will acquire its own value of <code>$var</code>, to be used a 
bit later. It is clear that if we have a common administration of 
<code>$</code>-variables we would have to `lock'<a name="17345"></a> the value for a 
considerable amount of time, thereby spoiling much of the gains of parallel 
processing. Hence in this case it would be best that each worker maintains 
its own local value of <code>$var</code>. But in the following example we have 
the opposite:
<pre>    #$xmax = -1;
    if ( count(x,1) &gt; $xmax ) $xmax = count_(x,1);
</pre>
Here we collect a maximum power in the variable <code>$xmax</code>. If each 
worker would have a local value of <code>$xmax</code>, the question is what to do 
with all these local values at the end of the module. A human will see that 
here we are collecting a maximum, but the computer cannot and should not 
see this. Hence the general rule in parallel processing is that when there 
are <code>$</code>-variables<a name="17348"></a> obtaining a value during the 
algebraic phase of a module the entire module is run sequentially, unless 
FORM has been helped with a moduleoption statement for each of the 
variables involved. Hence in the last example
<pre>    ModuleOption Maximum $xmax;
</pre>
would tell FORM how to combine the local values in P<small>AR</small>FORM (P<small>AR</small>FORM 
maintains local values of all <code>$</code>-variables). In TFORM it 
would put the value directly into the central administration, provided it 
is bigger than the previous value. Only during the update the variable 
would have to be locked.

<p>
There are several options in the moduleoption statement:

</p><ul>
<li>Maximum<a name="17352"></a>: The variable must have a 
numerical value and the maximum is collected.
</li>
<li>Minimum<a name="17353"></a>: The variable must have a 
numerical value and the minimum is collected.
</li>
<li>Sum<a name="17354"></a>: The variable must have a numerical value 
and the sum is collected.
</li>
<li>Local<a name="17355"></a>: The value will be kept privately and 
no attempt is made to put it in the central administration, neither during 
the execution of the module, nor at the end. If there was already a 
variable by this name in the central administration it will keep the value 
it had before the module started execution. At the end of the module, all 
private values will be forgotten.
</li>
</ul>

<p>
The redefine statement is a major inefficiency in a parallel environment. 
It redefines a preprocessor variable and there is only a single bookkeeping 
for such variables. This means that the variable has to be sent to the 
master process (P<small>AR</small>FORM) or that a lock has to be placed to prevent other 
workers to write to the same storage simultaneously (TFORM). In addition 
the final value in the preprocessor variable will be determined by the last 
term processed in any of the workers. This may not be the same term in 
different runs. It is up to the user to write programs that still give 
correct results under such conditions. The best way around the inefficiency 
is using <code>$</code>-variables and preprocessor instructions. We show this in 
an example in which we construct the equivalent of a conditional repeat 
that includes a .sort instruction.
</p><pre>    #do i = 1,1
      statements
      if ( count(x,1) &gt; 0 ) redefine i "0";
      .sort
    #enddo
</pre>
To run this in parallel, it is better to use the following code.
<pre>    #do i = 1,1
      #$i = 1;
      statements
      if ( count(x,1) &gt; 0 ) $i = 0;
      ModuleOption minimum $i;
      .sort
      #redefine i "`$i'"
    #enddo
</pre>
In this program the centrally stored value of <code>$i</code> is updated at most 
once. Admitedly it isn't as simple as the redefine statement, but it 
works in all versions of FORM starting with version 3.0.

<p>
It should be noted that when a new expression is defined in its defining 
module it starts out as a single term. Hence it cannot benefit from 
parallelization in that module. Therefore the code
</p><pre>    #define MAX "200"
    Symbols x0,...,x10;
    Local F = (x0+...+x`MAX')^3;
    id x1 = -x2-...-x`MAX';
    .end
</pre>
will execute inside a single worker while
<pre>    #define MAX "200"
    Symbols x0,...,x10;
    Local F = (x0+...+x`MAX')^3;
    .sort
    id x1 = -x2-...-x`MAX';
    .end
</pre>
will make the first expansion inside a single worker and the more costly 
substitution can be made in parallel. A better load<a name="17365"></a> 
balancing algorithm in which at any node in the expansion tree tasks can be 
given to idle workers would solve this problem, but due to some 
complications this has not yet been implemented. The structure of FORM will 
however allow such an implementation.

<p>

</p><h1><a name="SECTION001900000000000000000"></a>
<a name="externalcommunication"></a>
<br>
External communication
</h1>

<p>
To communicate<a name="17473"></a> with other programs FORM is 
equipped with special commands. One set of commands is rather simple in 
nature: the #pipe<a name="17474"></a> (see section <a href="#prepipe">3.38</a>) and 
#system<a name="17476"></a> (see section <a href="#presystem">3.56</a>) instructions allow 
FORM to run programs in the regular command<a name="17478"></a> 
shell<a name="17479"></a>. Sometimes however much more sophistication is needed 
because these instructions have a rather large overhead and need to start 
new processes each time they are executed. Hence a second more extensive 
set of instructions was developed that allows the start of an external 
process<a name="17480"></a>, keep it open and maintain a two way 
communication<a name="17481"></a> with it. Similarly it is 
possible to start FORM in such a way from other programs. Many details of 
the method of implementation and a number of examples are given in a 
separate paper which can also found in the FORM site 
(http://www.nikhef.nl/<img width="17" height="15" align="BOTTOM" border="0" src="./online_files/img137.png" alt="$\sim$">form) under publications (look for the file 
extform.ps<a name="17482"></a> or extform.pdf<a name="17483"></a>). Here we 
will just show the essentials and the syntax.

</p><p>
The basic idea is to open (by means of the preprocessor) a number of 
external channels<a name="17484"></a> (there is no reason to be 
restricted to just one) by starting the corresponding program in a command 
shell. This program is kept running and a number is assigned to each 
channel. Next we can select a channel and communicate with it. To not run 
into syntactic problems, because the external program may have different 
ideas of what a formula should look like, one may have to install 
filters<a name="17485"></a>. These are additional programs that should be 
prepared before the FORM program is started that process the communication 
to convert from one notation to the other.

</p><p>

</p><h1><a name="SECTION001910000000000000000"></a>
<a name="external"></a>
<br>
#external
</h1>

<p>
Syntax:

</p><p>
#external ["prevar"] systemcommand

</p><p>
See also

</p><p>
Starts<a name="17488"></a> the command in the background, 
connecting to its standard input and output. By default, the external 
command has no controlling terminal, the standard error stream is 
redirected to <code>/dev/null</code> and the command is run in a subshell in a 
new session and in a new process group (see the preprocessor instruction 
<code>#setexternalattr</code>).

</p><p>
The optional parameter ``prevar'' is the name of a preprocessor variable 
placed between double quotes. If it is present, the ``descriptor'' (small 
positive integer number) of the external command is stored into this 
variable and can be used for references to this external command (if there 
is more than one external command running simultaneously).

</p><p>
The external command that is started last becomes the ``current'' (active) 
external command.  All further instructions 
#fromexternal<a name="17489"></a> and #toexternal<a name="17490"></a> 
deal with the current external command.

</p><p>

</p><h1><a name="SECTION001920000000000000000"></a>
<a name="toexternalcommunication"></a>
<br>
#toexternal
</h1>

<p>
Syntax:

</p><p>
#toexternal "formatstring" [,variables]

</p><p>
See also

</p><p>
Sends<a name="17493"></a> the output to the current 
external<a name="17494"></a> command. The semantics of the 
<code>"formatstring"</code> and the <code>[,variables]</code> is the same as for the 
#write<a name="17495"></a> instruction, except for the trailing end-of-line symbol. In 
contrast to the #write instruction, the #toexternal instruction does not 
append any newline<a name="17496"></a> symbol to the end of its output.

</p><p>

</p><h1><a name="SECTION001930000000000000000"></a>
<a name="fromexternalcommunication"></a>
<br>
#fromexternal
</h1>

<p>
Syntax:

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">] ["[$]varname" [maxlength]]

</p><p>
Appends<a name="17499"></a> the output of the current 
external<a name="17500"></a> 
command to the FORM program. The semantics differ depending on the optional 
arguments. After the external command sends the prompt, FORM will continue 
with a next line after the line containing the #fromexternal instruction. 
The prompt string is not appended. The optional + or - sign after the name 
has influence on the listing of the content. The varieties are:

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">]

</p><p>
The semantics is similar to the #include<a name="17501"></a> 
instruction but folders<a name="17502"></a> are not supported. 

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">] "[$]varname"

</p><p>
is used to read the text from the running external command into 
the preprocessor variable varname, or into the dollar variable $varname if 
the name of the variable starts with the dollar sign ``$''.

</p><p>
#fromexternal[<img width="29" height="28" align="MIDDLE" border="0" src="./online_files/img30.png" alt="$+-$">] "[$]varname" maxlength

</p><p>
is used to read the text from the running external command into 
the preprocessor (or dollar) variable varname. Only the first maxlength 
characters are stored.

</p><p>

</p><h1><a name="SECTION001940000000000000000"></a>
<a name="promptcommunication"></a>
<br>
#prompt
</h1>

<p>
Syntax:

</p><p>
#prompt [newprompt]

</p><p>
Sets<a name="17505"></a> a new prompt for the current external 
command (if present) and all further (newly started) external commands.

</p><p>
If newprompt is an empty string, the default prompt (an empty line) will be 
used.

</p><p>
The prompt is a line consisting of a single prompt string. By default, this 
is an empty string.

</p><p>

</p><h1><a name="SECTION001950000000000000000"></a>
<a name="setexternalcommunication"></a>
<br>
#setexternal
</h1>

<p>
Syntax:

</p><p>
#setexternal n

</p><p>
Sets the ``current'' external<a name="17508"></a> command. The 
instructions #toexternal<a name="17509"></a> and 
#fromexternal<a name="17510"></a> deal with the current external 
command.  The integer number n must be the descriptor of a running external 
command.

</p><p>

</p><h1><a name="SECTION001960000000000000000"></a>
<a name="rmexternalcommunication"></a>
<br>
#rmexternal
</h1>

<p>
Syntax:

</p><p>
#rmexternal [n]

</p><p>
Terminates an external<a name="17513"></a> command. The integer 
number n must be either the descriptor of a running external command, or 0.

</p><p>
If n is 0, then all external programs will be terminated.

</p><p>
If n is not specified, the current external command will be terminated.

</p><p>
The action of this instruction depends on the attributes of the external 
channel (see the #setexternalattr<a name="17514"></a> (section 
<a href="#setexternalcommunication">18.5</a>) instruction). By default, the instruction 
closes the commands' IO channels, sends a KILL<a name="17516"></a> signal to 
every process in its process group and waits for the external command to be 
finished.

</p><p>

</p><h1><a name="SECTION001970000000000000000"></a>
<a name="setexternalattrcommunication"></a>
<br>
#setexternalattr
</h1>

<p>
Syntax:

</p><p>
#setexternalattr list_of_attributes

</p><p>
sets<a name="17519"></a> attributes for <em>newly started</em> 
external commands. Already running external commands are not affected. The 
list of attributes is a comma separated list of pairs attribute=value, 
e.g.:
</p><pre>   #setexternalattr shell=noshell,kill=9,killall=false
</pre>
Possible attributes are:
<dl>
<dt><strong>kill<a name="17524"></a></strong></dt>
<dd>Specifies which signal is to be sent to the external command either before 
the termination of the FORM program or by the preprocessor instruction 
#rmexternal<a name="17525"></a>. By default this is 9 
(SIGKILL<a name="17526"></a>). Number 0 means that no signal will be 
sent.
</dd>
<dt><strong>killall<a name="17527"></a></strong></dt>
<dd>Indicates whether the KILL<a name="17528"></a> 
signal will be sent to the whole group or only to the initial process. 
Possible values are ``<code>true</code>'' and ``<code>false</code>''. By default, the 
kill signal will be sent to the whole group.
</dd>
<dt><strong>daemon<a name="17529"></a></strong></dt>
<dd>Indicates whether the command should be ``daemonized'', i.e. 
the initial process will be passed to the init process and will belong
to the new process group in the new session.  
Possible values are ``<code>true</code>'' and ``<code>false</code>''. By default, 
``<code>true</code>''.
</dd>
<dt><strong>shell<a name="17530"></a></strong></dt>
<dd>specifies which shell<a name="17531"></a> is used to run a command. (Starting an 
external command in a subshell permits to start not only executable files 
but also scripts and pipelined jobs. The disadvantage is that there is no 
way to detect failure upon startup since usually the shell is started 
successfully.) By default this is ``<code>/bin/sh -c</code>''.  If set 
<code>shell=noshell</code>, the command will be started by the instruction 
#external<a name="17532"></a> directly but not in a subshell, so the command 
should be a name of the executable file rather than a system command. The 
instruction #external will duplicate the actions of the shell in searching 
for an executable file if the specified file name does not contain a slash 
(/) character.  The search path<a name="17533"></a> is the path specified in 
the environment by the PATH<a name="17534"></a> variable.  If this variable isn't 
specified, the default path ``<code>:/bin:/usr/bin</code>'' is used.
</dd>
<dt><strong>stderr<a name="17535"></a></strong></dt>
<dd>specifies a file to redirect the standard error<a name="17536"></a> stream 
to. By default it is ``<code>/dev/null</code>''. If set <code>stderr=terminal</code>,
no redirection occurs.
</dd>
</dl>
Only attributes that are explicitly mentioned are changed, all others remain 
unchanged. Note, changing attributes should be done with care. For example,
<pre>   #setexternalattr daemon=false
</pre>
starts a command in the subshell within the current process group with
default attributes kill=9 and killall=true.
The instruction #rmexternal<a name="17540"></a> sends the
KILL<a name="17541"></a> signal to the whole group, which means that also 
FORM itself will be killed.

<p>

</p><h1><a name="SECTION001980000000000000000">
An example</a>
</h1>

<p>
An example of the above instructions could be:
</p><pre> 1  symbol a,b;
 2
 3  #external "n1" cat -u
 4
 5  #external "n2" cat -u
 6
 7  *  cat simply repeats its input. The default prompt is an
 8  *  empty line. So we use "\n\n" here -- one "\n" is to finish
 9  *  the line, and the next "\n" is the prompt:
10  #toexternal "(a+b)^2\n\n"
11
12  #setexternal `n1'
13  *  For this channel the prompt will be "READY\n":
14  #toexternal "(a+b)^3\nREADY\n"
15
16  #setexternal `n2'
17  *  Set the default prompt:
18  #prompt
19  Local aPLUSbTO2=
20  #fromexternal
21         ;
22
23  #setexternal `n1'
24  #prompt READY
25  Local aPLUSbTO3=
26  #fromexternal
27         ;
28
29  #rmexternal `n1'
30  #rmexternal `n2'
31
32  Print;
33  .end
</pre>

<p>
Two external channels are opened in lines 3 and 5. The UNIX<a name="17545"></a> 
utility ``<code>cat</code>'' simply repeats its input.
The option ``<code>-u</code>'' is used to prevent the output buffering. The 
option is ignored by the GNU<a name="17546"></a> <code>cat</code> utility but is mandatory 
for non-GNU versions of <code>cat</code>.

</p><p>
After line 5 the current external channel is `<code>n2</code>'. The default 
prompt is an empty line so in line 10 ``<code>\n\n</code>'' is used - 
one``<code>\n</code>'' is to finish the line, and the next ``<code>\n</code>'' is the 
prompt.

</p><p>
Line 12 switches the current channel to `<code>n1</code>'. For this channel
the prompt will be ``<code>READY</code>'', see line 24, hence the expression is
finished by ``<code>\nREADY\n</code>''.

</p><p>
Line 16 switches to the `<code>n2</code>' external channel and line 18 sets
the default prompt (which is extra in this example since the default
prompt was not changed up to now).

</p><p>
Results (just a literal repetition of the sent expressions) are read
in lines 20 and 26.

</p><p>
Lines 29 and 30 close the external channels.

</p><p>

</p><h1><a name="SECTION001990000000000000000"></a>
<a name="embeddingcommunication"></a>
<br>
Embedding FORM in other applications
</h1>

<p>
The external channel instructions permit FORM to swallow an external 
program. The same mechanism can be used in order to <em>embed<a name="17549"></a></em> FORM in other applications.

</p><p>
There is a possibility to start FORM from another program providing
one (or more) communication channels (see below). These channels will be 
visible from a FORM program as
``pre-opened''<a name="17550"></a> external channels 
existing after FORM starts. There is no need to open them with the 
#external<a name="17551"></a> instruction.
In this case, the preprocessor variable ``PIPES_''<a name="17552"></a> is 
defined and is equal to the total number of the pre-opened external 
channels. Pre-opened external channel descriptors are contained in the 
preprocessor 
variables ``PIPE1_''<a name="17553"></a>, ``PIPE2_''<a name="17554"></a>, etc.
For example, if `PIPES_'<a name="17555"></a> is 3 then there are 3 
pre-opened external channels with the descriptors `PIPE1_',
`PIPE2_' and `PIPE3_' so e.g. the following instruction could
be used:
</p><pre>   #setexternal `PIPE2_'
</pre>
without 
<pre>   #external "PIPE2_"
</pre>

<p>
The external channel attributes make no sense for the pre-opened channel 
(see the #setexternalattr<a name="17560"></a> instruction (section 
<a href="#setexternalattrcommunication">18.7</a>)).
Formally, they are as follows:
</p><pre>   kill=0,
   killall=false,
   daemon=false,
   stderr=/dev/tty,
   shell=noshell
</pre>

<p>
In order to activate the pre-opened external channels, the parent
application must follow some standards. Here we describe a low-level 
protocol<a name="17564"></a>, the corresponding 
C-interface<a name="17565"></a> is available from the FORM distribution site 
under packages and then externalchannels.

</p><p>
Before starting FORM, the parent application must create one or more pairs 
of pipes. A pipe<a name="17566"></a> is a pair of file descriptors, one is for 
reading and another is for writing. In LINUX<a name="17567"></a>, see ``man 2 
pipe''. The read-only descriptor of the first pipe in the pair and the 
write-only descriptor of the second pipe must be passed to FORM as an 
argument of a command line option ``<code>-pipe</code>'' in ASCII decimal format. 
The argument of the option is a comma-separated list of pairs
``<code>r#,w#</code>'' where ``<code>r#</code>'' is a read-only descriptor and 
``<code>w#</code>'' is a write-only descriptor; alternatively, an environment 
variable FORM_PIPES<a name="17568"></a> containing this list can be used 
(the command line option overrides the environment variable). For example, 
to start FORM with two pre-opened external channels the parent application 
has to create first four pipes. Lets us suppose the first pipe was created 
with the descriptors 5 and 6, the second pipe has the descriptors 7 and 8, 
the third pipe has the descriptors 9 and 10 and the fourth pipe has the 
descriptors 11 and 12. The descriptors 5 and 8 will be used by FORM as the 
input and the output for the first pre-opened external channel while the 
descriptors 9 and 12 will be used by FORM as the input and the output for 
the second pre-opened external channel.

</p><p>
Then the parent application must start FORM with the following 
command line option:
</p><pre>   -pipe 5,8,9,12
</pre>

<p>
Upon startup, FORM sends its PID<a name="17571"></a> (the Process Identifier) in 
ASCIIdecimal format with an appended newline character to the descriptor 8 
and then FORM will wait for the answer from the descriptor 5. The answer 
must be two comma-separated integers in ASCII decimal format followed by a 
newline character. The first integer corresponds to the FORM PID while the 
second one is the parent process PID. If the answer is not obtained after 
some timeout, or if it is not correct (i.e. it is not a list of two 
integers or the first integer is not the FORM PID) then FORM fails. If 
everything is correct, FORM creates the pre-opened channel and puts its 
descriptor in the preprocessor variable ``PIPE1_''.

</p><p>
Then FORM processes the second pair of arguments, ``<code>9,12</code>''.

</p><p>
After all pairs have been processed FORM creates the preprocessor variable 
``PIPES_'' and puts into this variable the total number of created 
pre-opened external channels.

</p><p>
The order of processing the pairs of numbers in the argument is fixed 
exactly as it was described above i.e. from the left to the right.

</p><p>

</p><p>
<br>

</p><h2><a name="SECTION002000000000000000000">
Index</a>
</h2><dl compact="">
<dt><strong>#$name</strong>
</dt><dd><a href="#668">The preprocessor</a>
</dd><dt><strong>#:</strong>
</dt><dd><a href="#664">The preprocessor</a>
</dd><dt><strong>#<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img6.png" alt="$-$"></strong>
</dt><dd><a href="#665">The preprocessor</a>
</dd><dt><strong>#<img width="17" height="28" align="MIDDLE" border="0" src="./online_files/img7.png" alt="$+$"></strong>
</dt><dd><a href="#666">The preprocessor</a>
</dd><dt><strong>#add</strong>
</dt><dd><a href="#15526">Dictionaries</a>
</dd><dt><strong>#addseparator</strong>
</dt><dd><a href="#795">#addseparator</a>
</dd><dt><strong>#append</strong>
</dt><dd><a href="#804">#append</a>
 | <a href="#1338">#write</a>
</dd><dt><strong>#break</strong>
</dt><dd><a href="#812">#break</a>
 | <a href="#863">#case</a>
 | <a href="#904">#default</a>
 | <a href="#1294">#switch</a>
</dd><dt><strong>#breakdo</strong>
</dt><dd><a href="#822">#breakdo</a>
</dd><dt><strong>#call</strong>
</dt><dd><a href="#827">#call</a>
 | <a href="#834">#call</a>
 | <a href="#923">#define</a>
 | <a href="#15319">open</a>
 | <a href="#16569">The setup</a>
 | <a href="#16745">The setup</a>
</dd><dt><strong>#case</strong>
</dt><dd><a href="#860">#case</a>
 | <a href="#861">#case</a>
 | <a href="#902">#default</a>
 | <a href="#1293">#switch</a>
</dd><dt><strong>#close</strong>
</dt><dd><a href="#874">#close</a>
</dd><dt><strong>#closedictionary</strong>
</dt><dd><a href="#15523">Dictionaries</a>
 | <a href="#15534">Dictionaries</a>
</dd><dt><strong>#commentchar</strong>
</dt><dd><a href="#884">#commentchar</a>
</dd><dt><strong>#create</strong>
</dt><dd><a href="#893">#create</a>
 | <a href="#1337">#write</a>
</dd><dt><strong>#default</strong>
</dt><dd><a href="#901">#default</a>
 | <a href="#1295">#switch</a>
</dd><dt><strong>#define</strong>
</dt><dd><a href="#848">#call</a>
 | <a href="#910">#define</a>
 | <a href="#913">#define</a>
 | <a href="#1185">#redefine</a>
</dd><dt><strong>#do</strong>
</dt><dd><a href="#786">The triple dot operator</a>
 | <a href="#928">#do</a>
 | <a href="#976">#enddo</a>
 | <a href="#1306">#switch</a>
 | <a href="#1325">#undefine</a>
 | <a href="#1370">Some remarks</a>
</dd><dt><strong>#else</strong>
</dt><dd><a href="#955">#else</a>
 | <a href="#967">#elseif</a>
 | <a href="#1042">#if</a>
</dd><dt><strong>#elseif</strong>
</dt><dd><a href="#958">#else</a>
 | <a href="#964">#elseif</a>
 | <a href="#1041">#if</a>
</dd><dt><strong>#enddo</strong>
</dt><dd><a href="#930">#do</a>
 | <a href="#973">#enddo</a>
 | <a href="#1371">Some remarks</a>
</dd><dt><strong>#endif</strong>
</dt><dd><a href="#957">#else</a>
 | <a href="#966">#elseif</a>
 | <a href="#984">#endif</a>
 | <a href="#1040">#if</a>
 | <a href="#1377">Some remarks</a>
</dd><dt><strong>#endinside</strong>
</dt><dd><a href="#991">#endinside</a>
</dd><dt><strong>#endprocedure</strong>
</dt><dd><a href="#998">#endprocedure</a>
 | <a href="#1159">#procedure</a>
 | <a href="#1373">Some remarks</a>
</dd><dt><strong>#endswitch</strong>
</dt><dd><a href="#814">#break</a>
 | <a href="#864">#case</a>
 | <a href="#905">#default</a>
 | <a href="#1006">#endswitch</a>
 | <a href="#1296">#switch</a>
 | <a href="#1375">Some remarks</a>
</dd><dt><strong>#exchange</strong>
</dt><dd><a href="#1010">#exchange</a>
</dd><dt><strong>#external</strong>
</dt><dd><a href="#1015">#external</a>
 | <a href="#1246">#setexternalattr</a>
 | <a href="#17488">#external</a>
 | <a href="#17494">#toexternal</a>
 | <a href="#17500">#fromexternal</a>
 | <a href="#17532">#setexternalattr</a>
 | <a href="#17551">Embedding FORM in other</a>
</dd><dt><strong>#factdollar</strong>
</dt><dd><a href="#1026">#factdollar</a>
</dd><dt><strong>#fromexternal</strong>
</dt><dd><a href="#1020">#external</a>
 | <a href="#1029">#fromexternal</a>
 | <a href="#1230">#setexternal</a>
 | <a href="#17489">#external</a>
 | <a href="#17499">#fromexternal</a>
 | <a href="#17510">#setexternal</a>
</dd><dt><strong>#if</strong>
</dt><dd><a href="#956">#else</a>
 | <a href="#965">#elseif</a>
 | <a href="#985">#endif</a>
 | <a href="#1039">#if</a>
 | <a href="#1094">#ifdef</a>
 | <a href="#1102">#ifndef</a>
 | <a href="#1305">#switch</a>
 | <a href="#1376">Some remarks</a>
</dd><dt><strong>#ifdef</strong>
</dt><dd><a href="#986">#endif</a>
 | <a href="#1093">#ifdef</a>
</dd><dt><strong>#ifndef</strong>
</dt><dd><a href="#987">#endif</a>
 | <a href="#1101">#ifndef</a>
</dd><dt><strong>#include</strong>
</dt><dd><a href="#1031">#fromexternal</a>
 | <a href="#1105">#include</a>
 | <a href="#1162">#procedure</a>
 | <a href="#1298">#switch</a>
 | <a href="#15226">The TableBase</a>
 | <a href="#15321">open</a>
 | <a href="#16568">The setup</a>
 | <a href="#16744">The setup</a>
 | <a href="#17501">#fromexternal</a>
</dd><dt><strong>#inside</strong>
</dt><dd><a href="#992">#endinside</a>
 | <a href="#1120">#inside</a>
</dd><dt><strong>#message</strong>
</dt><dd><a href="#1124">#message</a>
</dd><dt><strong>#name</strong>
</dt><dd><a href="#667">The preprocessor</a>
</dd><dt><strong>#opendictionary</strong>
</dt><dd><a href="#15520">Dictionaries</a>
</dd><dt><strong>#pipe</strong>
</dt><dd><a href="#1138">#pipe</a>
 | <a href="#17474">External communication</a>
</dd><dt><strong>#preout</strong>
</dt><dd><a href="#1143">#preout</a>
</dd><dt><strong>#printtimes</strong>
</dt><dd><a href="#1148">#printtimes</a>
</dd><dt><strong>#procedure</strong>
</dt><dd><a href="#830">#call</a>
 | <a href="#835">#call</a>
 | <a href="#1155">#procedure</a>
 | <a href="#1372">Some remarks</a>
</dd><dt><strong>#procedureExtension</strong>
</dt><dd><a href="#851">#call</a>
 | <a href="#1166">#procedureextension</a>
 | <a href="#16764">The setup</a>
</dd><dt><strong>#prompt</strong>
</dt><dd><a href="#1176">#prompt</a>
 | <a href="#17505">#prompt</a>
</dd><dt><strong>#redefine</strong>
</dt><dd><a href="#915">#define</a>
 | <a href="#1182">#redefine</a>
</dd><dt><strong>#remove</strong>
</dt><dd><a href="#1192">#remove</a>
 | <a href="#1201">#remove</a>
</dd><dt><strong>#rmexternal</strong>
</dt><dd><a href="#1214">#rmexternal</a>
 | <a href="#1253">#setexternalattr</a>
 | <a href="#17513">#rmexternal</a>
 | <a href="#17525">#setexternalattr</a>
 | <a href="#17540">#setexternalattr</a>
</dd><dt><strong>#rmseparator</strong>
</dt><dd><a href="#1223">#rmseparator</a>
</dd><dt><strong>#setexternal</strong>
</dt><dd><a href="#1228">#setexternal</a>
 | <a href="#17508">#setexternal</a>
</dd><dt><strong>#setexternalattr</strong>
</dt><dd><a href="#1215">#rmexternal</a>
 | <a href="#1233">#setexternalattr</a>
 | <a href="#17514">#rmexternal</a>
 | <a href="#17519">#setexternalattr</a>
 | <a href="#17560">Embedding FORM in other</a>
</dd><dt><strong>#setrandom</strong>
</dt><dd><a href="#1259">#setrandom</a>
 | <a href="#13980">random_</a>
</dd><dt><strong>#show</strong>
</dt><dd><a href="#1265">#show</a>
</dd><dt><strong>#switch</strong>
</dt><dd><a href="#815">#break</a>
 | <a href="#862">#case</a>
 | <a href="#903">#default</a>
 | <a href="#1007">#endswitch</a>
 | <a href="#1289">#switch</a>
 | <a href="#1292">#switch</a>
 | <a href="#1374">Some remarks</a>
</dd><dt><strong>#system</strong>
</dt><dd><a href="#1200">#remove</a>
 | <a href="#1311">#system</a>
 | <a href="#17476">External communication</a>
</dd><dt><strong>#terminate</strong>
</dt><dd><a href="#1314">#terminate</a>
</dd><dt><strong>#toexternal</strong>
</dt><dd><a href="#1021">#external</a>
 | <a href="#1229">#setexternal</a>
 | <a href="#1317">#toexternal</a>
 | <a href="#17490">#external</a>
 | <a href="#17493">#toexternal</a>
 | <a href="#17509">#setexternal</a>
</dd><dt><strong>#undefine</strong>
</dt><dd><a href="#1323">#undefine</a>
</dd><dt><strong>#usedictionary</strong>
</dt><dd><a href="#15529">Dictionaries</a>
</dd><dt><strong>#write</strong>
</dt><dd><a href="#805">#append</a>
 | <a href="#876">#close</a>
 | <a href="#894">#create</a>
 | <a href="#1128">#message</a>
 | <a href="#1318">#toexternal</a>
 | <a href="#1335">#write</a>
 | <a href="#1362">#write</a>
 | <a href="#17495">#toexternal</a>
</dd><dt><strong>$-variable</strong>
</dt><dd><a href="#1012">#exchange</a>
 | <a href="#1348">#write</a>
 | <a href="#2656">Pattern matching</a>
 | <a href="#3624">endinside</a>
 | <a href="#4470">inside</a>
 | <a href="#8501">moduleoption</a>
 | <a href="#8517">moduleoption</a>
 | <a href="#8531">moduleoption</a>
 | <a href="#8545">moduleoption</a>
 | <a href="#5459">print</a>
 | <a href="#5789">redefine</a>
 | <a href="#6341">table</a>
 | <a href="#13804">factorin_</a>
 | <a href="#17348">Some problems</a>
</dd><dt><strong>*...*</strong>
</dt><dd><a href="#771">The triple dot operator</a>
</dd><dt><strong>+...+</strong>
</dt><dd><a href="#767">The triple dot operator</a>
</dd><dt><strong>+...-</strong>
</dt><dd><a href="#769">The triple dot operator</a>
</dd><dt><strong>,...,</strong>
</dt><dd><a href="#773">The triple dot operator</a>
</dd><dt><strong>-...+</strong>
</dt><dd><a href="#770">The triple dot operator</a>
</dd><dt><strong>-...-</strong>
</dt><dd><a href="#768">The triple dot operator</a>
</dd><dt><strong>...</strong>
</dt><dd><a href="#761">The triple dot operator</a>
</dd><dt><strong>.clear</strong>
</dt><dd><a href="#1172">#procedureextension</a>
 | <a href="#2449">Modules</a>
 | <a href="#16799">The setup</a>
</dd><dt><strong>.end</strong>
</dt><dd><a href="#2442">Modules</a>
</dd><dt><strong>.global</strong>
</dt><dd><a href="#2447">Modules</a>
</dd><dt><strong>.prc</strong>
</dt><dd><a href="#850">#call</a>
 | <a href="#1167">#procedureextension</a>
</dd><dt><strong>.sav</strong>
</dt><dd><a href="#5937">save</a>
</dd><dt><strong>.sc1</strong>
</dt><dd><a href="#16818">The setup</a>
</dd><dt><strong>.sc2</strong>
</dt><dd><a href="#16819">The setup</a>
</dd><dt><strong>.sc3</strong>
</dt><dd><a href="#16820">The setup</a>
</dd><dt><strong>.sor extension</strong>
</dt><dd><a href="#15992">Sorting and statistics</a>
</dd><dt><strong>.sort</strong>
</dt><dd><a href="#944">#do</a>
 | <a href="#1365">#write</a>
 | <a href="#2440">Modules</a>
 | <a href="#2467">Modules</a>
 | <a href="#5786">redefine</a>
 | <a href="#6052">sort</a>
 | <a href="#6383">term</a>
</dd><dt><strong>.store</strong>
</dt><dd><a href="#2444">Modules</a>
 | <a href="#3380">delete</a>
 | <a href="#4091">global</a>
 | <a href="#4143">hide</a>
 | <a href="#4587">local</a>
 | <a href="#5933">save</a>
</dd><dt><strong>.str</strong>
</dt><dd><a href="#16836">The setup</a>
</dd><dt><strong>.tbl</strong>
</dt><dd><a href="#15251">The TableBase</a>
</dd><dt><strong>/.../</strong>
</dt><dd><a href="#772">The triple dot operator</a>
</dd><dt><strong>32 bits</strong>
</dt><dd><a href="#740">The preprocessor calculator</a>
 | <a href="#3850">fixindex</a>
 | <a href="#8108">if</a>
 | <a href="#6336">table</a>
 | <a href="#13900">maxpowerof_</a>
 | <a href="#15692">Dirac algebra</a>
 | <a href="#16476">The setup</a>
 | <a href="#16601">The setup</a>
 | <a href="#16619">The setup</a>
 | <a href="#16062">The setup</a>
</dd><dt><strong>64  bits</strong>
</dt><dd><a href="#16063">The setup</a>
</dd><dt><strong>64 bits</strong>
</dt><dd><a href="#743">The preprocessor calculator</a>
 | <a href="#3852">fixindex</a>
 | <a href="#8110">if</a>
 | <a href="#6338">table</a>
 | <a href="#13901">maxpowerof_</a>
 | <a href="#15694">Dirac algebra</a>
 | <a href="#16477">The setup</a>
 | <a href="#16602">The setup</a>
 | <a href="#16620">The setup</a>
</dd><dt><strong>:...:</strong>
</dt><dd><a href="#774">The triple dot operator</a>
</dd><dt><strong>%</strong>
</dt><dd><a href="#1346">#write</a>
</dd><dt><strong>?name</strong>
</dt><dd><a href="#2617">Pattern matching</a>
</dd><dt><strong>aborted</strong>
</dt><dd><a href="#3677">exit</a>
</dd><dt><strong>abrackets</strong>
</dt><dd><a href="#2846">abrackets, antibrackets</a>
</dd><dt><strong>abs_</strong>
</dt><dd><a href="#13678">abs_</a>
</dd><dt><strong>acos_</strong>
</dt><dd><a href="#14119">Extra reserved names</a>
</dd><dt><strong>acosh_</strong>
</dt><dd><a href="#14161">Extra reserved names</a>
</dd><dt><strong>active</strong>
</dt><dd><a href="#4838">nhide</a>
 | <a href="#5461">print</a>
 | <a href="#6027">skip</a>
 | <a href="#6689">unhide</a>
</dd><dt><strong>active expressions</strong>
</dt><dd><a href="#4131">hide</a>
 | <a href="#4500">intohide</a>
</dd><dt><strong>addition</strong>
</dt><dd><a href="#724">The preprocessor calculator</a>
</dd><dt><strong>addto</strong>
</dt><dd><a href="#15258">addto</a>
 | <a href="#15304">off</a>
 | <a href="#15312">on</a>
</dd><dt><strong>Adler</strong>
</dt><dd><dl compact="">
<dt><strong>Mark</strong>
</dt><dd><a href="#15230">The TableBase</a>
</dd></dl>
</dd><dt><strong>algebra</strong>
</dt><dd><dl compact="">
<dt><strong>Dirac</strong>
</dt><dd><a href="#6710">unittrace</a>
</dd></dl>
</dd><dt><strong>algorithms</strong>
</dt><dd><a href="#15710">Dirac algebra</a>
</dd><dt><strong>also</strong>
</dt><dd><a href="#2863">also</a>
 | <a href="#4233">idold</a>
</dd><dt><strong>alternative</strong>
</dt><dd><a href="#3208">collect</a>
</dd><dt><strong>ambiguity</strong>
</dt><dd><a href="#2628">Pattern matching</a>
</dd><dt><strong>and</strong>
</dt><dd><a href="#730">The preprocessor calculator</a>
</dd><dt><strong>antibracket</strong>
</dt><dd><a href="#2880">antiputinside</a>
 | <a href="#3196">collect</a>
 | <a href="#4610">makeinteger</a>
 | <a href="#5558">print[]</a>
 | <a href="#14760">Brackets</a>
</dd><dt><strong>antibrackets</strong>
</dt><dd><a href="#2847">abrackets, antibrackets</a>
</dd><dt><strong>anticommute</strong>
</dt><dd><a href="#15722">Dirac algebra</a>
</dd><dt><strong>antiputinside</strong>
</dt><dd><a href="#2879">antiputinside</a>
</dd><dt><strong>antisymmetric</strong>
</dt><dd><a href="#7340">cfunctions</a>
 | <a href="#7924">functions</a>
 | <a href="#5902">replaceloop</a>
 | <a href="#13744">distrib_</a>
 | <a href="#13773">e_</a>
</dd><dt><strong>antisymmetrize</strong>
</dt><dd><a href="#2898">antisymmetrize</a>
</dd><dt><strong>append</strong>
</dt><dd><a href="#9847">printtable</a>
</dd><dt><strong>apply</strong>
</dt><dd><a href="#2910">apply</a>
 | <a href="#15248">The TableBase</a>
 | <a href="#15267">apply</a>
 | <a href="#15336">use</a>
</dd><dt><strong>argexplode</strong>
</dt><dd><a href="#2942">argimplode</a>
</dd><dt><strong>argimplode</strong>
</dt><dd><a href="#2939">argimplode</a>
</dd><dt><strong>argument</strong>
</dt><dd><a href="#2965">argument</a>
 | <a href="#3507">dropcoefficient</a>
 | <a href="#3570">endargument</a>
 | <a href="#4468">inside</a>
 | <a href="#4605">makeinteger</a>
 | <a href="#4857">normalize</a>
 | <a href="#5379">polyfun</a>
 | <a href="#5404">polyratfun</a>
 | <a href="#6068">splitarg</a>
</dd><dt><strong>argument field</strong>
</dt><dd><a href="#2718">The dollar variables</a>
 | <a href="#6316">table</a>
 | <a href="#14249">Functions</a>
</dd><dt><strong>argument field wildcard</strong>
</dt><dd><a href="#2614">Pattern matching</a>
</dd><dt><strong>argument statement</strong>
</dt><dd><a href="#6071">splitarg</a>
</dd><dt><strong>arguments of functions</strong>
</dt><dd><a href="#16002">Sorting and statistics</a>
</dd><dt><strong>arithmetic</strong>
</dt><dd><a href="#713">The preprocessor calculator</a>
 | <a href="#739">The preprocessor calculator</a>
 | <a href="#2651">Pattern matching</a>
</dd><dt><strong>arithmetic operations</strong>
</dt><dd><a href="#14991">Output optimization</a>
</dd><dt><strong>array</strong>
</dt><dd><a href="#2646">Pattern matching</a>
</dd><dt><strong>asin_</strong>
</dt><dd><a href="#14113">Extra reserved names</a>
</dd><dt><strong>asinh_</strong>
</dt><dd><a href="#14155">Extra reserved names</a>
</dd><dt><strong>atan2_</strong>
</dt><dd><a href="#14131">Extra reserved names</a>
</dd><dt><strong>atan_</strong>
</dt><dd><a href="#14125">Extra reserved names</a>
</dd><dt><strong>atanh_</strong>
</dt><dd><a href="#14167">Extra reserved names</a>
</dd><dt><strong>audit</strong>
</dt><dd><a href="#15274">audit</a>
</dd><dt><strong>auto</strong>
</dt><dd><a href="#2990">auto, autodeclare</a>
</dd><dt><strong>autodeclare</strong>
</dt><dd><a href="#383">The autodeclare conventions</a>
 | <a href="#2991">auto, autodeclare</a>
</dd><dt><strong>backquote</strong>
</dt><dd><a href="#675">The preprocessor variables</a>
 | <a href="#1157">#procedure</a>
</dd><dt><strong>backslash</strong>
</dt><dd><a href="#836">#call</a>
 | <a href="#1345">#write</a>
</dd><dt><strong>bernoulli_</strong>
</dt><dd><a href="#13682">bernoulli_</a>
</dd><dt><strong>binom_</strong>
</dt><dd><a href="#13687">binom_</a>
</dd><dt><strong>binomials</strong>
</dt><dd><a href="#5744">ratio</a>
</dd><dt><strong>Bjorken &amp; Drell metric</strong>
</dt><dd><a href="#15670">Dirac algebra</a>
</dd><dt><strong>bottleneck</strong>
</dt><dd><a href="#17237">The parallel version</a>
</dd><dt><strong>braces</strong>
</dt><dd><a href="#357">Sets</a>
 | <a href="#14769">Brackets</a>
</dd><dt><strong>bracket</strong>
</dt><dd><a href="#1307">#switch</a>
 | <a href="#3047">bracket</a>
 | <a href="#4139">hide</a>
 | <a href="#5557">print[]</a>
 | <a href="#5686">putinside</a>
 | <a href="#6029">skip</a>
 | <a href="#13758">dum_</a>
 | <a href="#14070">termsinbracket_</a>
 | <a href="#14755">Brackets</a>
<dl compact="">
<dt><strong>curly</strong>
</dt><dd><a href="#716">The preprocessor calculator</a>
 | <a href="#2637">Pattern matching</a>
</dd></dl>
</dd><dt><strong>bracket  index</strong>
</dt><dd><a href="#14773">Brackets</a>
</dd><dt><strong>bracket index</strong>
</dt><dd><a href="#4141">hide</a>
</dd><dt><strong>bracketindexsize</strong>
</dt><dd><a href="#14780">Brackets</a>
 | <a href="#16423">The setup</a>
</dd><dt><strong>brackets</strong>
</dt><dd><a href="#3048">bracket</a>
 | <a href="#3195">collect</a>
 | <a href="#3828">fillexpression</a>
 | <a href="#15999">Sorting and statistics</a>
<dl compact="">
<dt><strong>curly</strong>
</dt><dd><a href="#362">Sets</a>
</dd><dt><strong>indexing</strong>
</dt><dd><a href="#3059">bracket</a>
</dd><dt><strong>keep</strong>
</dt><dd><a href="#4516">keep</a>
</dd></dl>
</dd><dt><strong>bucket</strong>
</dt><dd><a href="#6409">threadbucketsize</a>
 | <a href="#17260">TFORM</a>
</dd><dt><strong>buffer</strong>
</dt><dd><dl compact="">
<dt><strong>large</strong>
</dt><dd><a href="#15984">Sorting and statistics</a>
 | <a href="#16284">The setup</a>
</dd><dt><strong>procedure</strong>
</dt><dd><a href="#829">#call</a>
</dd><dt><strong>small</strong>
</dt><dd><a href="#15975">Sorting and statistics</a>
 | <a href="#16279">The setup</a>
</dd></dl>
</dd><dt><strong>bug</strong>
</dt><dd><a href="#458">Some common bugs</a>
</dd><dt><strong>C</strong>
</dt><dd><a href="#729">The preprocessor calculator</a>
 | <a href="#916">#define</a>
 | <a href="#1340">#write</a>
 | <a href="#7779">format</a>
 | <a href="#5503">print</a>
</dd><dt><strong>C-interface</strong>
</dt><dd><a href="#17565">Embedding FORM in other</a>
</dd><dt><strong>cache</strong>
</dt><dd><a href="#16290">The setup</a>
 | <a href="#17270">TFORM</a>
</dd><dt><strong>caches</strong>
</dt><dd><a href="#16835">The setup</a>
</dd><dt><strong>caching</strong>
</dt><dd><a href="#15997">Sorting and statistics</a>
</dd><dt><strong>calculator</strong>
</dt><dd><a href="#714">The preprocessor calculator</a>
 | <a href="#840">#call</a>
 | <a href="#939">#do</a>
<dl compact="">
<dt><strong>preprocessor</strong>
</dt><dd><a href="#365">Sets</a>
</dd></dl>
</dd><dt><strong>caveat</strong>
</dt><dd><a href="#428">Dummy indices</a>
</dd><dt><strong>chainin</strong>
</dt><dd><a href="#3124">chainin</a>
</dd><dt><strong>chainout</strong>
</dt><dd><a href="#3135">chainout</a>
</dd><dt><strong>channel</strong>
</dt><dd><dl compact="">
<dt><strong>external</strong>
</dt><dd><a href="#17484">External communication</a>
</dd></dl>
</dd><dt><strong>checkpoints</strong>
</dt><dd><a href="#2479">Checkpoints</a>
</dd><dt><strong>Chinese  remainder theorem</strong>
</dt><dd><a href="#13972">prime_</a>
</dd><dt><strong>Chinese remainder theorem</strong>
</dt><dd><a href="#13787">exteuclidean_</a>
</dd><dt><strong>chisholm</strong>
</dt><dd><a href="#3149">chisholm</a>
 | <a href="#10356">trace4</a>
 | <a href="#10371">trace4</a>
 | <a href="#10386">trace4</a>
 | <a href="#15696">Dirac algebra</a>
 | <a href="#15705">Dirac algebra</a>
 | <a href="#15714">Dirac algebra</a>
 | <a href="#15717">Dirac algebra</a>
</dd><dt><strong>clock</strong>
</dt><dd><a href="#2451">Modules</a>
</dd><dt><strong>CMODULE_</strong>
</dt><dd><a href="#684">The preprocessor variables</a>
</dd><dt><strong>coeff_</strong>
</dt><dd><a href="#235">Symbols</a>
</dd><dt><strong>coefficient</strong>
</dt><dd><a href="#7534">factarg</a>
 | <a href="#8214">if</a>
 | <a href="#4858">normalize</a>
 | <a href="#5380">polyfun</a>
 | <a href="#5385">polyfun</a>
 | <a href="#5405">polyratfun</a>
 | <a href="#5410">polyratfun</a>
</dd><dt><strong>coefficients</strong>
</dt><dd><dl compact="">
<dt><strong>integer</strong>
</dt><dd><a href="#4606">makeinteger</a>
</dd></dl>
</dd><dt><strong>collect</strong>
</dt><dd><a href="#947">#do</a>
 | <a href="#3194">collect</a>
 | <a href="#14791">Brackets</a>
</dd><dt><strong>colon</strong>
</dt><dd><a href="#321">Sets</a>
</dd><dt><strong>color package</strong>
</dt><dd><a href="#5913">replaceloop</a>
</dd><dt><strong>combinatorics</strong>
</dt><dd><a href="#13723">dd_</a>
 | <a href="#13741">distrib_</a>
</dd><dt><strong>comma</strong>
</dt><dd><a href="#367">Sets</a>
 | <a href="#746">The preprocessor calculator</a>
</dd><dt><strong>command shell</strong>
</dt><dd><a href="#17478">External communication</a>
</dd><dt><strong>commentary</strong>
</dt><dd><a href="#662">The preprocessor</a>
 | <a href="#886">#commentchar</a>
 | <a href="#1116">#include</a>
</dd><dt><strong>commentchar</strong>
</dt><dd><a href="#16440">The setup</a>
</dd><dt><strong>Common subexpression elimination</strong>
</dt><dd><a href="#15036">Optimization options of the</a>
</dd><dt><strong>communication</strong>
</dt><dd><a href="#17233">The parallel version</a>
<dl compact="">
<dt><strong>external</strong>
</dt><dd><a href="#17473">External communication</a>
</dd><dt><strong>two way</strong>
</dt><dd><a href="#17481">External communication</a>
</dd></dl>
</dd><dt><strong>commuteinset</strong>
</dt><dd><a href="#3223">commuteinset</a>
</dd><dt><strong>commuting</strong>
</dt><dd><a href="#295">Functions</a>
 | <a href="#2595">Pattern matching</a>
 | <a href="#7203">auto, autodeclare</a>
 | <a href="#3078">cfunctions</a>
 | <a href="#3237">commuting</a>
 | <a href="#3318">ctable</a>
 | <a href="#3333">ctensors</a>
 | <a href="#4001">functions</a>
 | <a href="#8089">identify</a>
 | <a href="#6301">table</a>
 | <a href="#6363">tensors</a>
 | <a href="#13646">Functions</a>
</dd><dt><strong>compilation</strong>
</dt><dd><a href="#5780">redefine</a>
</dd><dt><strong>compile</strong>
</dt><dd><a href="#15237">The TableBase</a>
</dd><dt><strong>compiler</strong>
</dt><dd><a href="#660">The preprocessor</a>
</dd><dt><strong>complex</strong>
</dt><dd><a href="#223">Symbols</a>
 | <a href="#301">Functions</a>
 | <a href="#7295">cfunctions</a>
 | <a href="#7879">functions</a>
 | <a href="#10025">symbols</a>
 | <a href="#15859">A few notes on</a>
</dd><dt><strong>complicated</strong>
</dt><dd><a href="#354">Sets</a>
</dd><dt><strong>complication</strong>
</dt><dd><a href="#3203">collect</a>
 | <a href="#15969">Sorting and statistics</a>
</dd><dt><strong>compress</strong>
</dt><dd><a href="#3250">compress</a>
 | <a href="#15288">enter</a>
 | <a href="#15303">off</a>
 | <a href="#15310">on</a>
</dd><dt><strong>compressed</strong>
</dt><dd><a href="#15220">The TableBase</a>
</dd><dt><strong>compresssize</strong>
</dt><dd><a href="#16454">The setup</a>
</dd><dt><strong>condition</strong>
</dt><dd><a href="#4255">if</a>
</dd><dt><strong>conflicts</strong>
</dt><dd><a href="#387">The autodeclare conventions</a>
</dd><dt><strong>conjg_</strong>
</dt><dd><a href="#13691">conjg_</a>
</dd><dt><strong>conjugate</strong>
</dt><dd><dl compact="">
<dt><strong>complex</strong>
</dt><dd><a href="#211">Names</a>
</dd></dl>
</dd><dt><strong>conjugation</strong>
</dt><dd><a href="#15856">A few notes on</a>
<dl compact="">
<dt><strong>complex</strong>
</dt><dd><a href="#219">Symbols</a>
</dd></dl>
</dd><dt><strong>constindex</strong>
</dt><dd><a href="#3846">fixindex</a>
 | <a href="#16469">The setup</a>
</dd><dt><strong>content_</strong>
</dt><dd><a href="#13695">content_</a>
</dd><dt><strong>continuationlines</strong>
</dt><dd><a href="#16485">The setup</a>
</dd><dt><strong>contract</strong>
</dt><dd><a href="#3262">contract</a>
 | <a href="#15702">Dirac algebra</a>
</dd><dt><strong>contracted  indices</strong>
</dt><dd><a href="#5860">replaceloop</a>
</dd><dt><strong>contraction</strong>
</dt><dd><a href="#15846">A few notes on</a>
</dd><dt><strong>contractions</strong>
</dt><dd><dl compact="">
<dt><strong>trace</strong>
</dt><dd><a href="#7516">dimension</a>
</dd></dl>
</dd><dt><strong>conv2to3</strong>
</dt><dd><a href="#5013">nwrite</a>
</dd><dt><strong>cos_</strong>
</dt><dd><a href="#14101">Extra reserved names</a>
</dd><dt><strong>cosh_</strong>
</dt><dd><a href="#14143">Extra reserved names</a>
</dd><dt><strong>count</strong>
</dt><dd><a href="#8099">if</a>
 | <a href="#10085">symbols</a>
</dd><dt><strong>count_</strong>
</dt><dd><a href="#13708">count_</a>
</dd><dt><strong>CPU time</strong>
</dt><dd><a href="#17284">TFORM</a>
</dd><dt><strong>crash</strong>
</dt><dd><a href="#2481">Checkpoints</a>
</dd><dt><strong>crashed FORM program</strong>
</dt><dd><a href="#2510">Checkpoints</a>
</dd><dt><strong>create</strong>
</dt><dd><a href="#15278">create</a>
 | <a href="#15317">open</a>
</dd><dt><strong>CSE</strong>
</dt><dd><a href="#15035">Optimization options of the</a>
</dd><dt><strong>curly bracket</strong>
</dt><dd><a href="#715">The preprocessor calculator</a>
</dd><dt><strong>cycle</strong>
</dt><dd><a href="#10540">transform</a>
</dd><dt><strong>cycle symmetric</strong>
</dt><dd><a href="#7355">cfunctions</a>
 | <a href="#7939">functions</a>
</dd><dt><strong>cyclesymmetric</strong>
</dt><dd><a href="#5899">replaceloop</a>
</dd><dt><strong>cyclesymmetrize</strong>
</dt><dd><a href="#3350">cyclesymmetrize</a>
</dd><dt><strong>Cygwin</strong>
</dt><dd><a href="#113">Running FORM</a>
</dd><dt><strong>d_</strong>
</dt><dd><a href="#13713">d_</a>
</dd><dt><strong>daemon</strong>
</dt><dd><a href="#1241">#setexternalattr</a>
 | <a href="#17529">#setexternalattr</a>
</dd><dt><strong>dangerous</strong>
</dt><dd><a href="#15868">A few notes on</a>
</dd><dt><strong>database</strong>
</dt><dd><a href="#15213">The TableBase</a>
</dd><dt><strong>DATE_</strong>
</dt><dd><a href="#683">The preprocessor variables</a>
</dd><dt><strong>dd_</strong>
</dt><dd><a href="#13720">dd_</a>
</dd><dt><strong>deallocatetable</strong>
</dt><dd><a href="#3362">deallocatetable</a>
</dd><dt><strong>debugging</strong>
</dt><dd><a href="#5460">print</a>
 | <a href="#15046">Optimization options of the</a>
</dd><dt><strong>declarations</strong>
</dt><dd><a href="#2431">Modules</a>
</dd><dt><strong>decode</strong>
</dt><dd><a href="#10466">transform</a>
</dd><dt><strong>default dimension</strong>
</dt><dd><a href="#6172">sum</a>
</dd><dt><strong>define</strong>
</dt><dd><a href="#16500">The setup</a>
</dd><dt><strong>definitions</strong>
</dt><dd><a href="#2433">Modules</a>
</dd><dt><strong>delayed substitution</strong>
</dt><dd><a href="#917">#define</a>
 | <a href="#2733">The dollar variables</a>
</dd><dt><strong>delete</strong>
</dt><dd><a href="#3377">delete</a>
 | <a href="#3381">delete</a>
</dd><dt><strong>delta</strong>
</dt><dd><dl compact="">
<dt><strong>Kronecker</strong>
</dt><dd><a href="#270">Indices</a>
 | <a href="#435">Kronecker delta's</a>
 | <a href="#3267">contract</a>
 | <a href="#13717">d_</a>
 | <a href="#15837">A few notes on</a>
 | <a href="#15867">A few notes on</a>
</dd></dl>
</dd><dt><strong>delta_</strong>
</dt><dd><a href="#13726">delta_</a>
</dd><dt><strong>deltap_</strong>
</dt><dd><a href="#13730">deltap_</a>
</dd><dt><strong>den_</strong>
</dt><dd><a href="#237">Symbols</a>
</dd><dt><strong>denom_</strong>
</dt><dd><a href="#13734">denom_</a>
</dd><dt><strong>denominators</strong>
</dt><dd><a href="#193">Names</a>
 | <a href="#3393">denominators</a>
</dd><dt><strong>deterministic</strong>
</dt><dd><a href="#17342">Some problems</a>
</dd><dt><strong>dictionaries</strong>
</dt><dd><a href="#15516">Dictionaries</a>
</dd><dt><strong>dimension</strong>
</dt><dd><a href="#244">Vectors</a>
 | <a href="#262">Indices</a>
 | <a href="#4415">index, indices</a>
<dl compact="">
<dt><strong>default</strong>
</dt><dd><a href="#407">Dummy indices</a>
 | <a href="#3408">dimension</a>
 | <a href="#6173">sum</a>
</dd></dl>
</dd><dt><strong>Dirac</strong>
</dt><dd><a href="#6709">unittrace</a>
 | <a href="#13824">g5_</a>
 | <a href="#13841">g_</a>
</dd><dt><strong>Dirac algebra</strong>
</dt><dd><a href="#15665">Dirac algebra</a>
</dd><dt><strong>discard</strong>
</dt><dd><a href="#3445">discard</a>
 | <a href="#10088">symbols</a>
</dd><dt><strong>disk to disk sort</strong>
</dt><dd><a href="#15993">Sorting and statistics</a>
</dd><dt><strong>disorder</strong>
</dt><dd><a href="#3460">disorder</a>
 | <a href="#8079">identify</a>
</dd><dt><strong>distrib_</strong>
</dt><dd><a href="#5999">shuffle</a>
 | <a href="#13738">distrib_</a>
 | <a href="#15732">Dirac algebra</a>
</dd><dt><strong>div_</strong>
</dt><dd><a href="#13748">div_</a>
 | <a href="#14882">Polynomials and Factorization</a>
</dd><dt><strong>division</strong>
</dt><dd><a href="#727">The preprocessor calculator</a>
</dd><dt><strong>do loop</strong>
</dt><dd><a href="#929">#do</a>
 | <a href="#975">#enddo</a>
</dd><dt><strong>dollar</strong>
</dt><dd><a href="#3791">fill</a>
<dl compact="">
<dt><strong>printing</strong>
</dt><dd><a href="#2750">The dollar variables</a>
</dd></dl>
</dd><dt><strong>dotchar</strong>
</dt><dd><a href="#200">Names</a>
 | <a href="#7789">format</a>
 | <a href="#16517">The setup</a>
</dd><dt><strong>dotproducts</strong>
</dt><dd><a href="#197">Names</a>
 | <a href="#16524">The setup</a>
</dd><dt><strong>double quote</strong>
</dt><dd><a href="#1344">#write</a>
</dd><dt><strong>doublefortran</strong>
</dt><dd><a href="#7718">format</a>
 | <a href="#15554">Dictionaries</a>
</dd><dt><strong>drop</strong>
</dt><dd><a href="#3495">drop</a>
 | <a href="#4586">local</a>
 | <a href="#4788">ndrop</a>
</dd><dt><strong>dum_</strong>
</dt><dd><a href="#4612">makeinteger</a>
 | <a href="#13754">dum_</a>
</dd><dt><strong>dummy</strong>
</dt><dd><a href="#5802">renumber</a>
 | <a href="#6170">sum</a>
 | <a href="#14211">Functions</a>
</dd><dt><strong>dummy arguments</strong>
</dt><dd><a href="#4098">global</a>
</dd><dt><strong>dummy_</strong>
</dt><dd><a href="#13760">dummy_</a>
</dd><dt><strong>dummyindices_</strong>
</dt><dd><a href="#345">Sets</a>
</dd><dt><strong>dummyten_</strong>
</dt><dd><a href="#13764">dummyten_</a>
</dd><dt><strong>dynamical loading</strong>
</dt><dd><a href="#3825">fillexpression</a>
</dd><dt><strong>e_</strong>
</dt><dd><a href="#13768">e_</a>
</dd><dt><strong>edit</strong>
</dt><dd><a href="#659">The preprocessor</a>
 | <a href="#673">The preprocessor variables</a>
</dd><dt><strong>efficient</strong>
</dt><dd><a href="#15967">Sorting and statistics</a>
</dd><dt><strong>Einstein</strong>
</dt><dd><a href="#263">Indices</a>
 | <a href="#310">Functions</a>
 | <a href="#436">Kronecker delta's</a>
</dd><dt><strong>elements</strong>
</dt><dd><a href="#5974">set</a>
</dd><dt><strong>else</strong>
</dt><dd><a href="#3530">else</a>
 | <a href="#3559">elseif</a>
 | <a href="#4256">if</a>
</dd><dt><strong>else statement</strong>
</dt><dd><a href="#3529">else</a>
 | <a href="#3558">elseif</a>
</dd><dt><strong>elseif</strong>
</dt><dd><a href="#3536">else</a>
 | <a href="#3557">elseif</a>
 | <a href="#4258">if</a>
</dd><dt><strong>elseif statement</strong>
</dt><dd><a href="#3556">elseif</a>
</dd><dt><strong>embed</strong>
</dt><dd><a href="#17549">Embedding FORM in other</a>
</dd><dt><strong>encode</strong>
</dt><dd><a href="#10452">transform</a>
</dd><dt><strong>end of module specifications</strong>
</dt><dd><a href="#2436">Modules</a>
</dd><dt><strong>endargument</strong>
</dt><dd><a href="#2968">argument</a>
 | <a href="#3508">dropcoefficient</a>
 | <a href="#3571">endargument</a>
</dd><dt><strong>endif</strong>
</dt><dd><a href="#3532">else</a>
 | <a href="#3554">elseif</a>
 | <a href="#3597">endif</a>
 | <a href="#4260">if</a>
</dd><dt><strong>endif statement</strong>
</dt><dd><a href="#3531">else</a>
 | <a href="#3553">elseif</a>
 | <a href="#3596">endif</a>
</dd><dt><strong>endinexpression</strong>
</dt><dd><a href="#3606">endinexpression</a>
</dd><dt><strong>endinside</strong>
</dt><dd><a href="#4471">inside</a>
</dd><dt><strong>endrepeat</strong>
</dt><dd><a href="#3638">endrepeat</a>
 | <a href="#5825">repeat</a>
</dd><dt><strong>endterm</strong>
</dt><dd><a href="#3651">endterm</a>
 | <a href="#6379">term</a>
</dd><dt><strong>endwhile</strong>
</dt><dd><a href="#3665">endwhile</a>
 | <a href="#6736">while</a>
</dd><dt><strong>enter</strong>
</dt><dd><a href="#15285">enter</a>
</dd><dt><strong>environment</strong>
</dt><dd><a href="#703">The preprocessor variables</a>
 | <a href="#16336">The setup</a>
<dl compact="">
<dt><strong>argument</strong>
</dt><dd><a href="#2966">argument</a>
 | <a href="#3568">endargument</a>
</dd><dt><strong>inside</strong>
</dt><dd><a href="#3622">endinside</a>
</dd><dt><strong>repeat</strong>
</dt><dd><a href="#3636">endrepeat</a>
</dd><dt><strong>term</strong>
</dt><dd><a href="#3649">endterm</a>
 | <a href="#6049">sort</a>
 | <a href="#6378">term</a>
</dd><dt><strong>while</strong>
</dt><dd><a href="#3663">endwhile</a>
 | <a href="#6735">while</a>
</dd></dl>
</dd><dt><strong>environment variables</strong>
</dt><dd><a href="#133">Running FORM</a>
</dd><dt><strong>error</strong>
</dt><dd><a href="#457">Some common bugs</a>
<dl compact="">
<dt><strong>runtime</strong>
</dt><dd><a href="#2721">The dollar variables</a>
</dd></dl>
</dd><dt><strong>error stream</strong>
</dt><dd><a href="#17536">#setexternalattr</a>
</dd><dt><strong>even_</strong>
</dt><dd><a href="#341">Sets</a>
</dd><dt><strong>exclamation</strong>
</dt><dd><a href="#370">Sets</a>
</dd><dt><strong>executable statements</strong>
</dt><dd><a href="#2434">Modules</a>
</dd><dt><strong>execution</strong>
</dt><dd><a href="#2422">Modules</a>
 | <a href="#5988">setexitflag</a>
</dd><dt><strong>exists</strong>
</dt><dd><a href="#1427">#if</a>
</dd><dt><strong>exit</strong>
</dt><dd><a href="#3676">exit</a>
</dd><dt><strong>exp_</strong>
</dt><dd><a href="#13776">exp_</a>
</dd><dt><strong>explode</strong>
</dt><dd><a href="#10498">transform</a>
</dd><dt><strong>exponent</strong>
</dt><dd><a href="#732">The preprocessor calculator</a>
</dd><dt><strong>exponent operator</strong>
</dt><dd><a href="#7787">format</a>
</dd><dt><strong>expression</strong>
</dt><dd><a href="#181">Variables</a>
 | <a href="#1011">#exchange</a>
 | <a href="#1349">#write</a>
 | <a href="#3496">drop</a>
 | <a href="#4090">global</a>
 | <a href="#8146">if</a>
 | <a href="#8159">if</a>
 | <a href="#13805">factorin_</a>
</dd><dt><strong>extension</strong>
</dt><dd><dl compact="">
<dt><strong>.sav</strong>
</dt><dd><a href="#5938">save</a>
</dd><dt><strong>small</strong>
</dt><dd><a href="#15977">Sorting and statistics</a>
</dd></dl>
</dd><dt><strong>exteuclidean_</strong>
</dt><dd><a href="#13780">exteuclidean_</a>
</dd><dt><strong>extform.pdf</strong>
</dt><dd><a href="#17483">External communication</a>
</dd><dt><strong>extform.ps</strong>
</dt><dd><a href="#17482">External communication</a>
</dd><dt><strong>extra symbols</strong>
</dt><dd><a href="#1277">#skipextrasymbols</a>
 | <a href="#3383">delete</a>
 | <a href="#3694">extrasymbols</a>
 | <a href="#14994">Output optimization</a>
 | <a href="#15000">Output optimization</a>
 | <a href="#15002">Output optimization</a>
 | <a href="#15581">Dictionaries</a>
</dd><dt><strong>extrasymbol_</strong>
</dt><dd><a href="#13791">extrasymbol_</a>
</dd><dt><strong>extrasymbols</strong>
</dt><dd><a href="#1357">#write</a>
</dd><dt><strong>extrasymbols_</strong>
</dt><dd><a href="#238">Symbols</a>
 | <a href="#686">The preprocessor variables</a>
</dd><dt><strong>fac_</strong>
</dt><dd><a href="#13796">fac_</a>
</dd><dt><strong>factarg</strong>
</dt><dd><a href="#3711">factarg</a>
 | <a href="#8941">off</a>
 | <a href="#9343">on</a>
</dd><dt><strong>factorial</strong>
</dt><dd><a href="#733">The preprocessor calculator</a>
 | <a href="#13799">fac_</a>
 | <a href="#13881">invfac_</a>
</dd><dt><strong>factorin_</strong>
</dt><dd><a href="#13801">factorin_</a>
</dd><dt><strong>fall-through</strong>
</dt><dd><a href="#1303">#switch</a>
</dd><dt><strong>farg_</strong>
</dt><dd><a href="#13809">farg_</a>
</dd><dt><strong>file</strong>
</dt><dd><a href="#1353">#write</a>
<dl compact="">
<dt><strong>close</strong>
</dt><dd><a href="#875">#close</a>
</dd><dt><strong>disk</strong>
</dt><dd><a href="#4096">global</a>
</dd><dt><strong>hide</strong>
</dt><dd><a href="#4134">hide</a>
 | <a href="#6688">unhide</a>
</dd><dt><strong>include</strong>
</dt><dd><a href="#1299">#switch</a>
</dd><dt><strong>input</strong>
</dt><dd><a href="#116">Running FORM</a>
 | <a href="#15287">enter</a>
</dd><dt><strong>intermediate</strong>
</dt><dd><a href="#2426">Modules</a>
</dd><dt><strong>log</strong>
</dt><dd><a href="#128">Running FORM</a>
 | <a href="#9572">print</a>
 | <a href="#9587">print</a>
 | <a href="#5596">printtable</a>
</dd><dt><strong>new</strong>
</dt><dd><a href="#15279">create</a>
</dd><dt><strong>program</strong>
</dt><dd><a href="#16059">The setup</a>
</dd><dt><strong>saved</strong>
</dt><dd><a href="#4568">load</a>
</dd><dt><strong>setup</strong>
</dt><dd><a href="#139">Running FORM</a>
 | <a href="#141">Running FORM</a>
 | <a href="#16058">The setup</a>
</dd><dt><strong>sort</strong>
</dt><dd><a href="#16288">The setup</a>
 | <a href="#17271">TFORM</a>
</dd><dt><strong>storage</strong>
</dt><dd><a href="#2446">Modules</a>
 | <a href="#3379">delete</a>
 | <a href="#4093">global</a>
 | <a href="#4570">load</a>
</dd><dt><strong>store</strong>
</dt><dd><a href="#5932">save</a>
 | <a href="#16837">The setup</a>
</dd><dt><strong>temporary</strong>
</dt><dd><a href="#137">Running FORM</a>
</dd></dl>
</dd><dt><strong>filepatches</strong>
</dt><dd><a href="#15996">Sorting and statistics</a>
 | <a href="#16289">The setup</a>
 | <a href="#16995">The setup</a>
</dd><dt><strong>files</strong>
</dt><dd><dl compact="">
<dt><strong>.sav</strong>
</dt><dd><a href="#430">Dummy indices</a>
</dd></dl>
</dd><dt><strong>fill</strong>
</dt><dd><a href="#3365">deallocatetable</a>
 | <a href="#3774">fill</a>
 | <a href="#3829">fillexpression</a>
 | <a href="#5597">printtable</a>
 | <a href="#6311">table</a>
 | <a href="#15216">The TableBase</a>
 | <a href="#15260">addto</a>
 | <a href="#15268">apply</a>
 | <a href="#15286">enter</a>
 | <a href="#15295">load</a>
</dd><dt><strong>fillexpression</strong>
</dt><dd><a href="#3824">fillexpression</a>
 | <a href="#5590">printtable</a>
 | <a href="#14046">table_</a>
</dd><dt><strong>filter</strong>
</dt><dd><a href="#17485">External communication</a>
</dd><dt><strong>findloop</strong>
</dt><dd><a href="#8172">if</a>
 | <a href="#5915">replaceloop</a>
</dd><dt><strong>firstbracket_</strong>
</dt><dd><a href="#13813">firstbracket_</a>
</dd><dt><strong>firstterm_</strong>
</dt><dd><a href="#13817">firstterm_</a>
</dd><dt><strong>fixed index</strong>
</dt><dd><a href="#3844">fixindex</a>
</dd><dt><strong>fixed_</strong>
</dt><dd><a href="#338">Sets</a>
</dd><dt><strong>fixindex</strong>
</dt><dd><a href="#2642">Pattern matching</a>
 | <a href="#3843">fixindex</a>
 | <a href="#15869">A few notes on</a>
</dd><dt><strong>flexibility</strong>
</dt><dd><a href="#15865">A few notes on</a>
</dd><dt><strong>float</strong>
</dt><dd><a href="#7579">format</a>
</dd><dt><strong>floating point</strong>
</dt><dd><a href="#7589">format</a>
</dd><dt><strong>fold</strong>
</dt><dd><a href="#1108">#include</a>
</dd><dt><strong>folders</strong>
</dt><dd><a href="#17502">#fromexternal</a>
</dd><dt><strong>foldname</strong>
</dt><dd><a href="#1107">#include</a>
</dd><dt><strong>folds</strong>
</dt><dd><a href="#1297">#switch</a>
</dd><dt><strong>form.set</strong>
</dt><dd><a href="#143">Running FORM</a>
 | <a href="#16060">The setup</a>
</dd><dt><strong>FORM_PIPES</strong>
</dt><dd><a href="#17568">Embedding FORM in other</a>
</dd><dt><strong>format</strong>
</dt><dd><a href="#2755">The dollar variables</a>
 | <a href="#3865">format</a>
 | <a href="#9639">print</a>
 | <a href="#9820">printtable</a>
<dl compact="">
<dt><strong>C</strong>
</dt><dd><a href="#7780">format</a>
</dd><dt><strong>doublefortran</strong>
</dt><dd><a href="#7719">format</a>
</dd><dt><strong>float</strong>
</dt><dd><a href="#7580">format</a>
</dd><dt><strong>fortran</strong>
</dt><dd><a href="#7703">format</a>
</dd><dt><strong>fortran90</strong>
</dt><dd><a href="#7763">format</a>
</dd><dt><strong>maple</strong>
</dt><dd><a href="#7799">format</a>
</dd><dt><strong>mathematica</strong>
</dt><dd><a href="#7813">format</a>
</dd><dt><strong>normal</strong>
</dt><dd><a href="#7841">format</a>
</dd><dt><strong>nospaces</strong>
</dt><dd><a href="#7611">format</a>
</dd><dt><strong>optimize</strong>
</dt><dd><a href="#7639">format</a>
 | <a href="#7655">format</a>
 | <a href="#7671">format</a>
 | <a href="#7687">format</a>
</dd><dt><strong>quadfortran</strong>
</dt><dd><a href="#7749">format</a>
</dd><dt><strong>quadruplefortran</strong>
</dt><dd><a href="#7734">format</a>
</dd><dt><strong>rational</strong>
</dt><dd><a href="#7597">format</a>
</dd><dt><strong>reduce</strong>
</dt><dd><a href="#7827">format</a>
</dd><dt><strong>spaces</strong>
</dt><dd><a href="#7625">format</a>
</dd></dl>
</dd><dt><strong>format string</strong>
</dt><dd><a href="#1339">#write</a>
 | <a href="#5501">print</a>
</dd><dt><strong>FORMPATH</strong>
</dt><dd><a href="#135">Running FORM</a>
 | <a href="#833">#call</a>
 | <a href="#1111">#include</a>
 | <a href="#1355">#write</a>
 | <a href="#15318">open</a>
</dd><dt><strong>FORMSETUP</strong>
</dt><dd><a href="#138">Running FORM</a>
</dd><dt><strong>FORMTMP</strong>
</dt><dd><a href="#136">Running FORM</a>
</dd><dt><strong>fortran</strong>
</dt><dd><a href="#199">Names</a>
 | <a href="#1350">#write</a>
 | <a href="#1366">#write</a>
 | <a href="#7702">format</a>
 | <a href="#15549">Dictionaries</a>
 | <a href="#16525">The setup</a>
</dd><dt><strong>fortran90</strong>
</dt><dd><a href="#7762">format</a>
</dd><dt><strong>fractions</strong>
</dt><dd><a href="#4734">modulus</a>
</dd><dt><strong>function</strong>
</dt><dd><a href="#4820">nfunctions</a>
 | <a href="#13645">Functions</a>
<dl compact="">
<dt><strong>abs_</strong>
</dt><dd><a href="#13679">abs_</a>
</dd><dt><strong>acos_</strong>
</dt><dd><a href="#14120">Extra reserved names</a>
</dd><dt><strong>acosh_</strong>
</dt><dd><a href="#14162">Extra reserved names</a>
</dd><dt><strong>asin_</strong>
</dt><dd><a href="#14114">Extra reserved names</a>
</dd><dt><strong>asinh_</strong>
</dt><dd><a href="#14156">Extra reserved names</a>
</dd><dt><strong>atan2_</strong>
</dt><dd><a href="#14132">Extra reserved names</a>
</dd><dt><strong>atan_</strong>
</dt><dd><a href="#14126">Extra reserved names</a>
</dd><dt><strong>atanh_</strong>
</dt><dd><a href="#14168">Extra reserved names</a>
</dd><dt><strong>bernoulli_</strong>
</dt><dd><a href="#13683">bernoulli_</a>
</dd><dt><strong>binom_</strong>
</dt><dd><a href="#13688">binom_</a>
</dd><dt><strong>commuting</strong>
</dt><dd><a href="#296">Functions</a>
</dd><dt><strong>conjg_</strong>
</dt><dd><a href="#13692">conjg_</a>
</dd><dt><strong>content_</strong>
</dt><dd><a href="#13696">content_</a>
</dd><dt><strong>cos_</strong>
</dt><dd><a href="#14102">Extra reserved names</a>
</dd><dt><strong>cosh_</strong>
</dt><dd><a href="#14144">Extra reserved names</a>
</dd><dt><strong>count_</strong>
</dt><dd><a href="#13709">count_</a>
</dd><dt><strong>d_</strong>
</dt><dd><a href="#13714">d_</a>
</dd><dt><strong>dd_</strong>
</dt><dd><a href="#13721">dd_</a>
</dd><dt><strong>delta_</strong>
</dt><dd><a href="#13727">delta_</a>
</dd><dt><strong>deltap_</strong>
</dt><dd><a href="#13731">deltap_</a>
</dd><dt><strong>denom_</strong>
</dt><dd><a href="#13735">denom_</a>
</dd><dt><strong>distrib_</strong>
</dt><dd><a href="#6000">shuffle</a>
 | <a href="#13739">distrib_</a>
</dd><dt><strong>div_</strong>
</dt><dd><a href="#13749">div_</a>
 | <a href="#14883">Polynomials and Factorization</a>
</dd><dt><strong>dum_</strong>
</dt><dd><a href="#13755">dum_</a>
</dd><dt><strong>dummy_</strong>
</dt><dd><a href="#13761">dummy_</a>
</dd><dt><strong>dummyten_</strong>
</dt><dd><a href="#13765">dummyten_</a>
</dd><dt><strong>e_</strong>
</dt><dd><a href="#13769">e_</a>
</dd><dt><strong>exp_</strong>
</dt><dd><a href="#13777">exp_</a>
</dd><dt><strong>exteuclidean_</strong>
</dt><dd><a href="#13781">exteuclidean_</a>
</dd><dt><strong>extrasymbol_</strong>
</dt><dd><a href="#13792">extrasymbol_</a>
</dd><dt><strong>fac_</strong>
</dt><dd><a href="#13797">fac_</a>
</dd><dt><strong>factorin_</strong>
</dt><dd><a href="#13802">factorin_</a>
</dd><dt><strong>farg_</strong>
</dt><dd><a href="#13810">farg_</a>
</dd><dt><strong>firstbracket_</strong>
</dt><dd><a href="#13814">firstbracket_</a>
</dd><dt><strong>firstterm_</strong>
</dt><dd><a href="#13818">firstterm_</a>
</dd><dt><strong>g5_</strong>
</dt><dd><a href="#13822">g5_</a>
</dd><dt><strong>g6_</strong>
</dt><dd><a href="#13829">g6_</a>
</dd><dt><strong>g7_</strong>
</dt><dd><a href="#13834">g7_</a>
</dd><dt><strong>g_</strong>
</dt><dd><a href="#13839">g_</a>
</dd><dt><strong>gcd_</strong>
</dt><dd><a href="#13845">gcd_</a>
 | <a href="#14880">Polynomials and Factorization</a>
</dd><dt><strong>gi_</strong>
</dt><dd><a href="#13851">gi_</a>
</dd><dt><strong>id_</strong>
</dt><dd><a href="#13855">id_</a>
</dd><dt><strong>integer_</strong>
</dt><dd><a href="#13870">integer_</a>
</dd><dt><strong>inverse_</strong>
</dt><dd><a href="#13875">inverse_</a>
</dd><dt><strong>invfac_</strong>
</dt><dd><a href="#13879">invfac_</a>
</dd><dt><strong>li2_</strong>
</dt><dd><a href="#14174">Extra reserved names</a>
</dd><dt><strong>lin_</strong>
</dt><dd><a href="#14180">Extra reserved names</a>
</dd><dt><strong>ln_</strong>
</dt><dd><a href="#14090">Extra reserved names</a>
</dd><dt><strong>makerational_</strong>
</dt><dd><a href="#13884">makerational_</a>
</dd><dt><strong>match_</strong>
</dt><dd><a href="#13890">match_</a>
</dd><dt><strong>max_</strong>
</dt><dd><a href="#13894">max_</a>
</dd><dt><strong>maxpowerof_</strong>
</dt><dd><a href="#13898">maxpowerof_</a>
</dd><dt><strong>min_</strong>
</dt><dd><a href="#13904">min_</a>
</dd><dt><strong>minpowerof_</strong>
</dt><dd><a href="#13908">minpowerof_</a>
</dd><dt><strong>mod2_</strong>
</dt><dd><a href="#13920">mod2_</a>
</dd><dt><strong>mod_</strong>
</dt><dd><a href="#13912">mod_</a>
</dd><dt><strong>nargs_</strong>
</dt><dd><a href="#13925">nargs_</a>
</dd><dt><strong>non-commuting</strong>
</dt><dd><a href="#298">Functions</a>
</dd><dt><strong>nterms_</strong>
</dt><dd><a href="#13929">nterms_</a>
</dd><dt><strong>numfactors_</strong>
</dt><dd><a href="#13933">numfactors_</a>
</dd><dt><strong>pattern_</strong>
</dt><dd><a href="#13939">pattern_</a>
</dd><dt><strong>poly_</strong>
</dt><dd><a href="#13943">poly_</a>
</dd><dt><strong>polyadd_</strong>
</dt><dd><a href="#13946">poly_</a>
</dd><dt><strong>polydiv_</strong>
</dt><dd><a href="#13752">div_</a>
 | <a href="#13948">poly_</a>
</dd><dt><strong>polygcd_</strong>
</dt><dd><a href="#13848">gcd_</a>
 | <a href="#13950">poly_</a>
 | <a href="#14937">Polynomials and Factorization</a>
</dd><dt><strong>polyintfac_</strong>
</dt><dd><a href="#13952">poly_</a>
</dd><dt><strong>polymul_</strong>
</dt><dd><a href="#13954">poly_</a>
</dd><dt><strong>polynorm_</strong>
</dt><dd><a href="#13956">poly_</a>
</dd><dt><strong>polyrem_</strong>
</dt><dd><a href="#13958">poly_</a>
 | <a href="#13997">rem_</a>
</dd><dt><strong>polysub_</strong>
</dt><dd><a href="#13960">poly_</a>
</dd><dt><strong>prime_</strong>
</dt><dd><a href="#13967">prime_</a>
</dd><dt><strong>random_</strong>
</dt><dd><a href="#1262">#setrandom</a>
 | <a href="#13977">random_</a>
 | <a href="#13989">ranperm_</a>
</dd><dt><strong>ranperm_</strong>
</dt><dd><a href="#13983">ranperm_</a>
</dd><dt><strong>regular</strong>
</dt><dd><a href="#13648">Functions</a>
</dd><dt><strong>rem_</strong>
</dt><dd><a href="#13994">rem_</a>
 | <a href="#14886">Polynomials and Factorization</a>
</dd><dt><strong>replace_</strong>
</dt><dd><a href="#6655">tryreplace</a>
 | <a href="#14000">replace_</a>
</dd><dt><strong>reverse_</strong>
</dt><dd><a href="#14009">reverse_</a>
</dd><dt><strong>root_</strong>
</dt><dd><a href="#14013">root_</a>
</dd><dt><strong>setfun_</strong>
</dt><dd><a href="#14017">setfun_</a>
</dd><dt><strong>sig_</strong>
</dt><dd><a href="#14021">sig_</a>
</dd><dt><strong>sign_</strong>
</dt><dd><a href="#14025">sign_</a>
</dd><dt><strong>sin_</strong>
</dt><dd><a href="#14096">Extra reserved names</a>
</dd><dt><strong>sinh_</strong>
</dt><dd><a href="#14138">Extra reserved names</a>
</dd><dt><strong>sqrt_</strong>
</dt><dd><a href="#14084">Extra reserved names</a>
</dd><dt><strong>sum_</strong>
</dt><dd><a href="#14029">sum_</a>
</dd><dt><strong>sump_</strong>
</dt><dd><a href="#14036">sump_</a>
</dd><dt><strong>table_</strong>
</dt><dd><a href="#14043">table_</a>
</dd><dt><strong>tan_</strong>
</dt><dd><a href="#14108">Extra reserved names</a>
</dd><dt><strong>tanh_</strong>
</dt><dd><a href="#14150">Extra reserved names</a>
</dd><dt><strong>tbl_</strong>
</dt><dd><a href="#14050">tbl_</a>
</dd><dt><strong>term_</strong>
</dt><dd><a href="#14056">term_</a>
</dd><dt><strong>termsin_</strong>
</dt><dd><a href="#14062">termsin_</a>
</dd><dt><strong>termsinbracket_</strong>
</dt><dd><a href="#14068">termsinbracket_</a>
</dd><dt><strong>theta_</strong>
</dt><dd><a href="#14074">theta_</a>
</dd><dt><strong>thetap_</strong>
</dt><dd><a href="#14078">thetap_</a>
</dd></dl>
</dd><dt><strong>function  arguments</strong>
</dt><dd><a href="#3712">factarg</a>
</dd><dt><strong>functionlevels</strong>
</dt><dd><a href="#16533">The setup</a>
</dd><dt><strong>functions</strong>
</dt><dd><a href="#292">Functions</a>
 | <a href="#3999">functions</a>
<dl compact="">
<dt><strong>commuting</strong>
</dt><dd><a href="#7204">auto, autodeclare</a>
 | <a href="#3079">cfunctions</a>
</dd><dt><strong>noncommuting</strong>
</dt><dd><a href="#7176">auto, autodeclare</a>
 | <a href="#8087">identify</a>
</dd></dl>
</dd><dt><strong>funpowers</strong>
</dt><dd><a href="#4056">funpowers</a>
</dd><dt><strong>g5_</strong>
</dt><dd><a href="#13821">g5_</a>
 | <a href="#15671">Dirac algebra</a>
</dd><dt><strong>g6_</strong>
</dt><dd><a href="#13828">g6_</a>
</dd><dt><strong>g7_</strong>
</dt><dd><a href="#13833">g7_</a>
</dd><dt><strong>g_</strong>
</dt><dd><a href="#13838">g_</a>
 | <a href="#15666">Dirac algebra</a>
</dd><dt><strong>Gailly</strong>
</dt><dd><dl compact="">
<dt><strong>Jean-loup</strong>
</dt><dd><a href="#15229">The TableBase</a>
</dd></dl>
</dd><dt><strong>gamma algebra</strong>
</dt><dd><a href="#3162">chisholm</a>
</dd><dt><strong>gamma matrices</strong>
</dt><dd><a href="#285">Indices</a>
 | <a href="#3154">chisholm</a>
 | <a href="#6522">trace4</a>
 | <a href="#6559">tracen</a>
 | <a href="#13825">g5_</a>
 | <a href="#13842">g_</a>
 | <a href="#15664">Dirac algebra</a>
</dd><dt><strong>garbage collection</strong>
</dt><dd><a href="#15980">Sorting and statistics</a>
</dd><dt><strong>GCD</strong>
</dt><dd><a href="#13806">factorin_</a>
</dd><dt><strong>gcd_</strong>
</dt><dd><a href="#13844">gcd_</a>
 | <a href="#14879">Polynomials and Factorization</a>
</dd><dt><strong>gi_</strong>
</dt><dd><a href="#13850">gi_</a>
 | <a href="#15687">Dirac algebra</a>
</dd><dt><strong>global</strong>
</dt><dd><a href="#4089">global</a>
 | <a href="#4588">local</a>
</dd><dt><strong>GNU</strong>
</dt><dd><a href="#17546">An example</a>
</dd><dt><strong>goto</strong>
</dt><dd><a href="#4113">goto</a>
 | <a href="#4533">label</a>
</dd><dt><strong>Grace</strong>
</dt><dd><a href="#1168">#procedureextension</a>
</dd><dt><strong>greater than</strong>
</dt><dd><a href="#765">The triple dot operator</a>
</dd><dt><strong>greedy optimizations</strong>
</dt><dd><a href="#15037">Optimization options of the</a>
</dd><dt><strong>group theory</strong>
</dt><dd><a href="#5914">replaceloop</a>
</dd><dt><strong>guarantee</strong>
</dt><dd><a href="#4772">multiply</a>
</dd><dt><strong>gzip</strong>
</dt><dd><a href="#9210">on</a>
 | <a href="#15311">on</a>
</dd><dt><strong>harmonic  polylogarithms</strong>
</dt><dd><a href="#2935">argimplode</a>
</dd><dt><strong>harmonic  sums</strong>
</dt><dd><a href="#2933">argimplode</a>
 | <a href="#6634">transform</a>
</dd><dt><strong>harmonic polylogarithm</strong>
</dt><dd><a href="#6011">shuffle</a>
 | <a href="#6635">transform</a>
</dd><dt><strong>harmonic sum</strong>
</dt><dd><a href="#6010">shuffle</a>
 | <a href="#6151">stuffle</a>
</dd><dt><strong>hide</strong>
</dt><dd><a href="#4130">hide</a>
 | <a href="#4499">intohide</a>
 | <a href="#4837">nhide</a>
 | <a href="#4993">nunhide</a>
 | <a href="#5670">pushhide</a>
 | <a href="#6687">unhide</a>
 | <a href="#16815">The setup</a>
 | <a href="#16953">The setup</a>
 | <a href="#17291">TFORM</a>
</dd><dt><strong>hide file</strong>
</dt><dd><a href="#4133">hide</a>
</dd><dt><strong>hide files</strong>
</dt><dd><a href="#2508">Checkpoints</a>
</dd><dt><strong>hidesize</strong>
</dt><dd><a href="#16547">The setup</a>
</dd><dt><strong>hierarchy</strong>
</dt><dd><a href="#4347">if</a>
</dd><dt><strong>high energy physics</strong>
</dt><dd><a href="#15663">Dirac algebra</a>
</dd><dt><strong>highfirst</strong>
</dt><dd><a href="#16855">The setup</a>
</dd><dt><strong>Horner scheme</strong>
</dt><dd><a href="#15015">Optimization options of the</a>
 | <a href="#15049">Optimization options of the</a>
</dd><dt><strong>i_</strong>
</dt><dd><a href="#232">Symbols</a>
 | <a href="#252">Vectors</a>
 | <a href="#15695">Dirac algebra</a>
</dd><dt><strong>id</strong>
</dt><dd><a href="#2591">Pattern matching</a>
 | <a href="#2864">also</a>
 | <a href="#3463">disorder</a>
 | <a href="#4094">global</a>
 | <a href="#4168">identify</a>
 | <a href="#4213">idnew</a>
 | <a href="#4235">idold</a>
 | <a href="#4631">many</a>
 | <a href="#4749">multi</a>
 | <a href="#5343">once</a>
 | <a href="#5362">only</a>
 | <a href="#5954">select</a>
 | <a href="#6034">skip</a>
 | <a href="#6178">sum</a>
 | <a href="#14003">replace_</a>
</dd><dt><strong>id statement</strong>
</dt><dd><a href="#3462">disorder</a>
</dd><dt><strong>id_</strong>
</dt><dd><a href="#13854">id_</a>
</dd><dt><strong>identify</strong>
</dt><dd><a href="#4169">identify</a>
 | <a href="#4214">idnew</a>
 | <a href="#4236">idold</a>
</dd><dt><strong>idnew</strong>
</dt><dd><a href="#4212">idnew</a>
</dd><dt><strong>idold</strong>
</dt><dd><a href="#4232">idold</a>
</dd><dt><strong>if</strong>
</dt><dd><a href="#3535">else</a>
 | <a href="#3551">elseif</a>
 | <a href="#3592">endif</a>
 | <a href="#4254">if</a>
 | <a href="#5916">replaceloop</a>
 | <a href="#10086">symbols</a>
 | <a href="#6738">while</a>
<dl compact="">
<dt><strong>count</strong>
</dt><dd><a href="#10084">symbols</a>
</dd></dl>
</dd><dt><strong>if statement</strong>
</dt><dd><a href="#3534">else</a>
 | <a href="#3550">elseif</a>
 | <a href="#3591">endif</a>
</dd><dt><strong>ifmatch</strong>
</dt><dd><a href="#8051">identify</a>
 | <a href="#8065">identify</a>
 | <a href="#4374">ifmatch</a>
 | <a href="#4535">label</a>
</dd><dt><strong>ifnomatch</strong>
</dt><dd><a href="#4394">ifnomatch</a>
</dd><dt><strong>imaginary</strong>
</dt><dd><a href="#224">Symbols</a>
 | <a href="#300">Functions</a>
 | <a href="#7312">cfunctions</a>
 | <a href="#7896">functions</a>
 | <a href="#10041">symbols</a>
 | <a href="#15857">A few notes on</a>
 | <a href="#15860">A few notes on</a>
</dd><dt><strong>implode</strong>
</dt><dd><a href="#10482">transform</a>
</dd><dt><strong>improvement factor</strong>
</dt><dd><a href="#17245">The parallel version</a>
</dd><dt><strong>inactive</strong>
</dt><dd><a href="#4656">metric</a>
</dd><dt><strong>incdir</strong>
</dt><dd><a href="#16561">The setup</a>
 | <a href="#16747">The setup</a>
</dd><dt><strong>index</strong>
</dt><dd><a href="#243">Vectors</a>
 | <a href="#261">Indices</a>
 | <a href="#7147">auto, autodeclare</a>
 | <a href="#3845">fixindex</a>
 | <a href="#4413">index, indices</a>
<dl compact="">
<dt><strong>bracket</strong>
</dt><dd><a href="#14774">Brackets</a>
</dd><dt><strong>contracted</strong>
</dt><dd><a href="#5861">replaceloop</a>
</dd><dt><strong>dummy</strong>
</dt><dd><a href="#6171">sum</a>
 | <a href="#14212">Functions</a>
</dd><dt><strong>main</strong>
</dt><dd><a href="#15233">The TableBase</a>
</dd><dt><strong>table</strong>
</dt><dd><a href="#13652">Functions</a>
</dd><dt><strong>trace line</strong>
</dt><dd><a href="#6524">trace4</a>
</dd></dl>
</dd><dt><strong>index loop</strong>
</dt><dd><a href="#8181">if</a>
 | <a href="#5858">replaceloop</a>
</dd><dt><strong>index tree</strong>
</dt><dd><a href="#14783">Brackets</a>
</dd><dt><strong>index_</strong>
</dt><dd><a href="#339">Sets</a>
</dd><dt><strong>indices</strong>
</dt><dd><a href="#260">Indices</a>
 | <a href="#7161">auto, autodeclare</a>
 | <a href="#3409">dimension</a>
 | <a href="#4414">index, indices</a>
<dl compact="">
<dt><strong>dummy</strong>
</dt><dd><a href="#399">Dummy indices</a>
 | <a href="#3410">dimension</a>
 | <a href="#5803">renumber</a>
</dd><dt><strong>fixed</strong>
</dt><dd><a href="#271">Indices</a>
</dd><dt><strong>lower</strong>
</dt><dd><a href="#3275">contract</a>
 | <a href="#15833">A few notes on</a>
</dd><dt><strong>numeric</strong>
</dt><dd><a href="#272">Indices</a>
</dd><dt><strong>renumber</strong>
</dt><dd><a href="#409">Dummy indices</a>
</dd><dt><strong>summable</strong>
</dt><dd><a href="#281">Indices</a>
 | <a href="#15839">A few notes on</a>
</dd><dt><strong>upper</strong>
</dt><dd><a href="#3276">contract</a>
 | <a href="#15832">A few notes on</a>
</dd></dl>
</dd><dt><strong>individual expressions</strong>
</dt><dd><a href="#5500">print</a>
</dd><dt><strong>inexpression</strong>
</dt><dd><a href="#3607">endinexpression</a>
 | <a href="#4435">inexpression</a>
</dd><dt><strong>infinite loop</strong>
</dt><dd><a href="#5835">repeat</a>
 | <a href="#6744">while</a>
</dd><dt><strong>input</strong>
</dt><dd><a href="#17290">TFORM</a>
<dl compact="">
<dt><strong>standard</strong>
</dt><dd><a href="#1018">#external</a>
</dd></dl>
</dd><dt><strong>inside</strong>
</dt><dd><a href="#3621">endinside</a>
 | <a href="#4467">inside</a>
</dd><dt><strong>insidefirst</strong>
</dt><dd><a href="#4485">insidefirst</a>
 | <a href="#16580">The setup</a>
</dd><dt><strong>installation</strong>
</dt><dd><a href="#16057">The setup</a>
</dd><dt><strong>instance</strong>
</dt><dd><a href="#914">#define</a>
</dd><dt><strong>int_</strong>
</dt><dd><a href="#327">Sets</a>
</dd><dt><strong>integer_</strong>
</dt><dd><a href="#13869">integer_</a>
</dd><dt><strong>inverse_</strong>
</dt><dd><a href="#13874">inverse_</a>
</dd><dt><strong>invfac_</strong>
</dt><dd><a href="#13878">invfac_</a>
</dd><dt><strong>isdefined</strong>
</dt><dd><a href="#1440">#if</a>
</dd><dt><strong>isfactorized</strong>
</dt><dd><a href="#1455">#if</a>
</dd><dt><strong>islyndon</strong>
</dt><dd><a href="#10554">transform</a>
</dd><dt><strong>isnumerical</strong>
</dt><dd><a href="#1468">#if</a>
</dd><dt><strong>Karlsruhe</strong>
</dt><dd><a href="#17234">The parallel version</a>
</dd><dt><strong>keep</strong>
</dt><dd><a href="#4515">keep</a>
</dd><dt><strong>keep brackets</strong>
</dt><dd><a href="#4514">keep</a>
 | <a href="#14786">Brackets</a>
</dd><dt><strong>kill</strong>
</dt><dd><a href="#1238">#setexternalattr</a>
 | <a href="#17524">#setexternalattr</a>
</dd><dt><strong>KILL signal</strong>
</dt><dd><a href="#1217">#rmexternal</a>
 | <a href="#1254">#setexternalattr</a>
 | <a href="#17516">#rmexternal</a>
 | <a href="#17528">#setexternalattr</a>
 | <a href="#17541">#setexternalattr</a>
</dd><dt><strong>killall</strong>
</dt><dd><a href="#1240">#setexternalattr</a>
 | <a href="#17527">#setexternalattr</a>
</dd><dt><strong>Knuth</strong>
</dt><dd><a href="#15987">Sorting and statistics</a>
</dd><dt><strong>Kronecker</strong>
</dt><dd><a href="#269">Indices</a>
 | <a href="#434">Kronecker delta's</a>
 | <a href="#3266">contract</a>
 | <a href="#13716">d_</a>
 | <a href="#15836">A few notes on</a>
 | <a href="#15866">A few notes on</a>
</dd><dt><strong>label</strong>
</dt><dd><a href="#4114">goto</a>
 | <a href="#8058">identify</a>
 | <a href="#8072">identify</a>
 | <a href="#4532">label</a>
</dd><dt><strong>large buffer</strong>
</dt><dd><a href="#15983">Sorting and statistics</a>
 | <a href="#16283">The setup</a>
</dd><dt><strong>largepatches</strong>
</dt><dd><a href="#16286">The setup</a>
 | <a href="#17009">The setup</a>
</dd><dt><strong>largesize</strong>
</dt><dd><a href="#16285">The setup</a>
 | <a href="#17065">The setup</a>
</dd><dt><strong>last</strong>
</dt><dd><a href="#6574">transform</a>
</dd><dt><strong>LCM</strong>
</dt><dd><a href="#13807">factorin_</a>
</dd><dt><strong>legal</strong>
</dt><dd><a href="#461">Some common bugs</a>
</dd><dt><strong>less than</strong>
</dt><dd><a href="#764">The triple dot operator</a>
</dd><dt><strong>Levi-Civita</strong>
</dt><dd><a href="#3263">contract</a>
 | <a href="#15843">A few notes on</a>
</dd><dt><strong>Levi-Civita tensor</strong>
</dt><dd><a href="#13771">e_</a>
</dd><dt><strong>li2_</strong>
</dt><dd><a href="#14173">Extra reserved names</a>
</dd><dt><strong>library</strong>
</dt><dd><a href="#1161">#procedure</a>
<dl compact="">
<dt><strong>making a</strong>
</dt><dd><a href="#1160">#procedure</a>
</dd></dl>
</dd><dt><strong>lin_</strong>
</dt><dd><a href="#14179">Extra reserved names</a>
</dd><dt><strong>linebreaks</strong>
</dt><dd><a href="#9638">print</a>
</dd><dt><strong>linefeed</strong>
</dt><dd><a href="#837">#call</a>
 | <a href="#1347">#write</a>
 | <a href="#9769">print</a>
 | <a href="#5536">print</a>
</dd><dt><strong>LINUX</strong>
</dt><dd><a href="#17269">TFORM</a>
 | <a href="#17567">Embedding FORM in other</a>
</dd><dt><strong>listed loop</strong>
</dt><dd><a href="#932">#do</a>
 | <a href="#934">#do</a>
</dd><dt><strong>lists</strong>
</dt><dd><a href="#391">Name lists</a>
</dd><dt><strong>ln_</strong>
</dt><dd><a href="#14089">Extra reserved names</a>
</dd><dt><strong>load</strong>
</dt><dd><a href="#4566">load</a>
 | <a href="#5934">save</a>
 | <a href="#15234">The TableBase</a>
 | <a href="#15289">enter</a>
 | <a href="#15294">load</a>
</dd><dt><strong>load balancing</strong>
</dt><dd><a href="#17263">TFORM</a>
 | <a href="#17365">Some problems</a>
</dd><dt><strong>loading dynamically</strong>
</dt><dd><a href="#3826">fillexpression</a>
</dd><dt><strong>local</strong>
</dt><dd><a href="#4102">global</a>
 | <a href="#4550">lfactorized</a>
 | <a href="#4585">local</a>
</dd><dt><strong>lock</strong>
</dt><dd><a href="#17345">Some problems</a>
</dd><dt><strong>log</strong>
</dt><dd><a href="#127">Running FORM</a>
 | <a href="#9571">print</a>
 | <a href="#9586">print</a>
 | <a href="#5595">printtable</a>
</dd><dt><strong>logical</strong>
</dt><dd><a href="#1045">#if</a>
</dd><dt><strong>loop</strong>
</dt><dd><a href="#5783">redefine</a>
<dl compact="">
<dt><strong>index</strong>
</dt><dd><a href="#5859">replaceloop</a>
</dd><dt><strong>infinite</strong>
</dt><dd><a href="#5836">repeat</a>
</dd><dt><strong>listed</strong>
</dt><dd><a href="#933">#do</a>
 | <a href="#935">#do</a>
</dd><dt><strong>numerical</strong>
</dt><dd><a href="#938">#do</a>
</dd><dt><strong>while</strong>
</dt><dd><a href="#5784">redefine</a>
</dd></dl>
</dd><dt><strong>loops</strong>
</dt><dd><dl compact="">
<dt><strong>infinite</strong>
</dt><dd><a href="#6745">while</a>
</dd></dl>
</dd><dt><strong>loopsize</strong>
</dt><dd><a href="#9929">replaceloop</a>
 | <a href="#5893">replaceloop</a>
</dd><dt><strong>lower</strong>
</dt><dd><a href="#3274">contract</a>
</dd><dt><strong>lowfirst</strong>
</dt><dd><a href="#16854">The setup</a>
</dd><dt><strong>Lyndon word</strong>
</dt><dd><a href="#10561">transform</a>
 | <a href="#10576">transform</a>
</dd><dt><strong>macro</strong>
</dt><dd><a href="#922">#define</a>
</dd><dt><strong>makeinteger</strong>
</dt><dd><a href="#4604">makeinteger</a>
 | <a href="#14800">Brackets</a>
</dd><dt><strong>makerational_</strong>
</dt><dd><a href="#13883">makerational_</a>
</dd><dt><strong>many</strong>
</dt><dd><a href="#7993">identify</a>
 | <a href="#8135">if</a>
 | <a href="#4630">many</a>
</dd><dt><strong>maple</strong>
</dt><dd><a href="#7798">format</a>
</dd><dt><strong>master</strong>
</dt><dd><a href="#6410">threadbucketsize</a>
 | <a href="#15884">A few notes on</a>
 | <a href="#17238">The parallel version</a>
 | <a href="#17254">TFORM</a>
</dd><dt><strong>match</strong>
</dt><dd><a href="#8125">if</a>
</dd><dt><strong>match_</strong>
</dt><dd><a href="#13889">match_</a>
</dd><dt><strong>mathematica</strong>
</dt><dd><a href="#7812">format</a>
</dd><dt><strong>matrices</strong>
</dt><dd><dl compact="">
<dt><strong>gamma</strong>
</dt><dd><a href="#286">Indices</a>
 | <a href="#15842">A few notes on</a>
</dd></dl>
</dd><dt><strong>matrix</strong>
</dt><dd><dl compact="">
<dt><strong>unit</strong>
</dt><dd><a href="#6708">unittrace</a>
</dd></dl>
</dd><dt><strong>matrix like</strong>
</dt><dd><a href="#6306">table</a>
</dd><dt><strong>max_</strong>
</dt><dd><a href="#13893">max_</a>
</dd><dt><strong>maxnumbersize</strong>
</dt><dd><a href="#16594">The setup</a>
</dd><dt><strong>maxpowerof</strong>
</dt><dd><a href="#1481">#if</a>
</dd><dt><strong>maxpowerof_</strong>
</dt><dd><a href="#13897">maxpowerof_</a>
</dd><dt><strong>maxtermsize</strong>
</dt><dd><a href="#3204">collect</a>
 | <a href="#16611">The setup</a>
 | <a href="#16817">The setup</a>
 | <a href="#16839">The setup</a>
</dd><dt><strong>maxwildcards</strong>
</dt><dd><a href="#16630">The setup</a>
</dd><dt><strong>MCTS</strong>
</dt><dd><a href="#15018">Optimization options of the</a>
 | <a href="#15022">Optimization options of the</a>
</dd><dt><strong>memory</strong>
</dt><dd><a href="#2427">Modules</a>
<dl compact="">
<dt><strong>total amount of</strong>
</dt><dd><a href="#453">Restrictions</a>
</dd></dl>
</dd><dt><strong>merge</strong>
</dt><dd><a href="#5998">shuffle</a>
</dd><dt><strong>metric</strong>
</dt><dd><a href="#3853">fixindex</a>
 | <a href="#4655">metric</a>
 | <a href="#15828">A few notes on</a>
 | <a href="#15862">A few notes on</a>
</dd><dt><strong>min_</strong>
</dt><dd><a href="#13903">min_</a>
</dd><dt><strong>mincer</strong>
</dt><dd><a href="#4521">keep</a>
</dd><dt><strong>minpowerof</strong>
</dt><dd><a href="#1495">#if</a>
</dd><dt><strong>minpowerof_</strong>
</dt><dd><a href="#13907">minpowerof_</a>
</dd><dt><strong>mixed statements</strong>
</dt><dd><a href="#2437">Modules</a>
</dd><dt><strong>mod2_</strong>
</dt><dd><a href="#13919">mod2_</a>
</dd><dt><strong>mod_</strong>
</dt><dd><a href="#13911">mod_</a>
</dd><dt><strong>mode</strong>
</dt><dd><dl compact="">
<dt><strong>single term</strong>
</dt><dd><a href="#9601">print</a>
</dd></dl>
</dd><dt><strong>module</strong>
</dt><dd><a href="#661">The preprocessor</a>
 | <a href="#2421">Modules</a>
 | <a href="#2490">Checkpoints</a>
</dd><dt><strong>module instruction</strong>
</dt><dd><a href="#2425">Modules</a>
</dd><dt><strong>module number</strong>
</dt><dd><a href="#2501">Checkpoints</a>
</dd><dt><strong>moduleoption</strong>
</dt><dd><a href="#2460">Modules</a>
 | <a href="#2775">Dollar variables in a</a>
 | <a href="#4453">inparallel</a>
 | <a href="#4671">moduleoption</a>
<dl compact="">
<dt><strong>inparallel</strong>
</dt><dd><a href="#8421">moduleoption</a>
</dd><dt><strong>local</strong>
</dt><dd><a href="#8494">moduleoption</a>
 | <a href="#17355">Some problems</a>
</dd><dt><strong>maximum</strong>
</dt><dd><a href="#8510">moduleoption</a>
 | <a href="#17352">Some problems</a>
</dd><dt><strong>minimum</strong>
</dt><dd><a href="#8524">moduleoption</a>
 | <a href="#17353">Some problems</a>
</dd><dt><strong>noparallel</strong>
</dt><dd><a href="#8407">moduleoption</a>
</dd><dt><strong>notinparallel</strong>
</dt><dd><a href="#8435">moduleoption</a>
</dd><dt><strong>parallel</strong>
</dt><dd><a href="#8393">moduleoption</a>
</dd><dt><strong>polyfun</strong>
</dt><dd><a href="#8449">moduleoption</a>
 | <a href="#8464">moduleoption</a>
</dd><dt><strong>processbucketsize</strong>
</dt><dd><a href="#8479">moduleoption</a>
 | <a href="#17306">ParFORM</a>
</dd><dt><strong>sum</strong>
</dt><dd><a href="#8538">moduleoption</a>
 | <a href="#17354">Some problems</a>
</dd></dl>
</dd><dt><strong>modulus</strong>
</dt><dd><a href="#4733">modulus</a>
</dd><dt><strong>Monte Carlo tree search</strong>
</dt><dd><a href="#15019">Optimization options of the</a>
 | <a href="#15023">Optimization options of the</a>
</dd><dt><strong>mountains</strong>
</dt><dd><a href="#15881">A few notes on</a>
</dd><dt><strong>MPI</strong>
</dt><dd><a href="#17232">The parallel version</a>
 | <a href="#17241">The parallel version</a>
 | <a href="#17295">ParFORM</a>
</dd><dt><strong>mpirun</strong>
</dt><dd><a href="#17296">ParFORM</a>
</dd><dt><strong>MS-DOS</strong>
</dt><dd><a href="#1196">#remove</a>
</dd><dt><strong>multi</strong>
</dt><dd><a href="#7979">identify</a>
 | <a href="#8134">if</a>
 | <a href="#4748">multi</a>
 | <a href="#4775">multiply</a>
</dd><dt><strong>Multiple  Zeta Value</strong>
</dt><dd><a href="#6632">transform</a>
</dd><dt><strong>multiple zeta value</strong>
</dt><dd><a href="#6012">shuffle</a>
</dd><dt><strong>multiple zeta values</strong>
</dt><dd><a href="#2936">argimplode</a>
</dd><dt><strong>multipleof</strong>
</dt><dd><a href="#8189">if</a>
</dd><dt><strong>multiplication</strong>
</dt><dd><a href="#726">The preprocessor calculator</a>
</dd><dt><strong>multiply</strong>
</dt><dd><a href="#4766">multiply</a>
 | <a href="#6036">skip</a>
<dl compact="">
<dt><strong>left</strong>
</dt><dd><a href="#8557">multiply</a>
</dd><dt><strong>right</strong>
</dt><dd><a href="#8570">multiply</a>
</dd></dl>
</dd><dt><strong>MZV</strong>
</dt><dd><a href="#6013">shuffle</a>
 | <a href="#6633">transform</a>
</dd><dt><strong>MZV data mine</strong>
</dt><dd><a href="#6636">transform</a>
</dd><dt><strong>NAME_</strong>
</dt><dd><a href="#682">The preprocessor variables</a>
 | <a href="#1270">#show</a>
</dd><dt><strong>names</strong>
</dt><dd><a href="#189">Names</a>
<dl compact="">
<dt><strong>definition</strong>
</dt><dd><a href="#190">Names</a>
</dd><dt><strong>length</strong>
</dt><dd><a href="#213">Names</a>
</dd></dl>
</dd><dt><strong>nargs_</strong>
</dt><dd><a href="#13924">nargs_</a>
</dd><dt><strong>ndrop</strong>
</dt><dd><a href="#4787">ndrop</a>
</dd><dt><strong>neg0_</strong>
</dt><dd><a href="#335">Sets</a>
</dd><dt><strong>neg_</strong>
</dt><dd><a href="#333">Sets</a>
</dd><dt><strong>nested</strong>
</dt><dd><a href="#1304">#switch</a>
 | <a href="#5846">repeat</a>
 | <a href="#6385">term</a>
</dd><dt><strong>nesting</strong>
</dt><dd><a href="#677">The preprocessor variables</a>
</dd><dt><strong>newline</strong>
</dt><dd><a href="#1342">#write</a>
 | <a href="#17496">#toexternal</a>
</dd><dt><strong>nfunction</strong>
</dt><dd><a href="#4818">nfunctions</a>
</dd><dt><strong>nhide</strong>
</dt><dd><a href="#4148">hide</a>
 | <a href="#4836">nhide</a>
</dd><dt><strong>non-commuting</strong>
</dt><dd><a href="#297">Functions</a>
</dd><dt><strong>noncommuting</strong>
</dt><dd><a href="#2596">Pattern matching</a>
 | <a href="#7175">auto, autodeclare</a>
 | <a href="#4000">functions</a>
 | <a href="#8086">identify</a>
 | <a href="#4819">nfunctions</a>
 | <a href="#4935">ntable</a>
 | <a href="#4952">ntensors</a>
 | <a href="#6302">table</a>
 | <a href="#6364">tensors</a>
 | <a href="#13647">Functions</a>
</dd><dt><strong>nondeterministic</strong>
</dt><dd><a href="#2770">Dollar variables in a</a>
</dd><dt><strong>normal</strong>
</dt><dd><a href="#7840">format</a>
</dd><dt><strong>normalization</strong>
</dt><dd><a href="#10070">symbols</a>
</dd><dt><strong>normalize</strong>
</dt><dd><a href="#4607">makeinteger</a>
 | <a href="#4856">normalize</a>
 | <a href="#14798">Brackets</a>
</dd><dt><strong>nospaces</strong>
</dt><dd><a href="#7610">format</a>
</dd><dt><strong>nospacesinnumbers</strong>
</dt><dd><a href="#16644">The setup</a>
</dd><dt><strong>nosymmetrize</strong>
</dt><dd><a href="#15704">Dirac algebra</a>
</dd><dt><strong>notation</strong>
</dt><dd><dl compact="">
<dt><strong>ambiguous</strong>
</dt><dd><a href="#283">Indices</a>
</dd></dl>
</dd><dt><strong>nprint</strong>
</dt><dd><a href="#4902">nprint</a>
</dd><dt><strong>nskip</strong>
</dt><dd><a href="#4915">nskip</a>
 | <a href="#6031">skip</a>
</dd><dt><strong>ntable</strong>
</dt><dd><a href="#4934">ntable</a>
 | <a href="#6303">table</a>
</dd><dt><strong>ntensor</strong>
</dt><dd><a href="#4951">ntensors</a>
 | <a href="#6365">tensors</a>
</dd><dt><strong>nterms_</strong>
</dt><dd><a href="#13928">nterms_</a>
</dd><dt><strong>num_</strong>
</dt><dd><a href="#236">Symbols</a>
</dd><dt><strong>number of terms</strong>
</dt><dd><a href="#14064">termsin_</a>
</dd><dt><strong>number_</strong>
</dt><dd><a href="#340">Sets</a>
</dd><dt><strong>numerical loop</strong>
</dt><dd><a href="#937">#do</a>
</dd><dt><strong>numerical output</strong>
</dt><dd><a href="#15548">Dictionaries</a>
</dd><dt><strong>numerical processing</strong>
</dt><dd><a href="#14990">Output optimization</a>
</dd><dt><strong>numfactors_</strong>
</dt><dd><a href="#13932">numfactors_</a>
</dd><dt><strong>numstorecaches</strong>
</dt><dd><a href="#16664">The setup</a>
 | <a href="#16838">The setup</a>
</dd><dt><strong>nunhide</strong>
</dt><dd><a href="#4987">nunhide</a>
</dd><dt><strong>nwrite</strong>
</dt><dd><a href="#5005">nwrite</a>
<dl compact="">
<dt><strong>allnames</strong>
</dt><dd><a href="#8731">nwrite</a>
</dd><dt><strong>allwarnings</strong>
</dt><dd><a href="#8692">nwrite</a>
</dd><dt><strong>highfirst</strong>
</dt><dd><a href="#8757">nwrite</a>
</dd><dt><strong>lowfirst</strong>
</dt><dd><a href="#8770">nwrite</a>
</dd><dt><strong>names</strong>
</dt><dd><a href="#8718">nwrite</a>
</dd><dt><strong>powerfirst</strong>
</dt><dd><a href="#8783">nwrite</a>
</dd><dt><strong>setup</strong>
</dt><dd><a href="#8705">nwrite</a>
</dd><dt><strong>shortstatistics</strong>
</dt><dd><a href="#8666">nwrite</a>
</dd><dt><strong>shortstats</strong>
</dt><dd><a href="#8653">nwrite</a>
 | <a href="#8744">nwrite</a>
</dd><dt><strong>statistics</strong>
</dt><dd><a href="#8640">nwrite</a>
</dd><dt><strong>stats</strong>
</dt><dd><a href="#8627">nwrite</a>
</dd><dt><strong>warnings</strong>
</dt><dd><a href="#8679">nwrite</a>
</dd></dl>
</dd><dt><strong>nwritestatistics</strong>
</dt><dd><a href="#16678">The setup</a>
</dd><dt><strong>nwritethreadstatistics</strong>
</dt><dd><a href="#16692">The setup</a>
</dd><dt><strong>obsolete</strong>
</dt><dd><a href="#2459">Modules</a>
 | <a href="#4057">funpowers</a>
 | <a href="#4486">insidefirst</a>
 | <a href="#5006">nwrite</a>
 | <a href="#5653">propercount</a>
 | <a href="#6762">write</a>
</dd><dt><strong>occurrence order</strong>
</dt><dd><a href="#15017">Optimization options of the</a>
</dd><dt><strong>odd_</strong>
</dt><dd><a href="#343">Sets</a>
</dd><dt><strong>off</strong>
</dt><dd><a href="#2485">Checkpoints</a>
 | <a href="#4060">funpowers</a>
 | <a href="#5007">nwrite</a>
 | <a href="#5081">off</a>
 | <a href="#5656">propercount</a>
 | <a href="#6765">write</a>
 | <a href="#15302">off</a>
<dl compact="">
<dt><strong>allnames</strong>
</dt><dd><a href="#8796">off</a>
</dd><dt><strong>allwarnings</strong>
</dt><dd><a href="#8809">off</a>
</dd><dt><strong>checkpoint</strong>
</dt><dd><a href="#8822">off</a>
</dd><dt><strong>compress</strong>
</dt><dd><a href="#8836">off</a>
</dd><dt><strong>finalstats</strong>
</dt><dd><a href="#8849">off</a>
</dd><dt><strong>highfirst</strong>
</dt><dd><a href="#8862">off</a>
</dd><dt><strong>insidefirst</strong>
</dt><dd><a href="#8875">off</a>
</dd><dt><strong>lowfirst</strong>
</dt><dd><a href="#8888">off</a>
</dd><dt><strong>names</strong>
</dt><dd><a href="#8901">off</a>
</dd><dt><strong>nospacesinnumbers</strong>
</dt><dd><a href="#8914">off</a>
</dd><dt><strong>oldfactarg</strong>
</dt><dd><a href="#8932">off</a>
</dd><dt><strong>parallel</strong>
</dt><dd><a href="#8948">off</a>
 | <a href="#17311">ParFORM</a>
</dd><dt><strong>powerfirst</strong>
</dt><dd><a href="#8962">off</a>
</dd><dt><strong>processstats</strong>
</dt><dd><a href="#8975">off</a>
</dd><dt><strong>propercount</strong>
</dt><dd><a href="#8992">off</a>
</dd><dt><strong>properorder</strong>
</dt><dd><a href="#9005">off</a>
</dd><dt><strong>setup</strong>
</dt><dd><a href="#9018">off</a>
</dd><dt><strong>shortstatistics</strong>
</dt><dd><a href="#9070">off</a>
</dd><dt><strong>shortstats</strong>
</dt><dd><a href="#9057">off</a>
</dd><dt><strong>statistics</strong>
</dt><dd><a href="#9044">off</a>
</dd><dt><strong>stats</strong>
</dt><dd><a href="#9031">off</a>
</dd><dt><strong>threadloadbalancing</strong>
</dt><dd><a href="#9083">off</a>
</dd><dt><strong>threads</strong>
</dt><dd><a href="#9099">off</a>
 | <a href="#17273">TFORM</a>
</dd><dt><strong>threadstats</strong>
</dt><dd><a href="#9114">off</a>
</dd><dt><strong>totalsize</strong>
</dt><dd><a href="#9129">off</a>
</dd><dt><strong>warnings</strong>
</dt><dd><a href="#9143">off</a>
</dd></dl>
</dd><dt><strong>old notation</strong>
</dt><dd><a href="#678">The preprocessor variables</a>
</dd><dt><strong>OLDNUMEXTRASYMBOLS_</strong>
</dt><dd><a href="#688">The preprocessor variables</a>
</dd><dt><strong>oldorder</strong>
</dt><dd><a href="#16709">The setup</a>
</dd><dt><strong>on</strong>
</dt><dd><a href="#2483">Checkpoints</a>
 | <a href="#4058">funpowers</a>
 | <a href="#5009">nwrite</a>
 | <a href="#5654">propercount</a>
 | <a href="#6763">write</a>
 | <a href="#15309">on</a>
 | <a href="#16857">The setup</a>
<dl compact="">
<dt><strong>allnames</strong>
</dt><dd><a href="#9156">on</a>
</dd><dt><strong>allwarnings</strong>
</dt><dd><a href="#9169">on</a>
</dd><dt><strong>checkpoint</strong>
</dt><dd><a href="#9182">on</a>
</dd><dt><strong>compress</strong>
</dt><dd><a href="#9197">on</a>
</dd><dt><strong>fewerstatistics</strong>
</dt><dd><a href="#9223">on</a>
</dd><dt><strong>fewerstats</strong>
</dt><dd><a href="#9237">on</a>
</dd><dt><strong>finalstats</strong>
</dt><dd><a href="#9250">on</a>
</dd><dt><strong>highfirst</strong>
</dt><dd><a href="#9264">on</a>
</dd><dt><strong>insidefirst</strong>
</dt><dd><a href="#9277">on</a>
</dd><dt><strong>lowfirst</strong>
</dt><dd><a href="#9290">on</a>
</dd><dt><strong>names</strong>
</dt><dd><a href="#9303">on</a>
</dd><dt><strong>nospacesinnumbers</strong>
</dt><dd><a href="#9316">on</a>
</dd><dt><strong>oldfactarg</strong>
</dt><dd><a href="#9334">on</a>
</dd><dt><strong>parallel</strong>
</dt><dd><a href="#9350">on</a>
 | <a href="#17310">ParFORM</a>
</dd><dt><strong>powerfirst</strong>
</dt><dd><a href="#9364">on</a>
</dd><dt><strong>processstats</strong>
</dt><dd><a href="#9377">on</a>
 | <a href="#17320">ParFORM</a>
 | <a href="#17321">ParFORM</a>
</dd><dt><strong>propercount</strong>
</dt><dd><a href="#9392">on</a>
</dd><dt><strong>properorder</strong>
</dt><dd><a href="#9405">on</a>
</dd><dt><strong>setup</strong>
</dt><dd><a href="#9420">on</a>
</dd><dt><strong>shortstatistics</strong>
</dt><dd><a href="#9433">on</a>
</dd><dt><strong>shortstats</strong>
</dt><dd><a href="#9446">on</a>
</dd><dt><strong>statistics</strong>
</dt><dd><a href="#9459">on</a>
</dd><dt><strong>stats</strong>
</dt><dd><a href="#9473">on</a>
</dd><dt><strong>threadloadbalancing</strong>
</dt><dd><a href="#9486">on</a>
</dd><dt><strong>threads</strong>
</dt><dd><a href="#9502">on</a>
 | <a href="#17272">TFORM</a>
</dd><dt><strong>threadstats</strong>
</dt><dd><a href="#9517">on</a>
 | <a href="#17282">TFORM</a>
 | <a href="#17283">TFORM</a>
</dd><dt><strong>totalsize</strong>
</dt><dd><a href="#9531">on</a>
</dd><dt><strong>warnings</strong>
</dt><dd><a href="#9550">on</a>
</dd></dl>
</dd><dt><strong>once</strong>
</dt><dd><a href="#8021">identify</a>
 | <a href="#8132">if</a>
 | <a href="#5342">once</a>
</dd><dt><strong>only</strong>
</dt><dd><a href="#8038">identify</a>
 | <a href="#8133">if</a>
 | <a href="#5361">only</a>
</dd><dt><strong>open</strong>
</dt><dd><a href="#15227">The TableBase</a>
 | <a href="#15280">create</a>
 | <a href="#15316">open</a>
</dd><dt><strong>opteron</strong>
</dt><dd><a href="#17247">The parallel version</a>
</dd><dt><strong>optimization buffer</strong>
</dt><dd><a href="#15003">Output optimization</a>
 | <a href="#15008">Output optimization</a>
</dd><dt><strong>optimize</strong>
</dt><dd><a href="#7638">format</a>
 | <a href="#7654">format</a>
 | <a href="#7670">format</a>
 | <a href="#7686">format</a>
</dd><dt><strong>OPTIMMAXVAR_</strong>
</dt><dd><a href="#692">The preprocessor variables</a>
 | <a href="#14997">Output optimization</a>
 | <a href="#15005">Output optimization</a>
</dd><dt><strong>OPTIMMINVAR_</strong>
</dt><dd><a href="#690">The preprocessor variables</a>
 | <a href="#14996">Output optimization</a>
 | <a href="#15004">Output optimization</a>
</dd><dt><strong>option</strong>
</dt><dd><dl compact="">
<dt><strong>disorder</strong>
</dt><dd><a href="#3461">disorder</a>
</dd><dt><strong>select</strong>
</dt><dd><a href="#358">Sets</a>
</dd></dl>
</dd><dt><strong>or</strong>
</dt><dd><a href="#731">The preprocessor calculator</a>
</dd><dt><strong>order of terms</strong>
</dt><dd><a href="#17341">Some problems</a>
</dd><dt><strong>output</strong>
</dt><dd><dl compact="">
<dt><strong>standard</strong>
</dt><dd><a href="#1019">#external</a>
</dd></dl>
</dd><dt><strong>output channel</strong>
</dt><dd><a href="#1336">#write</a>
</dd><dt><strong>output specifications</strong>
</dt><dd><a href="#2435">Modules</a>
</dd><dt><strong>overflow</strong>
</dt><dd><a href="#3799">fill</a>
</dd><dt><strong>overwrite</strong>
</dt><dd><a href="#9834">printtable</a>
</dd><dt><strong>package</strong>
</dt><dd><dl compact="">
<dt><strong>color</strong>
</dt><dd><a href="#5912">replaceloop</a>
</dd></dl>
</dd><dt><strong>parallel</strong>
</dt><dd><a href="#8400">moduleoption</a>
 | <a href="#8414">moduleoption</a>
 | <a href="#5637">processbucketsize</a>
</dd><dt><strong>parallel execution</strong>
</dt><dd><a href="#4721">moduleoption</a>
</dd><dt><strong>parallel processing</strong>
</dt><dd><a href="#2767">Dollar variables in a</a>
</dd><dt><strong>parentheses</strong>
</dt><dd><a href="#14754">Brackets</a>
 | <a href="#16723">The setup</a>
</dd><dt><strong>ParFORM</strong>
</dt><dd><a href="#2768">Dollar variables in a</a>
 | <a href="#5636">processbucketsize</a>
 | <a href="#17231">The parallel version</a>
 | <a href="#17294">ParFORM</a>
</dd><dt><strong>partial fractioning</strong>
</dt><dd><a href="#5702">ratio</a>
</dd><dt><strong>patch</strong>
</dt><dd><a href="#15985">Sorting and statistics</a>
 | <a href="#16287">The setup</a>
</dd><dt><strong>path</strong>
</dt><dd><a href="#831">#call</a>
 | <a href="#1109">#include</a>
 | <a href="#1247">#setexternalattr</a>
 | <a href="#16571">The setup</a>
 | <a href="#16737">The setup</a>
 | <a href="#16275">The setup</a>
 | <a href="#17534">#setexternalattr</a>
<dl compact="">
<dt><strong>search</strong>
</dt><dd><a href="#17533">#setexternalattr</a>
</dd></dl>
</dd><dt><strong>pattern</strong>
</dt><dd><a href="#777">The triple dot operator</a>
 | <a href="#2587">Pattern matching</a>
 | <a href="#4170">identify</a>
</dd><dt><strong>pattern matcher</strong>
</dt><dd><a href="#8138">if</a>
</dd><dt><strong>pattern matching</strong>
</dt><dd><a href="#360">Sets</a>
 | <a href="#2586">Pattern matching</a>
</dd><dt><strong>pattern_</strong>
</dt><dd><a href="#13938">pattern_</a>
</dd><dt><strong>pentium</strong>
</dt><dd><a href="#17246">The parallel version</a>
</dd><dt><strong>percentage</strong>
</dt><dd><a href="#3211">collect</a>
</dd><dt><strong>period</strong>
</dt><dd><a href="#203">Names</a>
 | <a href="#2424">Modules</a>
</dd><dt><strong>permutation</strong>
</dt><dd><a href="#6281">symmetrize</a>
</dd><dt><strong>permutations</strong>
</dt><dd><a href="#5764">rcyclesymmetrize</a>
 | <a href="#9878">renumber</a>
</dd><dt><strong>permute</strong>
</dt><dd><a href="#10512">transform</a>
</dd><dt><strong>pi_</strong>
</dt><dd><a href="#234">Symbols</a>
</dd><dt><strong>PID</strong>
</dt><dd><a href="#694">The preprocessor variables</a>
 | <a href="#17571">Embedding FORM in other</a>
</dd><dt><strong>PID_</strong>
</dt><dd><a href="#695">The preprocessor variables</a>
</dd><dt><strong>pipe</strong>
</dt><dd><a href="#1139">#pipe</a>
 | <a href="#17566">Embedding FORM in other</a>
</dd><dt><strong>PIPE1_</strong>
</dt><dd><a href="#17553">Embedding FORM in other</a>
</dd><dt><strong>PIPE2_</strong>
</dt><dd><a href="#17554">Embedding FORM in other</a>
</dd><dt><strong>pipelined job</strong>
</dt><dd><a href="#1245">#setexternalattr</a>
</dd><dt><strong>PIPES_</strong>
</dt><dd><a href="#17552">Embedding FORM in other</a>
 | <a href="#17555">Embedding FORM in other</a>
</dd><dt><strong>poly_</strong>
</dt><dd><a href="#13942">poly_</a>
</dd><dt><strong>polyadd_</strong>
</dt><dd><a href="#13945">poly_</a>
</dd><dt><strong>polydiv_</strong>
</dt><dd><a href="#13751">div_</a>
 | <a href="#13947">poly_</a>
</dd><dt><strong>polyfun</strong>
</dt><dd><a href="#2464">Modules</a>
 | <a href="#8456">moduleoption</a>
 | <a href="#5378">polyfun</a>
 | <a href="#14802">Brackets</a>
 | <a href="#15979">Sorting and statistics</a>
</dd><dt><strong>polygcd_</strong>
</dt><dd><a href="#13847">gcd_</a>
 | <a href="#13949">poly_</a>
 | <a href="#14936">Polynomials and Factorization</a>
</dd><dt><strong>polyintfac_</strong>
</dt><dd><a href="#13951">poly_</a>
</dd><dt><strong>polylogarithms</strong>
</dt><dd><dl compact="">
<dt><strong>harmonic</strong>
</dt><dd><a href="#2934">argimplode</a>
</dd></dl>
</dd><dt><strong>polymul_</strong>
</dt><dd><a href="#13953">poly_</a>
</dd><dt><strong>polynorm_</strong>
</dt><dd><a href="#13955">poly_</a>
</dd><dt><strong>polyratfun</strong>
</dt><dd><a href="#3396">denominators</a>
 | <a href="#8471">moduleoption</a>
 | <a href="#5403">polyratfun</a>
</dd><dt><strong>polyrem_</strong>
</dt><dd><a href="#13957">poly_</a>
 | <a href="#13996">rem_</a>
</dd><dt><strong>polysub_</strong>
</dt><dd><a href="#13959">poly_</a>
</dd><dt><strong>pophide</strong>
</dt><dd><a href="#5433">pophide</a>
 | <a href="#5673">pushhide</a>
</dd><dt><strong>pos0_</strong>
</dt><dd><a href="#331">Sets</a>
</dd><dt><strong>pos_</strong>
</dt><dd><a href="#329">Sets</a>
</dd><dt><strong>POSIX</strong>
</dt><dd><a href="#17243">The parallel version</a>
</dd><dt><strong>pow</strong>
</dt><dd><a href="#7788">format</a>
</dd><dt><strong>power series</strong>
</dt><dd><a href="#2472">Modules</a>
</dd><dt><strong>powerfirst</strong>
</dt><dd><a href="#16856">The setup</a>
</dd><dt><strong>pre-opened external channels</strong>
</dt><dd><a href="#17550">Embedding FORM in other</a>
</dd><dt><strong>precedence</strong>
</dt><dd><a href="#16061">The setup</a>
</dd><dt><strong>premature</strong>
</dt><dd><a href="#5842">repeat</a>
</dd><dt><strong>preprocessor</strong>
</dt><dd><a href="#658">The preprocessor</a>
</dd><dt><strong>preprocessor variable</strong>
</dt><dd><a href="#911">#define</a>
 | <a href="#1183">#redefine</a>
<dl compact="">
<dt><strong>numeric</strong>
</dt><dd><a href="#712">The preprocessor calculator</a>
</dd></dl>
</dd><dt><strong>preprocessor variables</strong>
</dt><dd><a href="#674">The preprocessor variables</a>
 | <a href="#5778">redefine</a>
 | <a href="#16064">The setup</a>
</dd><dt><strong>prime_</strong>
</dt><dd><a href="#13966">prime_</a>
</dd><dt><strong>print</strong>
</dt><dd><a href="#4903">nprint</a>
 | <a href="#5458">print</a>
 | <a href="#5554">print[]</a>
 | <a href="#5592">printtable</a>
 | <a href="#17285">TFORM</a>
 | <a href="#17323">ParFORM</a>
<dl compact="">
<dt><strong>%$</strong>
</dt><dd><a href="#9725">print</a>
</dd><dt><strong>%%</strong>
</dt><dd><a href="#9738">print</a>
</dd><dt><strong>%t</strong>
</dt><dd><a href="#9671">print</a>
 | <a href="#9684">print</a>
</dd><dt><strong>%w</strong>
</dt><dd><a href="#9697">print</a>
 | <a href="#9711">print</a>
</dd></dl>
</dd><dt><strong>print[]</strong>
</dt><dd><a href="#5555">print[]</a>
</dd><dt><strong>printf</strong>
</dt><dd><a href="#5502">print</a>
</dd><dt><strong>printing</strong>
</dt><dd><a href="#3866">format</a>
</dd><dt><strong>printtable</strong>
</dt><dd><a href="#5589">printtable</a>
</dd><dt><strong>private</strong>
</dt><dd><a href="#17289">TFORM</a>
</dd><dt><strong>procedure</strong>
</dt><dd><a href="#828">#call</a>
 | <a href="#997">#endprocedure</a>
 | <a href="#1156">#procedure</a>
</dd><dt><strong>procedureextension</strong>
</dt><dd><a href="#16757">The setup</a>
</dd><dt><strong>process</strong>
</dt><dd><dl compact="">
<dt><strong>external</strong>
</dt><dd><a href="#17480">External communication</a>
</dd></dl>
</dd><dt><strong>processbucketsize</strong>
</dt><dd><a href="#8486">moduleoption</a>
 | <a href="#5635">processbucketsize</a>
 | <a href="#16774">The setup</a>
 | <a href="#17304">ParFORM</a>
</dd><dt><strong>processor</strong>
</dt><dd><a href="#8502">moduleoption</a>
</dd><dt><strong>prompt</strong>
</dt><dd><a href="#1030">#fromexternal</a>
 | <a href="#1177">#prompt</a>
</dd><dt><strong>propagator</strong>
</dt><dd><a href="#15841">A few notes on</a>
</dd><dt><strong>propercount</strong>
</dt><dd><a href="#5652">propercount</a>
</dd><dt><strong>properorder</strong>
</dt><dd><a href="#8028">identify</a>
</dd><dt><strong>protocol</strong>
</dt><dd><dl compact="">
<dt><strong>lowlevel</strong>
</dt><dd><a href="#17564">Embedding FORM in other</a>
</dd></dl>
</dd><dt><strong>pushhide</strong>
</dt><dd><a href="#5434">pophide</a>
 | <a href="#5671">pushhide</a>
</dd><dt><strong>putinside</strong>
</dt><dd><a href="#5685">putinside</a>
</dd><dt><strong>quadfortran</strong>
</dt><dd><a href="#7748">format</a>
 | <a href="#15559">Dictionaries</a>
</dd><dt><strong>quadruplefortran</strong>
</dt><dd><a href="#7733">format</a>
</dd><dt><strong>question mark</strong>
</dt><dd><a href="#2590">Pattern matching</a>
</dd><dt><strong>quote</strong>
</dt><dd><a href="#676">The preprocessor variables</a>
 | <a href="#1158">#procedure</a>
</dd><dt><strong>random</strong>
</dt><dd><a href="#13988">ranperm_</a>
</dd><dt><strong>random_</strong>
</dt><dd><a href="#1261">#setrandom</a>
 | <a href="#13976">random_</a>
</dd><dt><strong>range</strong>
</dt><dd><a href="#6575">transform</a>
 | <a href="#15536">Dictionaries</a>
 | <a href="#15583">Dictionaries</a>
</dd><dt><strong>ranperm_</strong>
</dt><dd><a href="#13982">ranperm_</a>
</dd><dt><strong>ratio</strong>
</dt><dd><a href="#5701">ratio</a>
</dd><dt><strong>rational</strong>
</dt><dd><a href="#7596">format</a>
</dd><dt><strong>rcyclesymmetrize</strong>
</dt><dd><a href="#5759">rcyclesymmetrize</a>
</dd><dt><strong>reading</strong>
</dt><dd><a href="#1106">#include</a>
</dd><dt><strong>real</strong>
</dt><dd><a href="#225">Symbols</a>
 | <a href="#299">Functions</a>
 | <a href="#7280">cfunctions</a>
 | <a href="#7864">functions</a>
 | <a href="#10010">symbols</a>
 | <a href="#15580">Dictionaries</a>
 | <a href="#15858">A few notes on</a>
</dd><dt><strong>recovery</strong>
</dt><dd><a href="#2486">Checkpoints</a>
</dd><dt><strong>recovery option</strong>
</dt><dd><a href="#2504">Checkpoints</a>
</dd><dt><strong>recursively</strong>
</dt><dd><a href="#3781">fill</a>
</dd><dt><strong>redefine</strong>
</dt><dd><a href="#942">#do</a>
 | <a href="#5777">redefine</a>
</dd><dt><strong>reduce</strong>
</dt><dd><a href="#7826">format</a>
 | <a href="#15830">A few notes on</a>
</dd><dt><strong>rem_</strong>
</dt><dd><a href="#13993">rem_</a>
 | <a href="#14885">Polynomials and Factorization</a>
</dd><dt><strong>remainder</strong>
</dt><dd><a href="#728">The preprocessor calculator</a>
 | <a href="#6098">splitfirstarg</a>
</dd><dt><strong>renumber</strong>
</dt><dd><a href="#408">Dummy indices</a>
 | <a href="#5801">renumber</a>
</dd><dt><strong>repeat</strong>
</dt><dd><a href="#3635">endrepeat</a>
 | <a href="#5823">repeat</a>
</dd><dt><strong>repeat environment</strong>
</dt><dd><a href="#5824">repeat</a>
</dd><dt><strong>replace</strong>
</dt><dd><a href="#10438">transform</a>
</dd><dt><strong>replace_</strong>
</dt><dd><a href="#2625">Pattern matching</a>
 | <a href="#6654">tryreplace</a>
 | <a href="#13857">id_</a>
 | <a href="#13999">replace_</a>
</dd><dt><strong>replaceloop</strong>
</dt><dd><a href="#8179">if</a>
 | <a href="#5857">replaceloop</a>
</dd><dt><strong>replacement</strong>
</dt><dd><a href="#14002">replace_</a>
</dd><dt><strong>representation</strong>
</dt><dd><dl compact="">
<dt><strong>textual</strong>
</dt><dd><a href="#2724">The dollar variables</a>
</dd></dl>
</dd><dt><strong>resettimeonclear</strong>
</dt><dd><a href="#2452">Modules</a>
 | <a href="#16792">The setup</a>
</dd><dt><strong>restriction</strong>
</dt><dd><dl compact="">
<dt><strong>power</strong>
</dt><dd><a href="#226">Symbols</a>
</dd></dl>
</dd><dt><strong>restrictions</strong>
</dt><dd><a href="#450">Restrictions</a>
</dd><dt><strong>reverse</strong>
</dt><dd><a href="#10526">transform</a>
</dd><dt><strong>reverse cycle symmetric</strong>
</dt><dd><a href="#7370">cfunctions</a>
 | <a href="#7955">functions</a>
</dd><dt><strong>reverse cycle symmetrize</strong>
</dt><dd><a href="#5762">rcyclesymmetrize</a>
</dd><dt><strong>reverse_</strong>
</dt><dd><a href="#14008">reverse_</a>
</dd><dt><strong>root of unity</strong>
</dt><dd><a href="#6157">stuffle</a>
 | <a href="#10056">symbols</a>
</dd><dt><strong>root_</strong>
</dt><dd><a href="#14012">root_</a>
</dd><dt><strong>rounding</strong>
</dt><dd><a href="#13872">integer_</a>
</dd><dt><strong>run</strong>
</dt><dd><a href="#2499">Checkpoints</a>
</dd><dt><strong>run a script</strong>
</dt><dd><a href="#2495">Checkpoints</a>
</dd><dt><strong>running FORM</strong>
</dt><dd><a href="#111">Running FORM</a>
</dd><dt><strong>runtime error</strong>
</dt><dd><a href="#2720">The dollar variables</a>
</dd><dt><strong>save</strong>
</dt><dd><a href="#5930">save</a>
</dd><dt><strong>save files</strong>
</dt><dd><a href="#2507">Checkpoints</a>
</dd><dt><strong>saved file</strong>
</dt><dd><a href="#4567">load</a>
</dd><dt><strong>scalar objects</strong>
</dt><dd><a href="#2608">Pattern matching</a>
</dd><dt><strong>Schoonschip</strong>
</dt><dd><a href="#2601">Pattern matching</a>
 | <a href="#5741">ratio</a>
 | <a href="#6362">tensors</a>
 | <a href="#13831">g6_</a>
 | <a href="#13836">g7_</a>
 | <a href="#14040">sump_</a>
 | <a href="#15829">A few notes on</a>
</dd><dt><strong>scratch files</strong>
</dt><dd><a href="#2506">Checkpoints</a>
</dd><dt><strong>ScratchSize</strong>
</dt><dd><a href="#2428">Modules</a>
 | <a href="#4135">hide</a>
 | <a href="#16808">The setup</a>
</dd><dt><strong>screen</strong>
</dt><dd><a href="#9585">print</a>
</dd><dt><strong>script</strong>
</dt><dd><a href="#1244">#setexternalattr</a>
</dd><dt><strong>select</strong>
</dt><dd><a href="#8007">identify</a>
 | <a href="#8136">if</a>
 | <a href="#5953">select</a>
</dd><dt><strong>semicolon</strong>
</dt><dd><a href="#1127">#message</a>
 | <a href="#1351">#write</a>
 | <a href="#4262">if</a>
</dd><dt><strong>set</strong>
</dt><dd><a href="#2633">Pattern matching</a>
 | <a href="#8014">identify</a>
 | <a href="#5973">set</a>
 | <a href="#6081">splitarg</a>
 | <a href="#6099">splitfirstarg</a>
 | <a href="#6116">splitlastarg</a>
<dl compact="">
<dt><strong>ambiguous</strong>
</dt><dd><a href="#2644">Pattern matching</a>
</dd><dt><strong>corresponding element</strong>
</dt><dd><a href="#2654">Pattern matching</a>
</dd><dt><strong>dynamical</strong>
</dt><dd><a href="#749">The preprocessor calculator</a>
 | <a href="#2636">Pattern matching</a>
</dd><dt><strong>inside</strong>
</dt><dd><a href="#368">Sets</a>
</dd><dt><strong>mixed</strong>
</dt><dd><a href="#5977">set</a>
</dd><dt><strong>outside</strong>
</dt><dd><a href="#369">Sets</a>
</dd></dl>
</dd><dt><strong>set of indices</strong>
</dt><dd><a href="#2641">Pattern matching</a>
</dd><dt><strong>Set of symbols</strong>
</dt><dd><a href="#2640">Pattern matching</a>
</dd><dt><strong>setexitflag</strong>
</dt><dd><a href="#5986">setexitflag</a>
</dd><dt><strong>setfun_</strong>
</dt><dd><a href="#14016">setfun_</a>
</dd><dt><strong>setrandom</strong>
</dt><dd><a href="#13991">ranperm_</a>
</dd><dt><strong>sets</strong>
</dt><dd><a href="#320">Sets</a>
<dl compact="">
<dt><strong>array</strong>
</dt><dd><a href="#2645">Pattern matching</a>
</dd><dt><strong>implicitly declared</strong>
</dt><dd><a href="#361">Sets</a>
</dd><dt><strong>named</strong>
</dt><dd><a href="#375">Sets</a>
</dd></dl>
</dd><dt><strong>settings</strong>
</dt><dd><a href="#5082">off</a>
</dd><dt><strong>setup</strong>
</dt><dd><a href="#16000">Sorting and statistics</a>
 | <a href="#16056">The setup</a>
<dl compact="">
<dt><strong>bracketindexsize</strong>
</dt><dd><a href="#16422">The setup</a>
</dd><dt><strong>commentchar</strong>
</dt><dd><a href="#16439">The setup</a>
</dd><dt><strong>compresssize</strong>
</dt><dd><a href="#16453">The setup</a>
</dd><dt><strong>constindex</strong>
</dt><dd><a href="#16468">The setup</a>
</dd><dt><strong>continuationlines</strong>
</dt><dd><a href="#16484">The setup</a>
</dd><dt><strong>define</strong>
</dt><dd><a href="#16499">The setup</a>
</dd><dt><strong>dotchar</strong>
</dt><dd><a href="#16516">The setup</a>
</dd><dt><strong>filepatches</strong>
</dt><dd><a href="#16994">The setup</a>
</dd><dt><strong>functionlevels</strong>
</dt><dd><a href="#16532">The setup</a>
</dd><dt><strong>hidesize</strong>
</dt><dd><a href="#16546">The setup</a>
</dd><dt><strong>incdir</strong>
</dt><dd><a href="#16560">The setup</a>
 | <a href="#16746">The setup</a>
</dd><dt><strong>insidefirst</strong>
</dt><dd><a href="#16579">The setup</a>
</dd><dt><strong>largepatches</strong>
</dt><dd><a href="#17008">The setup</a>
</dd><dt><strong>largesize</strong>
</dt><dd><a href="#17064">The setup</a>
</dd><dt><strong>maxnumbersize</strong>
</dt><dd><a href="#16593">The setup</a>
</dd><dt><strong>maxtermsize</strong>
</dt><dd><a href="#16610">The setup</a>
</dd><dt><strong>maxwildcards</strong>
</dt><dd><a href="#16629">The setup</a>
</dd><dt><strong>nospacesinnumbers</strong>
</dt><dd><a href="#16643">The setup</a>
</dd><dt><strong>numstorecaches</strong>
</dt><dd><a href="#16663">The setup</a>
</dd><dt><strong>nwritestatistics</strong>
</dt><dd><a href="#16677">The setup</a>
</dd><dt><strong>nwritethreadstatistics</strong>
</dt><dd><a href="#16691">The setup</a>
</dd><dt><strong>oldorder</strong>
</dt><dd><a href="#16708">The setup</a>
</dd><dt><strong>parentheses</strong>
</dt><dd><a href="#16722">The setup</a>
</dd><dt><strong>path</strong>
</dt><dd><a href="#16570">The setup</a>
 | <a href="#16736">The setup</a>
</dd><dt><strong>procedureEetension</strong>
</dt><dd><a href="#16756">The setup</a>
</dd><dt><strong>processbucketsize</strong>
</dt><dd><a href="#16773">The setup</a>
</dd><dt><strong>resettimeonclear</strong>
</dt><dd><a href="#16791">The setup</a>
</dd><dt><strong>scratchsize</strong>
</dt><dd><a href="#16807">The setup</a>
</dd><dt><strong>sizestorecache</strong>
</dt><dd><a href="#16827">The setup</a>
</dd><dt><strong>smallextension</strong>
</dt><dd><a href="#17050">The setup</a>
</dd><dt><strong>smallsize</strong>
</dt><dd><a href="#17036">The setup</a>
</dd><dt><strong>sortiosize</strong>
</dt><dd><a href="#17078">The setup</a>
</dd><dt><strong>sorttype</strong>
</dt><dd><a href="#16846">The setup</a>
</dd><dt><strong>tempdir</strong>
</dt><dd><a href="#16865">The setup</a>
</dd><dt><strong>termsinsmall</strong>
</dt><dd><a href="#17022">The setup</a>
</dd><dt><strong>threadbucketsize</strong>
</dt><dd><a href="#16882">The setup</a>
</dd><dt><strong>threadloadbalancing</strong>
</dt><dd><a href="#16898">The setup</a>
</dd><dt><strong>threads</strong>
</dt><dd><a href="#16914">The setup</a>
</dd><dt><strong>threadscratchoutsize</strong>
</dt><dd><a href="#16930">The setup</a>
</dd><dt><strong>threadscratchsize</strong>
</dt><dd><a href="#16945">The setup</a>
</dd><dt><strong>totalsize</strong>
</dt><dd><a href="#16960">The setup</a>
</dd><dt><strong>workspace</strong>
</dt><dd><a href="#16978">The setup</a>
</dd></dl>
</dd><dt><strong>setup file</strong>
</dt><dd><a href="#201">Names</a>
</dd><dt><strong>shell</strong>
</dt><dd><a href="#1242">#setexternalattr</a>
 | <a href="#1243">#setexternalattr</a>
 | <a href="#2500">Checkpoints</a>
 | <a href="#17479">External communication</a>
 | <a href="#17530">#setexternalattr</a>
 | <a href="#17531">#setexternalattr</a>
</dd><dt><strong>short integer</strong>
</dt><dd><a href="#3848">fixindex</a>
</dd><dt><strong>shorthand</strong>
</dt><dd><a href="#4358">if</a>
 | <a href="#5830">repeat</a>
</dd><dt><strong>SHOWINPUT_</strong>
</dt><dd><a href="#685">The preprocessor variables</a>
 | <a href="#1272">#show</a>
</dd><dt><strong>shuffle</strong>
</dt><dd><a href="#4645">merge</a>
 | <a href="#6154">stuffle</a>
</dd><dt><strong>sig_</strong>
</dt><dd><a href="#14020">sig_</a>
</dd><dt><strong>SIGKILL signal</strong>
</dt><dd><a href="#1239">#setexternalattr</a>
 | <a href="#17526">#setexternalattr</a>
</dd><dt><strong>sign_</strong>
</dt><dd><a href="#14024">sign_</a>
</dd><dt><strong>signal</strong>
</dt><dd><a href="#17259">TFORM</a>
</dd><dt><strong>sin_</strong>
</dt><dd><a href="#14095">Extra reserved names</a>
</dd><dt><strong>single term mode</strong>
</dt><dd><a href="#9600">print</a>
</dd><dt><strong>sinh_</strong>
</dt><dd><a href="#14137">Extra reserved names</a>
</dd><dt><strong>sizestorecache</strong>
</dt><dd><a href="#16828">The setup</a>
</dd><dt><strong>skip</strong>
</dt><dd><a href="#4916">nskip</a>
 | <a href="#6026">skip</a>
</dd><dt><strong>skipped expressions</strong>
</dt><dd><a href="#4137">hide</a>
</dd><dt><strong>slow</strong>
</dt><dd><a href="#14772">Brackets</a>
</dd><dt><strong>small buffer</strong>
</dt><dd><a href="#15974">Sorting and statistics</a>
 | <a href="#16278">The setup</a>
</dd><dt><strong>small extension</strong>
</dt><dd><a href="#15976">Sorting and statistics</a>
</dd><dt><strong>smallextension</strong>
</dt><dd><a href="#15978">Sorting and statistics</a>
 | <a href="#16282">The setup</a>
 | <a href="#17051">The setup</a>
</dd><dt><strong>smallsize</strong>
</dt><dd><a href="#16280">The setup</a>
 | <a href="#17037">The setup</a>
</dd><dt><strong>sort</strong>
</dt><dd><a href="#6028">skip</a>
 | <a href="#6047">sort</a>
 | <a href="#6381">term</a>
<dl compact="">
<dt><strong>final stage</strong>
</dt><dd><a href="#14807">Brackets</a>
</dd></dl>
</dd><dt><strong>sort file</strong>
</dt><dd><a href="#15990">Sorting and statistics</a>
</dd><dt><strong>sorting</strong>
</dt><dd><a href="#14814">Brackets</a>
 | <a href="#15966">Sorting and statistics</a>
</dd><dt><strong>sortiosize</strong>
</dt><dd><a href="#15998">Sorting and statistics</a>
 | <a href="#16291">The setup</a>
 | <a href="#17079">The setup</a>
</dd><dt><strong>sorttype</strong>
</dt><dd><a href="#16847">The setup</a>
</dd><dt><strong>spaces</strong>
</dt><dd><a href="#7624">format</a>
</dd><dt><strong>sparse</strong>
</dt><dd><a href="#3363">deallocatetable</a>
 | <a href="#6307">table</a>
 | <a href="#15223">The TableBase</a>
 | <a href="#15259">addto</a>
</dd><dt><strong>specifications</strong>
</dt><dd><a href="#2432">Modules</a>
</dd><dt><strong>spin line</strong>
</dt><dd><a href="#6560">tracen</a>
 | <a href="#15669">Dirac algebra</a>
</dd><dt><strong>spinline</strong>
</dt><dd><a href="#3155">chisholm</a>
</dd><dt><strong>splitarg</strong>
</dt><dd><a href="#3713">factarg</a>
 | <a href="#4859">normalize</a>
 | <a href="#6067">splitarg</a>
 | <a href="#6096">splitfirstarg</a>
 | <a href="#6114">splitlastarg</a>
</dd><dt><strong>splitfirstarg</strong>
</dt><dd><a href="#6095">splitfirstarg</a>
</dd><dt><strong>splitlastarg</strong>
</dt><dd><a href="#6113">splitlastarg</a>
</dd><dt><strong>sqrt_</strong>
</dt><dd><a href="#14083">Extra reserved names</a>
</dd><dt><strong>square root</strong>
</dt><dd><a href="#737">The preprocessor calculator</a>
</dd><dt><strong>stack overflow</strong>
</dt><dd><a href="#3782">fill</a>
</dd><dt><strong>stages in the sorting</strong>
</dt><dd><a href="#15995">Sorting and statistics</a>
</dd><dt><strong>standard error</strong>
</dt><dd><a href="#1249">#setexternalattr</a>
</dd><dt><strong>standard input</strong>
</dt><dd><a href="#1017">#external</a>
</dd><dt><strong>standard output</strong>
</dt><dd><a href="#1016">#external</a>
</dd><dt><strong>statements</strong>
</dt><dd><a href="#2423">Modules</a>
</dd><dt><strong>stderr</strong>
</dt><dd><a href="#1248">#setexternalattr</a>
 | <a href="#17535">#setexternalattr</a>
</dd><dt><strong>storage  file</strong>
</dt><dd><a href="#4092">global</a>
</dd><dt><strong>storage file</strong>
</dt><dd><a href="#3378">delete</a>
</dd><dt><strong>store file</strong>
</dt><dd><a href="#5931">save</a>
</dd><dt><strong>strict</strong>
</dt><dd><a href="#6314">table</a>
</dd><dt><strong>string</strong>
</dt><dd><a href="#1352">#write</a>
</dd><dt><strong>strong typing</strong>
</dt><dd><a href="#382">The autodeclare conventions</a>
</dd><dt><strong>stub</strong>
</dt><dd><a href="#15327">testuse</a>
</dd><dt><strong>stub function</strong>
</dt><dd><a href="#15240">The TableBase</a>
</dd><dt><strong>student</strong>
</dt><dd><a href="#15883">A few notes on</a>
</dd><dt><strong>stuffle</strong>
</dt><dd><a href="#6014">shuffle</a>
</dd><dt><strong>subexpressions</strong>
</dt><dd><a href="#16328">The setup</a>
</dd><dt><strong>substaidentify</strong>
</dt><dd><a href="#13859">id_</a>
</dd><dt><strong>substitution</strong>
</dt><dd><dl compact="">
<dt><strong>delayed</strong>
</dt><dd><a href="#918">#define</a>
 | <a href="#2734">The dollar variables</a>
</dd></dl>
</dd><dt><strong>substitutions</strong>
</dt><dd><a href="#2585">Pattern matching</a>
</dd><dt><strong>subtraction</strong>
</dt><dd><a href="#725">The preprocessor calculator</a>
</dd><dt><strong>SUBVERSION_</strong>
</dt><dd><a href="#681">The preprocessor variables</a>
</dd><dt><strong>sum</strong>
</dt><dd><a href="#346">Sets</a>
 | <a href="#6169">sum</a>
 | <a href="#14031">sum_</a>
</dd><dt><strong>sum_</strong>
</dt><dd><a href="#14028">sum_</a>
</dd><dt><strong>summation</strong>
</dt><dd><dl compact="">
<dt><strong>Einstein</strong>
</dt><dd><a href="#264">Indices</a>
 | <a href="#311">Functions</a>
 | <a href="#437">Kronecker delta's</a>
</dd></dl>
</dd><dt><strong>sump_</strong>
</dt><dd><a href="#14035">sump_</a>
</dd><dt><strong>sums</strong>
</dt><dd><dl compact="">
<dt><strong>harmonic</strong>
</dt><dd><a href="#2932">argimplode</a>
</dd></dl>
</dd><dt><strong>superpatch</strong>
</dt><dd><a href="#16292">The setup</a>
</dd><dt><strong>symbol</strong>
</dt><dd><a href="#6188">symbols</a>
</dd><dt><strong>symbol_</strong>
</dt><dd><a href="#337">Sets</a>
</dd><dt><strong>symbols</strong>
</dt><dd><a href="#217">Symbols</a>
 | <a href="#7119">auto, autodeclare</a>
 | <a href="#7513">dimension</a>
 | <a href="#14999">Output optimization</a>
<dl compact="">
<dt><strong>built in</strong>
</dt><dd><a href="#231">Symbols</a>
</dd></dl>
</dd><dt><strong>symmetric</strong>
</dt><dd><a href="#7325">cfunctions</a>
 | <a href="#7909">functions</a>
<dl compact="">
<dt><strong>anti</strong>
</dt><dd><a href="#5903">replaceloop</a>
</dd><dt><strong>cycle</strong>
</dt><dd><a href="#7940">functions</a>
 | <a href="#5898">replaceloop</a>
</dd><dt><strong>reverse cycle</strong>
</dt><dd><a href="#7956">functions</a>
</dd></dl>
</dd><dt><strong>symmetrization</strong>
</dt><dd><a href="#10179">symmetrize</a>
</dd><dt><strong>symmetrize</strong>
</dt><dd><a href="#5760">rcyclesymmetrize</a>
 | <a href="#6239">symmetrize</a>
 | <a href="#15703">Dirac algebra</a>
<dl compact="">
<dt><strong>reverse cycle</strong>
</dt><dd><a href="#5763">rcyclesymmetrize</a>
</dd></dl>
</dd><dt><strong>tab</strong>
</dt><dd><a href="#1343">#write</a>
</dd><dt><strong>table</strong>
</dt><dd><a href="#3775">fill</a>
 | <a href="#3827">fillexpression</a>
 | <a href="#4937">ntable</a>
 | <a href="#5593">printtable</a>
 | <a href="#5976">set</a>
 | <a href="#6300">table</a>
 | <a href="#13650">Functions</a>
 | <a href="#15215">The TableBase</a>
<dl compact="">
<dt><strong>check</strong>
</dt><dd><a href="#10209">table</a>
</dd><dt><strong>commuting</strong>
</dt><dd><a href="#3319">ctable</a>
</dd><dt><strong>matrix like</strong>
</dt><dd><a href="#10243">table</a>
 | <a href="#6308">table</a>
</dd><dt><strong>noncommuting</strong>
</dt><dd><a href="#4936">ntable</a>
</dd><dt><strong>onefill</strong>
</dt><dd><a href="#10276">table</a>
</dd><dt><strong>relax</strong>
</dt><dd><a href="#10222">table</a>
</dd><dt><strong>sparse</strong>
</dt><dd><a href="#3364">deallocatetable</a>
 | <a href="#10235">table</a>
 | <a href="#6309">table</a>
</dd><dt><strong>strict</strong>
</dt><dd><a href="#10250">table</a>
</dd><dt><strong>zerofill</strong>
</dt><dd><a href="#10263">table</a>
</dd></dl>
</dd><dt><strong>table elements</strong>
</dt><dd><a href="#15214">The TableBase</a>
</dd><dt><strong>table index</strong>
</dt><dd><a href="#13651">Functions</a>
</dd><dt><strong>table indices</strong>
</dt><dd><a href="#6305">table</a>
</dd><dt><strong>table_</strong>
</dt><dd><a href="#14042">table_</a>
</dd><dt><strong>tablebase</strong>
</dt><dd><a href="#6347">tablebase</a>
 | <a href="#6398">testuse</a>
 | <a href="#14052">tbl_</a>
 | <a href="#15212">The TableBase</a>
</dd><dt><strong>tables</strong>
</dt><dd><a href="#306">Functions</a>
</dd><dt><strong>tan_</strong>
</dt><dd><a href="#14107">Extra reserved names</a>
</dd><dt><strong>tanh_</strong>
</dt><dd><a href="#14149">Extra reserved names</a>
</dd><dt><strong>tbl_</strong>
</dt><dd><a href="#14049">tbl_</a>
 | <a href="#15219">The TableBase</a>
 | <a href="#15241">The TableBase</a>
 | <a href="#15328">testuse</a>
</dd><dt><strong>tempdir</strong>
</dt><dd><a href="#16866">The setup</a>
</dd><dt><strong>temporary  variables</strong>
</dt><dd><a href="#14992">Output optimization</a>
</dd><dt><strong>temporary files</strong>
</dt><dd><a href="#15991">Sorting and statistics</a>
</dd><dt><strong>tensor</strong>
</dt><dd><a href="#4954">ntensors</a>
 | <a href="#5975">set</a>
 | <a href="#6361">tensors</a>
 | <a href="#13649">Functions</a>
<dl compact="">
<dt><strong>commuting</strong>
</dt><dd><a href="#3334">ctensors</a>
</dd><dt><strong>Levi-Civita</strong>
</dt><dd><a href="#3264">contract</a>
 | <a href="#13772">e_</a>
 | <a href="#15844">A few notes on</a>
</dd><dt><strong>metric</strong>
</dt><dd><a href="#15834">A few notes on</a>
</dd><dt><strong>noncommuting</strong>
</dt><dd><a href="#4953">ntensors</a>
</dd></dl>
</dd><dt><strong>tensors</strong>
</dt><dd><a href="#305">Functions</a>
 | <a href="#309">Functions</a>
<dl compact="">
<dt><strong>commuting</strong>
</dt><dd><a href="#7231">auto, autodeclare</a>
 | <a href="#7259">auto, autodeclare</a>
</dd><dt><strong>noncommuting</strong>
</dt><dd><a href="#7245">auto, autodeclare</a>
 | <a href="#8088">identify</a>
</dd></dl>
</dd><dt><strong>term</strong>
</dt><dd><a href="#3648">endterm</a>
 | <a href="#6048">sort</a>
 | <a href="#6377">term</a>
</dd><dt><strong>term_</strong>
</dt><dd><a href="#14055">term_</a>
</dd><dt><strong>terminate</strong>
</dt><dd><a href="#974">#enddo</a>
</dd><dt><strong>termination</strong>
</dt><dd><a href="#2480">Checkpoints</a>
 | <a href="#5987">setexitflag</a>
<dl compact="">
<dt><strong>premature</strong>
</dt><dd><a href="#5843">repeat</a>
</dd></dl>
</dd><dt><strong>terms</strong>
</dt><dd><a href="#182">Variables</a>
</dd><dt><strong>termsin</strong>
</dt><dd><a href="#1509">#if</a>
</dd><dt><strong>termsin_</strong>
</dt><dd><a href="#14061">termsin_</a>
</dd><dt><strong>termsinbracket_</strong>
</dt><dd><a href="#14067">termsinbracket_</a>
</dd><dt><strong>termsinsmall</strong>
</dt><dd><a href="#16281">The setup</a>
 | <a href="#17023">The setup</a>
</dd><dt><strong>testuse</strong>
</dt><dd><a href="#6397">testuse</a>
 | <a href="#15242">The TableBase</a>
 | <a href="#15269">apply</a>
 | <a href="#15326">testuse</a>
 | <a href="#15335">use</a>
</dd><dt><strong>TFORM</strong>
</dt><dd><a href="#2769">Dollar variables in a</a>
 | <a href="#4451">inparallel</a>
 | <a href="#4886">notinparallel</a>
 | <a href="#6408">threadbucketsize</a>
 | <a href="#17235">The parallel version</a>
 | <a href="#17250">TFORM</a>
</dd><dt><strong>theta_</strong>
</dt><dd><a href="#14073">theta_</a>
</dd><dt><strong>thetap_</strong>
</dt><dd><a href="#14077">thetap_</a>
</dd><dt><strong>thread</strong>
</dt><dd><a href="#2774">Dollar variables in a</a>
 | <a href="#8503">moduleoption</a>
</dd><dt><strong>threadbucketsize</strong>
</dt><dd><a href="#6407">threadbucketsize</a>
 | <a href="#16883">The setup</a>
 | <a href="#17261">TFORM</a>
</dd><dt><strong>threadloadbalancing</strong>
</dt><dd><a href="#16899">The setup</a>
 | <a href="#17264">TFORM</a>
</dd><dt><strong>threads</strong>
</dt><dd><a href="#16915">The setup</a>
</dd><dt><strong>threadscratchoutsize</strong>
</dt><dd><a href="#16931">The setup</a>
</dd><dt><strong>threadscratchsize</strong>
</dt><dd><a href="#16946">The setup</a>
</dd><dt><strong>time</strong>
</dt><dd><a href="#2491">Checkpoints</a>
</dd><dt><strong>time_</strong>
</dt><dd><a href="#699">The preprocessor variables</a>
</dd><dt><strong>timer_</strong>
</dt><dd><a href="#700">The preprocessor variables</a>
</dd><dt><strong>tointegralnotation</strong>
</dt><dd><a href="#10496">transform</a>
</dd><dt><strong>tolyndon</strong>
</dt><dd><a href="#10569">transform</a>
</dd><dt><strong>topolynomial</strong>
</dt><dd><a href="#3693">extrasymbols</a>
 | <a href="#15007">Output optimization</a>
</dd><dt><strong>tosumnotation</strong>
</dt><dd><a href="#10480">transform</a>
</dd><dt><strong>totalsize</strong>
</dt><dd><a href="#123">Running FORM</a>
 | <a href="#9539">on</a>
 | <a href="#16961">The setup</a>
</dd><dt><strong>totensor</strong>
</dt><dd><a href="#6450">totensor</a>
 | <a href="#6497">tovector</a>
<dl compact="">
<dt><strong>!set</strong>
</dt><dd><a href="#10336">totensor</a>
</dd><dt><strong>!vector</strong>
</dt><dd><a href="#10323">totensor</a>
</dd><dt><strong>functions</strong>
</dt><dd><a href="#10310">totensor</a>
</dd><dt><strong>nosquare</strong>
</dt><dd><a href="#10297">totensor</a>
</dd></dl>
</dd><dt><strong>tovector</strong>
</dt><dd><a href="#6496">tovector</a>
</dd><dt><strong>trace</strong>
</dt><dd><a href="#15676">Dirac algebra</a>
</dd><dt><strong>trace contractions</strong>
</dt><dd><a href="#7515">dimension</a>
</dd><dt><strong>trace line</strong>
</dt><dd><a href="#6523">trace4</a>
</dd><dt><strong>trace4</strong>
</dt><dd><a href="#6521">trace4</a>
 | <a href="#15749">Dirac algebra</a>
 | <a href="#15699">Dirac algebra</a>
<dl compact="">
<dt><strong>contract</strong>
</dt><dd><a href="#10349">trace4</a>
</dd><dt><strong>nocontract</strong>
</dt><dd><a href="#10364">trace4</a>
</dd><dt><strong>nosymmetrize</strong>
</dt><dd><a href="#10379">trace4</a>
</dd><dt><strong>notrick</strong>
</dt><dd><a href="#10394">trace4</a>
</dd></dl>
</dd><dt><strong>tracen</strong>
</dt><dd><a href="#6558">tracen</a>
 | <a href="#15764">Dirac algebra</a>
</dd><dt><strong>traces</strong>
</dt><dd><a href="#284">Indices</a>
</dd><dt><strong>traffic jam</strong>
</dt><dd><a href="#15994">Sorting and statistics</a>
</dd><dt><strong>transform</strong>
</dt><dd><a href="#6573">transform</a>
<dl compact="">
<dt><strong>cycle</strong>
</dt><dd><a href="#10539">transform</a>
</dd><dt><strong>decode</strong>
</dt><dd><a href="#10465">transform</a>
</dd><dt><strong>encode</strong>
</dt><dd><a href="#10451">transform</a>
</dd><dt><strong>explode</strong>
</dt><dd><a href="#10497">transform</a>
</dd><dt><strong>implode</strong>
</dt><dd><a href="#10481">transform</a>
</dd><dt><strong>islyndon</strong>
</dt><dd><a href="#10553">transform</a>
</dd><dt><strong>permute</strong>
</dt><dd><a href="#10511">transform</a>
</dd><dt><strong>replace</strong>
</dt><dd><a href="#10437">transform</a>
</dd><dt><strong>reverse</strong>
</dt><dd><a href="#10525">transform</a>
</dd><dt><strong>tointegralnotation</strong>
</dt><dd><a href="#10495">transform</a>
</dd><dt><strong>tolyndon</strong>
</dt><dd><a href="#10568">transform</a>
</dd><dt><strong>tosumnotation</strong>
</dt><dd><a href="#10479">transform</a>
</dd></dl>
</dd><dt><strong>translation</strong>
</dt><dd><a href="#15519">Dictionaries</a>
</dd><dt><strong>tree</strong>
</dt><dd><dl compact="">
<dt><strong>balanced</strong>
</dt><dd><a href="#10242">table</a>
</dd><dt><strong>index</strong>
</dt><dd><a href="#14784">Brackets</a>
</dd></dl>
</dd><dt><strong>tree of losers</strong>
</dt><dd><a href="#15986">Sorting and statistics</a>
</dd><dt><strong>tree sort</strong>
</dt><dd><a href="#15968">Sorting and statistics</a>
</dd><dt><strong>tricks</strong>
</dt><dd><a href="#15756">Dirac algebra</a>
</dd><dt><strong>tryreplace</strong>
</dt><dd><a href="#6653">tryreplace</a>
</dd><dt><strong>twolog</strong>
</dt><dd><a href="#735">The preprocessor calculator</a>
</dd><dt><strong>underscore</strong>
</dt><dd><a href="#196">Names</a>
 | <a href="#206">Names</a>
 | <a href="#209">Names</a>
</dd><dt><strong>underscore character</strong>
</dt><dd><a href="#7791">format</a>
</dd><dt><strong>unhide</strong>
</dt><dd><a href="#4146">hide</a>
 | <a href="#4988">nunhide</a>
 | <a href="#6686">unhide</a>
</dd><dt><strong>unit matrix</strong>
</dt><dd><a href="#6707">unittrace</a>
 | <a href="#15686">Dirac algebra</a>
</dd><dt><strong>unittrace</strong>
</dt><dd><a href="#6706">unittrace</a>
</dd><dt><strong>UNIX</strong>
</dt><dd><a href="#112">Running FORM</a>
 | <a href="#1140">#pipe</a>
 | <a href="#1193">#remove</a>
 | <a href="#2588">Pattern matching</a>
 | <a href="#16276">The setup</a>
 | <a href="#17244">The parallel version</a>
 | <a href="#17545">An example</a>
</dd><dt><strong>unpleasant</strong>
</dt><dd><a href="#4473">inside</a>
</dd><dt><strong>upper</strong>
</dt><dd><a href="#3273">contract</a>
</dd><dt><strong>use</strong>
</dt><dd><a href="#15245">The TableBase</a>
 | <a href="#15270">apply</a>
 | <a href="#15329">testuse</a>
 | <a href="#15334">use</a>
</dd><dt><strong>variable</strong>
</dt><dd><dl compact="">
<dt><strong>dollar</strong>
</dt><dd><a href="#3792">fill</a>
</dd><dt><strong>preprocessor</strong>
</dt><dd><a href="#912">#define</a>
 | <a href="#1184">#redefine</a>
 | <a href="#1266">#show</a>
 | <a href="#1324">#undefine</a>
 | <a href="#2723">The dollar variables</a>
</dd></dl>
</dd><dt><strong>variables</strong>
</dt><dd><dl compact="">
<dt><strong>algebraic</strong>
</dt><dd><a href="#2715">The dollar variables</a>
</dd><dt><strong>dollar</strong>
</dt><dd><a href="#186">Variables</a>
 | <a href="#204">Names</a>
 | <a href="#423">Dummy indices</a>
 | <a href="#2716">The dollar variables</a>
</dd><dt><strong>lists</strong>
</dt><dd><a href="#392">Name lists</a>
</dd><dt><strong>preprocessor</strong>
</dt><dd><a href="#184">Variables</a>
 | <a href="#195">Names</a>
 | <a href="#205">Names</a>
 | <a href="#999">#endprocedure</a>
 | <a href="#2714">The dollar variables</a>
 | <a href="#5779">redefine</a>
</dd><dt><strong>total number of</strong>
</dt><dd><a href="#451">Restrictions</a>
</dd></dl>
</dd><dt><strong>vector</strong>
</dt><dd><a href="#6721">vectors</a>
</dd><dt><strong>vectors</strong>
</dt><dd><a href="#242">Vectors</a>
 | <a href="#7133">auto, autodeclare</a>
</dd><dt><strong>VERSION_</strong>
</dt><dd><a href="#680">The preprocessor variables</a>
 | <a href="#1269">#show</a>
</dd><dt><strong>vertices</strong>
</dt><dd><a href="#5864">replaceloop</a>
</dd><dt><strong>veto</strong>
</dt><dd><a href="#2773">Dollar variables in a</a>
</dd><dt><strong>virtual bracket</strong>
</dt><dd><a href="#13757">dum_</a>
</dd><dt><strong>warning</strong>
</dt><dd><a href="#3209">collect</a>
 | <a href="#3786">fill</a>
</dd><dt><strong>warnings</strong>
</dt><dd><a href="#15539">Dictionaries</a>
</dd><dt><strong>water</strong>
</dt><dd><a href="#15882">A few notes on</a>
</dd><dt><strong>weight</strong>
</dt><dd><a href="#8106">if</a>
</dd><dt><strong>while</strong>
</dt><dd><a href="#3662">endwhile</a>
 | <a href="#6734">while</a>
</dd><dt><strong>wildcard</strong>
</dt><dd><a href="#2589">Pattern matching</a>
 | <a href="#2746">The dollar variables</a>
 | <a href="#4171">identify</a>
 | <a href="#13654">Functions</a>
<dl compact="">
<dt><strong>$-variable</strong>
</dt><dd><a href="#2655">Pattern matching</a>
</dd><dt><strong>argument field</strong>
</dt><dd><a href="#2613">Pattern matching</a>
 | <a href="#14250">Functions</a>
</dd><dt><strong>function</strong>
</dt><dd><a href="#2594">Pattern matching</a>
</dd><dt><strong>index</strong>
</dt><dd><a href="#2598">Pattern matching</a>
</dd><dt><strong>symbol</strong>
</dt><dd><a href="#2607">Pattern matching</a>
</dd><dt><strong>vector</strong>
</dt><dd><a href="#2604">Pattern matching</a>
</dd></dl>
</dd><dt><strong>wildcarding</strong>
</dt><dd><a href="#349">Sets</a>
</dd><dt><strong>wildcards</strong>
</dt><dd><a href="#6315">table</a>
</dd><dt><strong>Windows</strong>
</dt><dd><a href="#1197">#remove</a>
</dd><dt><strong>word</strong>
</dt><dd><a href="#15518">Dictionaries</a>
</dd><dt><strong>worker</strong>
</dt><dd><a href="#17251">TFORM</a>
</dd><dt><strong>workers</strong>
</dt><dd><a href="#17239">The parallel version</a>
</dd><dt><strong>workspace</strong>
</dt><dd><a href="#16979">The setup</a>
</dd><dt><strong>write</strong>
</dt><dd><a href="#6761">write</a>
<dl compact="">
<dt><strong>allnames</strong>
</dt><dd><a href="#10591">write</a>
</dd><dt><strong>allwarnings</strong>
</dt><dd><a href="#10604">write</a>
</dd><dt><strong>highfirst</strong>
</dt><dd><a href="#10617">write</a>
</dd><dt><strong>lowfirst</strong>
</dt><dd><a href="#10630">write</a>
</dd><dt><strong>names</strong>
</dt><dd><a href="#10643">write</a>
</dd><dt><strong>powerfirst</strong>
</dt><dd><a href="#10656">write</a>
</dd><dt><strong>setup</strong>
</dt><dd><a href="#10669">write</a>
</dd><dt><strong>shortstatistics</strong>
</dt><dd><a href="#10682">write</a>
</dd><dt><strong>shortstats</strong>
</dt><dd><a href="#10695">write</a>
</dd><dt><strong>statistics</strong>
</dt><dd><a href="#10708">write</a>
</dd><dt><strong>stats</strong>
</dt><dd><a href="#10721">write</a>
</dd><dt><strong>warnings</strong>
</dt><dd><a href="#10734">write</a>
</dd></dl>
</dd><dt><strong>Zen</strong>
</dt><dd><a href="#15879">A few notes on</a>
</dd><dt><strong>zero</strong>
</dt><dd><dl compact="">
<dt><strong>dimension</strong>
</dt><dd><a href="#8354">index, indices</a>
</dd></dl>
</dd><dt><strong>zlib</strong>
</dt><dd><a href="#15228">The TableBase</a>

</dd></dl>

<p>
<br></p><hr>



</body></html>l>l>
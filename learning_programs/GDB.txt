=== 1 ввод-вывод ===
интерфейс консольный
у команд есть псевдонимы
при вводе пустой строки выполняется последняя команда
	ее результат может отличаться от  обычного ее вызова
# комментарий
(gdb) - приглашение
set prompt ...
Quit
ctrl+C - не работает
set screensize  <lpp>
set screensize  <lpp> <cpl>
set verbose on/off

=== 2 задание файлов ===
может отлаживать файл и дамп ядра
вызов gdb program [core]
exec-file <fn>	# при необходимости ищет в path
symbol-file <fn>
symbol-file	# очищает таблицу символов
	а также быстрые переменные
		историю значений
		точки останова
		авто-отображаемые выражения
core-file <fn>	# дамп ядра - содержимое памяти
add-file <fn> <addr>
	доп инфа о таблице символов, когда файл был динамически загружен по адресу addr
info files

=== 3 компиляция для отладки ===
-g
в gcc можно одновременно -g и -O

=== 4 запуск программы ===
run
run <args...> [> file]
set args <args...>
Info ENVironment
Info ENVironment <var>
set Environment <var> [=] <val>
unset environment <var>
delete environment <var>
pwd
cd <dir>

tty /dev/ttyb

attach <PID> # останавливает после прикрепления
detach
kill # полезен перед отладкой дампа

=== 5 остановка и продолжение ===
1) сигналы
info signal
handle signal stop/nostop print/noprint pass/nopass # устанавливает режим данного сигнала
signal ... # послать сигнал

2) точки останова
- по номеру строки
- по имени в функции (в ее начале)
- по адресу в коде
	можно ставить несколько в одну точку
	обладают:
		счетчик игнорирования
		условие
		команды после
		автоматически отключиться/удалиться после
info break [N]
# $_ и адрес команды x устанавливается на последнюю точку останова
break line
break file:line
break fun
break file:fun
break *addr
break +-offset # сдвиг по строкам в выбранном фрейме отн. текущей позиции в нем
break # устанавливает в выбранном фрейме стека так чтобы там остановилось сразу как туда вернется управление
	# в самом внутреннем фрейме - на текущей позиции
break ... if expr # условная точка останова
tbreak ... ... - отключится сразу после первого срабатывания

clear ...
delete <bnum>
enable <bnum>
disable <bnum>
enable once <bnum> # tbreak
enable delete <bnum> # не отключится а удалится после попадания
condition <bnum> expr
condition <bnum> # сделать безусловной
ignore <bnum> <count> # счетчик игнорирования 
	- сначала он уменьшается и только потом начинают проверяться условия
	condition <bnum> $foo-- <=0 # - немного похоже
CONTinue <count> = (если остановиться в точке останова, иначе <count> будет проигнорирован)
	ignore <current> count-1
	CONTinue

commands <bnum>
	[silent] # не печатать стандартное сообщение о попадании в т.о.
	...
	[step|cont]
	... # будет проигнорировано
end

3) продолжение
CONTinue

4) шаги
Step		к след. строке со входом
Step <count>
Next		к след. строке без входа
Next <count>
finish		выйти из функции и напечатать ее результат
until		работать, пока не будет достигнута следующая машинная инструкция
		или не произойдет выход из функции
		 т.е. завершить цикл, но не работает с for
until <location> # работать, пока не будет достигнута данная позиция
		или не произойдет выход из функции
StepI		к след. инструкции со входом
StepI <count>
NextI		к след. инструкции без входа
NextI <count>

=== 6 СТЕК функций ===
кадр стека:
	адрес возврата
	аргументы
	лок. переменные
после останова выбирается текущий кадр стека
можно выбрать другой

1)
main() - начальный, внешний кадр
текущий - внутренний №0
кадры имеют адреса, есть регистр указателя кадра

некоторые функции не создают фрейм
GDB предоставляет им виртуальный фрейм
	и может сломаться. если они вызовут функцию с фреймом

2)
BackTrace	выводит список кадров стека
bt <n>		n внутренних кадров
bt -<n>		n внешних кадров
where === info stack === bt

3)
frame n		выбор кадра
frame addr	если цепочка кадров была повреждена
			или несколько стеков
up n		к внешним
down n		к внутренним
после этого list будет печатать код выбранной функции

4)
Frame		инфо о выбранном фрейме
info frame	инфо о выбранном фрейме подробно
info frame addr
info args
info locals	и статические и автоматические

=== 7 исходные файлы ===
List <linespec>		5 строк назад, 5 вперед
List first,last		от и до
List first,		от 10 строк
List ,last		до, 10 строк
List +			10 строк вниз
List -			10 строк вверх
<linespec>:
	line
	file:line
	+-offset
	fun
	file:fun
	*addr
info line n	адреса начала и конца данной строки
FOrward-search <regexp>
REVerse-search <regexp>
код содержит ссылки только на имена файлов
directory dir:dir dir	# - добавляет в путь поиска исходников
directory		выводит это путь
			+ (?) удаляет текущий каталог из этого списка
info directories

=== 8 присмотр переменных ===
Print expr # на языке исходника
x addr format

1)
выражения: условные конструкции, вызов функций, приведения и строковые константы
	но не символы препроцессора
{type}addr

2)
переменная - только в текущем блоке или в файле целиком
file::var

3)
var@len - массив длины len элементов типа var, начинающийся с &var

4)


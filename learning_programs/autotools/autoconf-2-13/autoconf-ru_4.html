<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">


<TITLE>Autoconf - Существующие тесты</TITLE>
</HEAD>
<body><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

Go to the <A HREF="autoconf-ru_1.html">first</A>, <A HREF="autoconf-ru_3.html">previous</A>, <A HREF="autoconf-ru_5.html">next</A>, <A HREF="autoconf-ru_19.html">last</A> section, <A HREF="autoconf-ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC21" HREF="autoconf-ru_toc.html#TOC21">Существующие тесты</A></H1>
<P>
@anchor{Existing Tests}


<P>
Эти макросы выполняют проверку отдельных возможностей системы, в которых 
пакет нуждается или которые он может использовать.  
Если вам необходимо протестировать возможность, которую не
проверяет ни один из имеющихся макросов, то, скорее всего, вы сможете это
сделать путем вызова примитивных макросов с соответствующими аргументами
(see section <A HREF="autoconf-ru_5.html#SEC40">Написание тестов</A>).


<P>
Эти тесты сообщают пользователю, что именно они проверяют и каков
результат проверки.  Результаты кэшируются для ускорения последующих
запусков <CODE>configure</CODE>
(see section <A HREF="autoconf-ru_6.html#SEC55">Кэширование результатов</A>).


<P>
Некоторые из этих макросов устанавливают выходные
переменные. See section <A HREF="autoconf-ru_3.html#SEC11">Подстановки в файлах Makefile</A>, для того, чтобы узнать о том,
как получить значения этих переменных. Фраза "определить <VAR>name</VAR>"
ниже используется как сокращение, обозначающее "определить символ
<VAR>name</VAR> препроцессора C в значение 1".  See section <A HREF="autoconf-ru_6.html#SEC53">Определение символов препроцессора С</A>,
для того, чтобы узнать о том, как получить определения этих символов в
вашей программе.




<H2><A NAME="SEC22" HREF="autoconf-ru_toc.html#TOC22">Альтернативные программы</A></H2>
<P>
@anchor{Alternative Programs}


<P>
Эти макросы проверяют наличие или поведение определенных программ.  Они
используются для выбора между несколькими различными программами и для
решения того, что делать, когда нужная программа выбрана. Если для
проверки наличия необходимой вам программы нет отдельного макроса, и вам
не нужно выполнять проверку специальных возможностей этой программы, то
можно использовать один из стандартных макросов проверки программ.




<H3><A NAME="SEC23" HREF="autoconf-ru_toc.html#TOC23">Проверка отдельных программ</A></H3>
<P>
@anchor{Particular Programs}


<P>
Эти макросы выполняют проверку отдельных программ--- существуют ли они, 
а также, в некоторых случаях, проверку того, поддерживают ли эти программы
определенные свойства.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_DECL_YYTEXT</B>
<DD><A NAME="IDX77"></A>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
Определяет <CODE>YYTEXT_POINTER</CODE>, если <CODE>yytext</CODE> имеет тип
<SAMP>`char *'</SAMP>, а не <SAMP>`char []'</SAMP>.  Также устанавливает значение
выходной переменной <CODE>LEX_OUTPUT_ROOT</CODE> равным основе имени файла,
создаваемого лексическим генератором; обычно это значение равно
<TT>`lex.yy'</TT>, но иногда используется что-то другое. Эти результаты
различаются в зависимости от того, используется ли <CODE>lex</CODE> или
<CODE>flex</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_AWK</B>
<DD><A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
Проверяет наличие <CODE>mawk</CODE>, <CODE>gawk</CODE>, <CODE>nawk</CODE> и <CODE>awk</CODE>, в таком
порядке и устанавливает выходную переменную <CODE>AWK</CODE>, равную имени найденной 
программы. Сначала пытается найти <CODE>mawk</CODE>, который считается
самой быстрой реализацией.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_CC</B>
<DD><A NAME="IDX84"></A>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
Определяет компилятор C, который надо использовать.  Если переменная
среды <CODE>CC</CODE> не 
установлена, то проверить наличие <CODE>gcc</CODE> и использовать
<CODE>cc</CODE>, если <CODE>gcc</CODE> не найден. Устанавливает выходную переменную
<CODE>CC</CODE>, равную имени найденного компилятора.


<P>
Если используется компилятор GNU C, то значение переменной <CODE>GCC</CODE>
устанавливается в значение <SAMP>`yes'</SAMP>, в противном случае оно остается
пустым. Если выходная переменная <CODE>CFLAGS</CODE> еще не была установлена,
то установить ее равной <SAMP>`-g -O2'</SAMP> для компилятора GNU C (<SAMP>`-O2'</SAMP>
на системах, в которых GCC не понимает ключа <SAMP>`-g'</SAMP>) или равной
<SAMP>`-g'</SAMP> для других компиляторов.


<P>
Если используемый компилятор C не создает исполняемых файлов, которые
могут запускаться в той системе, где исполняется <CODE>configure</CODE>, то
переменной командного процессора <CODE>cross_compiling</CODE> присваивается
значение <SAMP>`yes'</SAMP>, в противном случае она получает значение
<SAMP>`no'</SAMP>.  Другими словами, здесь проверяется, отличается ли тип системы, для
которой производится сборка, от системы, на которой производится сборка
(тип целевой системы не относится к этому тесту). Для получения
дополнительной информации о кросс-компиляции See section <A HREF="autoconf-ru_8.html#SEC67">Ручная настройка</A>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_CC_C_O</B>
<DD><A NAME="IDX88"></A>
<A NAME="IDX89"></A>
<A NAME="IDX90"></A>
Если компилятор C не может запускаться одновременно с ключами <SAMP>`-c'</SAMP> и 
<SAMP>`-o'</SAMP>, то определяется переменная <CODE>NO_MINUS_C_MINUS_O</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_CPP</B>
<DD><A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
Значение выходной переменной <CODE>CPP</CODE> устанавливается равным имени
команды, которая запускает препроцессор C. Если <SAMP>`$CC -E'</SAMP> не
работает, то используется <TT>`/lib/cpp'</TT>. Переносимым решением является
запуск <CODE>CPP</CODE> только для обработки файлов с расширением <TT>`.c'</TT>.


<P>
Если текущим языком является C (see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), то многие
специфические тесты косвенно используют значение переменной <CODE>CPP</CODE>,
вызывая макросы <CODE>AC_TRY_CPP</CODE>, <CODE>AC_CHECK_HEADER</CODE>,
<CODE>AC_EGREP_HEADER</CODE> или <CODE>AC_EGREP_CPP</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_CXX</B>
<DD><A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
Определяет имя используемого компилятора C++.  Проверяется,
установлены ли переменные среды <CODE>CXX</CODE> или <CODE>CCC</CODE> (именно в
таком порядке); если одна из них установлена, то значение выходной переменной
<CODE>CXX</CODE> устанавливается равным значению этой переменной.  В противном
случае производится поиск компилятора C++, используя вероятные имена (<CODE>c++</CODE>,
<CODE>g++</CODE>, <CODE>gcc</CODE>, <CODE>CC</CODE>, <CODE>cxx</CODE> и <CODE>cc++</CODE>). Если ни
одна из этих проверок не прошла успешно, то в качестве последнего шанса
значение переменной <CODE>CXX</CODE> устанавливается равным <CODE>gcc</CODE>.


<P>
Если используется компилятор GNU C++, то переменная командного
процессора <CODE>GXX</CODE> получает значение <SAMP>`yes'</SAMP>, иначе ей
присваивается пустое значение.  Если выходная переменная <CODE>CXXFLAGS</CODE>
еще не была установлена, то ей присваивается значение <SAMP>`-g -O2'</SAMP> для
компилятора GNU C++ (<SAMP>`-O2'</SAMP> на системах, где G++ не распознает ключ
<SAMP>`-g'</SAMP>) или значение <SAMP>`-g'</SAMP> для других систем.


<P>
Если используемый компилятор C++ не создает исполняемых файлов, которые
могут запускаться в системе, где выполняется <CODE>configure</CODE>, то
переменной командного процессора <CODE>cross_compiling</CODE> присваивается
значение <SAMP>`yes'</SAMP>, в противном случае устанавливается значение
<SAMP>`no'</SAMP>. Другими словами, здесь проверяется, отличается ли тип системы, для
которой производится сборка, от системы, на которой производится сборка
(тип целевой системы не относится к этому тесту).  Для получения
дополнительной информации о кросс-компиляции See section <A HREF="autoconf-ru_8.html#SEC67">Ручная настройка</A>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_CXXCPP</B>
<DD><A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>


<P>
Значение выходной переменной <CODE>CXXCPP</CODE> устанавливается равным имени
команды, которая запускает препроцессор C++. Если <SAMP>`$CXX -E'</SAMP> не
работает, то используется <TT>`/lib/cpp'</TT>. Переносимым решением является
запуск <CODE>CXXCPP</CODE> только для обработки файлов с расширениями <TT>`.c'</TT>,
<TT>`.C'</TT> или <TT>`.cc'</TT>.


<P>
Если текущим языком является C++ (see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), то многие
специфические тесты косвенно используют значение переменной
<CODE>CXXCPP</CODE>, вызывая <CODE>AC_TRY_CPP</CODE>, <CODE>AC_CHECK_HEADER</CODE>,
<CODE>AC_EGREP_HEADER</CODE> или <CODE>AC_EGREP_CPP</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_F77</B>
<DD><A NAME="IDX101"></A>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<A NAME="IDX104"></A>
Определяет имя используемого компилятора Fortran 77. Если переменная
среды <CODE>F77</CODE> не установлена, то производится проверка наличия
программ <CODE>g77</CODE>, <CODE>f77</CODE> and <CODE>f2c</CODE>, в описанном порядке. Имя
найденной программы присваивается выходной переменной <CODE>F77</CODE>.


<P>
Если используется программа <CODE>g77</CODE> (компилятор GNU Fortran 77), то
макрос <CODE>AC_PROG_F77</CODE> установит переменную <CODE>G77</CODE> равной
значению <SAMP>`yes'</SAMP>, а в противном случае ей будет присвоено пустое
значение. Если выходная переменная <CODE>FFLAGS</CODE> не была установлена в
среде, то для <CODE>g77</CODE> данной переменной присваивается значение
<SAMP>`-g -02'</SAMP> (или <SAMP>`-O2'</SAMP> в тех случаях когда <CODE>g77</CODE> не
принимает ключ <SAMP>`-g'</SAMP>). Иначе, для всех остальных компиляторов
Fortran 77, переменной <CODE>FFLAGS</CODE> присваивается значение <SAMP>`-g'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_F77_C_O</B>
<DD><A NAME="IDX105"></A>
<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
Выполняет проверку того, что компилятор Fortran 77 может запускаться 
одновременно с ключами <SAMP>`-c'</SAMP> и <SAMP>`-o'</SAMP>. Если компилятор не принимает
эти ключи одновременно, то определяется переменная 
<CODE>F77_NO_MINUS_C_MINUS_O</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_GCC_TRADITIONAL</B>
<DD><A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
Добавляет строку <SAMP>`-traditional'</SAMP> к выходной переменной <CODE>CC</CODE> в
том случае, если используемый компилятор GNU C и функции <CODE>ioctl</CODE>
неправильно работают без нее.  Обычно это
случается, если в старой системе не были установлены исправленные
заголовочные файлы. Поскольку свежие версии компилятора GNU C при
установке исправляют заголовочные файлы, это становится менее
распространенной проблемой.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_INSTALL</B>
<DD><A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<A NAME="IDX116"></A>
Устанавливает выходную переменную <CODE>INSTALL</CODE>, равной полному пути к
совместимой с BSD программе <CODE>install</CODE>, если она найдена в текущей
переменной <CODE>PATH</CODE>. Иначе, переменная <CODE>INSTALL</CODE> получает
значение <SAMP>`<VAR>dir</VAR>/install-sh -c'</SAMP>, проверяя каталоги, указанные в
<CODE>AC_CONFIG_AUX_DIR</CODE> (или каталоги по умолчанию) для определения
<VAR>dir</VAR> (see section <A HREF="autoconf-ru_3.html#SEC10">Создание выходных файлов</A>). Этот макрос также устанавливает переменные
<CODE>INSTALL_PROGRAM</CODE> и <CODE>INSTALL_SCRIPT</CODE> равными значениям
<SAMP>`${INSTALL}'</SAMP>, а <CODE>INSTALL_DATA</CODE> значение <SAMP>`${INSTALL}
-m 644'</SAMP>.


<P>
Этот макрос не замечает версии <CODE>install</CODE> о которых известно, что
они не работают. Этот макрос также предпочитает использовать программу
на языке C вместо скриптов командного процессора. Вместо
<TT>`install-sh'</TT>, он также может использовать <TT>`install.sh'</TT>, но это
имя устарело, поскольку некоторые программы <CODE>make</CODE> имеют правило,
которое создает файл <TT>`install'</TT> из этого файла, если нет файла
<TT>`Makefile'</TT>.


<P>
Копия <TT>`install-sh'</TT>, которую вы можете использовать, поставляется с
Autoconf. Если вы используете <CODE>AC_PROG_INSTALL</CODE>, то вы должны
включить в свой дистрибутив либо <TT>`install-sh'</TT>, либо
<TT>`install.sh'</TT>, иначе <CODE>configure</CODE> выдаст ошибку, сообщающую о
том, что он не может найти эти файлы--- даже если система имеет
нормальную программу <CODE>install</CODE>.  Это мера безопасности, чтобы вы
случайно не забыли про этот файл, тем самым лишив пользователя
возможности установить ваш пакет в системе, в которой нет
BSD-совместимой
программы <CODE>install</CODE>.


<P>
Если вам необходимо использовать вашу собственную программу установки
(поскольку она имеет возможности, отсутствующие в стандартных программах
<CODE>install</CODE>), то нет никакой надобности в использовании макроса
<CODE>AC_PROG_INSTALL</CODE>; просто поместите путь к вашей программе в ваши
файлы <TT>`Makefile.in'</TT>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_LEX</B>
<DD><A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
Если найдена программа <CODE>flex</CODE>, то выходная переменная <CODE>LEX</CODE>
получает значение <SAMP>`flex'</SAMP>, а <CODE>LEXLIB</CODE> -- значение <SAMP>`-lfl'</SAMP>, в
случае, если библиотека располагается в стандартном месте.  Иначе
переменная <CODE>LEX</CODE> получает значение <SAMP>`lex'</SAMP>, а <CODE>LEXLIB</CODE> ---
значение <SAMP>`-ll'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_LN_S</B>
<DD><A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
Если команда <SAMP>`ln -s'</SAMP> работает в текущей файловой системе (и
операционная, и файловая системы поддерживают символьные ссылки), то
выходная переменная <CODE>LN_S</CODE> получает значение <SAMP>`ln -s'</SAMP>, в
противном случае значение равно <SAMP>`ln'</SAMP>.


<P>
Если ссылка помещается в другой, отличный от текущего, каталог, то смысл 
этой ссылки зависит от того, какая команда будет использована: <SAMP>`ln'</SAMP> или
<SAMP>`ln -s'</SAMP>.  Чтобы безбоязненно создавать ссылки, используя
<SAMP>`$(LN_S)'</SAMP>, либо определите, какая форма команды используется и
соответственно измените ее аргументы, либо всегда запускайте <CODE>ln</CODE> в
том каталоге, где будет создаваться ссылка.


<P>
Другими словами, не делайте

<PRE>
$(LN_S) foo /x/bar
</PRE>

<P>
Вместо этого выполняйте



<PRE>
(cd /x &#38;&#38; $(LN_S) foo bar)
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_RANLIB</B>
<DD><A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<A NAME="IDX126"></A>
Если команда <CODE>ranlib</CODE> найдена, то выходная переменная
<CODE>RANLIB</CODE> получает значение равное <SAMP>`ranlib'</SAMP>, в противном случае
используется значение <SAMP>`:'</SAMP> (не делать ничего).
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PROG_YACC</B>
<DD><A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
Если найдена программа <CODE>bison</CODE>, то выходная переменная <CODE>YACC</CODE>
получает значение <SAMP>`bison -y'</SAMP>. В противном случае, если найдена команда 
<CODE>byacc</CODE>, то переменная <CODE>YACC</CODE> получит значение <SAMP>`byacc'</SAMP>. В 
противном случае <CODE>YACC</CODE> устанавливается в <SAMP>`yacc'</SAMP>.
</DL>




<H3><A NAME="SEC24" HREF="autoconf-ru_toc.html#TOC24">Общие программы и проверки файлов</A></H3>
<P>
@anchor{Generic Programs}


<P>
Эти макросы используются для обнаружения программ, для которых нет
отдельных макросов. Если вам необходимо проверить не только присутствие
программы, но и ее поведение, то вам необходимо написать свой
тест для данной программы (see section <A HREF="autoconf-ru_5.html#SEC40">Написание тестов</A>).  По умолчанию эти
макросы используют переменную среды <CODE>PATH</CODE>. Если вам необходимо
проверить наличие программы, которая может находится в каталогах
пользовательской переменной <CODE>PATH</CODE>, то вы можете передать макросу
измененную переменную <CODE>PATH</CODE>, вот как в этом случае:



<PRE>
AC_PATH_PROG(INETD, inetd, /usr/libexec/inetd,
  $PATH:/usr/libexec:/usr/sbin:/usr/etc:etc)
</PRE>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_FILE</B> <I>(<VAR>file</VAR> [, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX130"></A>
<A NAME="IDX131"></A>
Выполняет проверку, существует ли в системе файл <VAR>file</VAR>. Если он
найден, то выполняются команды <VAR>action-if-found</VAR>, в противном случае
выполняется <VAR>action-if-not-found</VAR>, если задано.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_FILES</B> <I>(<VAR>files</VAR>[, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX132"></A>
<A NAME="IDX133"></A>
Выполняет макрос <CODE>AC_CHECK_FILE</CODE> для каждого из файлов в списке 
<VAR>files</VAR>. Дополнительно определяет переменную <SAMP>`HAVE<VAR>file</VAR>'</SAMP> 
для каждого из найденных файлов и устанавливает ее равной 1.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_PROG</B> <I>(<VAR>variable</VAR>, <VAR>prog-to-check-for</VAR>, <VAR>value-if-found</VAR> [, <VAR>value-if-not-found</VAR> [, <VAR>path</VAR>, [ <VAR>reject</VAR> ]]])</I>
<DD><A NAME="IDX134"></A>
<A NAME="IDX135"></A>
Проверяет, находится ли программа <VAR>prog-to-check-for</VAR> в каталогах,
перечисленных в переменной <CODE>PATH</CODE>. Если эта программа найдена, то
переменная <VAR>variable</VAR> устанавливается равным значению
<VAR>value-if-found</VAR>, в противном случае равным значению
<VAR>value-if-not-found</VAR> (если оно задано).  Никогда не использует
<VAR>reject</VAR> (имя файла с абсолютным путем), даже если такая программа была
найдена в путях поиска; в этом случае переменная <VAR>variable</VAR>
устанавливается, используя абсолютное имя найденной программы
<VAR>prog-to-check-for</VAR>, которая не является <VAR>reject</VAR>. Если
переменная <VAR>variable</VAR> уже установлена, то ничего не делается.
Вызывает макрос <CODE>AC_SUBST</CODE> для <VAR>variable</VAR>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_PROGS</B> <I>(<VAR>variable</VAR>, <VAR>progs-to-check-for</VAR> [, <VAR>value-if-not-found</VAR> [, <VAR>path</VAR>]])</I>
<DD><A NAME="IDX136"></A>
<A NAME="IDX137"></A>
Проверяет наличие в <CODE>PATH</CODE> каждой программы из списка через пробел
<VAR>progs-to-check-for</VAR>.  Если программа найдена, то
переменная <VAR>variable</VAR> устанавливается в значение, равное имени
найденной программы. В противном случае продолжается проверка наличия
следующей программы. Если ни одна из программ не найдена, то переменная
<VAR>variable</VAR> получает значение <VAR>value-if-not-found</VAR>; если
<VAR>value-if-not-found</VAR> не указано, то значение <VAR>variable</VAR> не
изменяется. Вызывает макрос <CODE>AC_SUBST</CODE> для <VAR>variable</VAR>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_TOOL</B> <I>(<VAR>variable</VAR>, <VAR>prog-to-check-for</VAR> [, <VAR>value-if-not-found</VAR> [, <VAR>path</VAR>]])</I>
<DD><A NAME="IDX138"></A>
<A NAME="IDX139"></A>
Работает подобно <CODE>AC_CHECK_PROG</CODE>, но сначала проверяет наличие 
<VAR>prog-to-check-for</VAR> с префиксом типа системы, который определяется
макросом <CODE>AC_CANONICAL_HOST</CODE>, за которым следует тире
(see section <A HREF="autoconf-ru_8.html#SEC69">Получение канонического типа системы</A>). Например, если пользователь запустит 
<SAMP>`configure --host=i386-gnu'</SAMP>, то этот вызов:

<PRE>
AC_CHECK_TOOL(RANLIB, ranlib, :)
</PRE>

<P>
установит переменную <CODE>RANLIB</CODE> в значение <TT>`i386-gnu-ranlib'</TT>,
если эта программа находится в каталогах, перечисленных в <CODE>PATH</CODE>,
или в <SAMP>`ranlib'</SAMP>, если эта программа находится в <CODE>PATH</CODE>, или в
<SAMP>`:'</SAMP>, если ни одна из программ не существует.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PATH_PROG</B> <I>(<VAR>variable</VAR>, <VAR>prog-to-check-for</VAR> [, <VAR>value-if-not-found</VAR> [, <VAR>path</VAR>]])</I>
<DD><A NAME="IDX140"></A>
<A NAME="IDX141"></A>
Работает подобно <CODE>AC_CHECK_PROG</CODE>, но устанавливает <VAR>variable</VAR>
равной полному пути к найденной программе <VAR>prog-to-check-for</VAR>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PATH_PROGS</B> <I>(<VAR>variable</VAR>, <VAR>progs-to-check-for</VAR> [, <VAR>value-if-not-found</VAR> [, <VAR>path</VAR>]])</I>
<DD><A NAME="IDX142"></A>
<A NAME="IDX143"></A>
Подобен макросу <CODE>AC_CHECK_PROGS</CODE>, но если найдена любая из программ
<VAR>progs-to-check-for</VAR>, то переменная <VAR>variable</VAR> получает значение,
равное полному пути к найденной программе.
</DL>




<H2><A NAME="SEC25" HREF="autoconf-ru_toc.html#TOC25">Файлы библиотек</A></H2>
<P>
@anchor{Libraries}


<P>
Нижеописанные макросы проверяют наличие определенных библиотек C,
C++ или Fortran 77.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_LIB</B> <I>(<VAR>library</VAR>, <VAR>function</VAR> [, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR> [, <VAR>other-libraries</VAR>]]])</I>
<DD><A NAME="IDX144"></A>
<A NAME="IDX145"></A>
В зависимости от текущего языка (see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>), макрос пытается
убедиться, что функция C, C++ или Fortran 77 с именем <VAR>function</VAR>
доступна (путем проверки, что тестовая программа компонуется с
библиотекой <VAR>library</VAR> для получения доступа к функции).
<VAR>library</VAR> является базовым именем библиотеки; например, для
<SAMP>`-lmp'</SAMP>, используйте <SAMP>`mp'</SAMP> в качестве аргумента <VAR>library</VAR>.


<P>
<VAR>action-if-found</VAR> является списком команд командного процессора,
которые запускаются в случае, если процесс компоновки прошел удачно;
<VAR>action-if-not-found</VAR> является списком команд, которые запускаются,
если процесс компоновки потерпел неудачу.  Если аргумент <VAR>action-if-found</VAR>
не указан, то действие по умолчанию добавит <SAMP>`-l<VAR>library</VAR>'</SAMP> в
переменную <CODE>LIBS</CODE> и определит переменную
<SAMP>`HAVE_LIB<VAR>library</VAR>'</SAMP> (все буквы заглавные).


<P>
Если при компоновке с <VAR>library</VAR> выдаются сообщения о ненайденных
символах, которые могут быть найдены, компонуя программы с
дополнительными библиотеками, то вы должны передать список этих
библиотек через пробелы в аргументе <VAR>other-libraries</VAR>: <SAMP>`-lXt
-lX11'</SAMP>. В противном случае этот макрос
не сможет определить, что библиотека <VAR>library</VAR> присутствует,
поскольку компоновка тестовой программы всегда будет аварийно
завершаться с сообщениями о ненайденных символах.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HAVE_LIBRARY</B> <I>(<VAR>library</VAR>, [, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR> [, <VAR>other-libraries</VAR>]]])</I>
<DD><A NAME="IDX146"></A>
<A NAME="IDX147"></A>
Этот макрос аналогичен вызову <CODE>AC_CHECK_LIB</CODE> с аргументом
<VAR>function</VAR>, равным <CODE>main</CODE>.  Вдобавок, <VAR>library</VAR>
может быть указана как <SAMP>`foo'</SAMP>, <SAMP>`-lfoo'</SAMP> или <SAMP>`libfoo.a'</SAMP>. Во
всех этих случаях компилятору передается строка <SAMP>`-lfoo'</SAMP>. Однако
<VAR>library</VAR> не может быть переменной командного процессора; ее
значение должно быть символьным именем. Этот макрос считается
устаревшим.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_SEARCH_LIBS</B> <I>(<VAR>function</VAR>, <VAR>search-libs</VAR> [, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR> [, <VAR>other-libraries</VAR>]]])</I>
<DD><A NAME="IDX148"></A>
<A NAME="IDX149"></A>
Производит поиск библиотеки, определяющей функцию <VAR>function</VAR>, если
она еще не доступна. Это подобно вызову макроса
<CODE>AC_TRY_LINK_FUNC</CODE> сначала без указания библиотек, а затем для каждой из
библиотек, перечисленных в списке <VAR>search-libs</VAR>.


<P>
Если функция найдена, то выполняются команды <VAR>action-if-found</VAR>, в
противном случае выполняются <VAR>action-if-not-found</VAR>.


<P>
Если при компоновке с <VAR>library</VAR> выдаются сообщения о ненайденных
символах, которые могут быть найдены, компонуя программы с
дополнительными библиотеками, то вы должны передать список этих
библиотек через пробел, используя аргумент <VAR>other-libraries</VAR>:
<SAMP>`-lXt -lX11'</SAMP>. В противном случае этот макрос
не сможет определить, что библиотека <VAR>library</VAR> присутствует,
поскольку компоновка тестовой программы всегда будет аварийно
завершаться с сообщениями о ненайденных символах.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_SEARCH_LIBS</B> <I>(<VAR>function</VAR>, <VAR>search-libs</VAR>[, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX150"></A>
<A NAME="IDX151"></A>
Этот макрос эквивалентен вызову <CODE>AC_TRY_LINK_FUNC</CODE> для каждой из
библиотек, перечисленных в списке <VAR>search-libs</VAR>. Макрос добавляет
<SAMP>`-l<VAR>library</VAR>'</SAMP> к содержимому переменной <CODE>LIBS</CODE> для первой
библиотеки, которая содержит <VAR>function</VAR> и выполняет
<VAR>action-if-found</VAR>. В противном случае выполняется
<VAR>action-if-not-found</VAR>.
</DL>




<H2><A NAME="SEC26" HREF="autoconf-ru_toc.html#TOC26">Библиотечные функции</A></H2>
<P>
@anchor{Library Functions}


<P>
Следующие макросы проверяют отдельные функции библиотеки C.  Если для
функции, которая вам нужна, нет отдельного макроса, и вам не нужно
проверять специальные возможности этой функции, то можно использовать
один из общих макросов проверки функций.




<H3><A NAME="SEC27" HREF="autoconf-ru_toc.html#TOC27">Проверка отдельных функций</A></H3>
<P>
@anchor{Particular Functions}


<P>
Эти макросы выполняют проверку отдельных функций: существуют ли
они и, в отдельных случаях, как они работают при задании
определенных аргументов.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_ALLOCA</B>
<DD><A NAME="IDX152"></A>
<A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
Проверяет, как получить <CODE>alloca</CODE>.  Макрос пробует получить
встроенную версию, проверяя наличие файла <TT>`alloca.h'</TT> или
предопределенных макросов препроцессора C <CODE>__GNUC__</CODE> и
<CODE>_AIX</CODE>. Если этот макрос находит <TT>`alloca.h'</TT>, то определяется
переменная <CODE>HAVE_ALLOCA_H</CODE>.


<P>
Если эти попытки оканчиваются неудачей, то макрос будет искать функцию в
стандартной библиотеке C. Если любой из этих методов закончится успешно,
то будет определена переменная <CODE>HAVE_ALLOCA</CODE>. В противном случае
выходная переменная <CODE>ALLOCA</CODE> получит значение <SAMP>`alloca.o'</SAMP> и
будет определена переменная <CODE>C_ALLOCA</CODE> (так что программы смогут
периодически вызывать <SAMP>`alloca(0)'</SAMP> для сборки мусора). Эта
переменная отделена от <CODE>LIBOBJS</CODE>, так что несколько программ смогут 
использовать одно и то же значение <CODE>ALLOCA</CODE>, без необходимости создания настоящей
библиотеки, если лишь некоторые из них используют код в
<CODE>LIBOBJS</CODE>.


<P>
Эти макросы не пытаются получить <CODE>alloca</CODE> из библиотеки System V
R3 <TT>`libPW'</TT> или из библиотеки System V R4 <TT>`libucb'</TT>, поскольку
эти библиотеки содержат некоторые несовместимые функции, что может в
дальнейшем вызвать проблемы. Некоторые версии библиотек даже не содержат
<CODE>alloca</CODE> или содержат версию с ошибками. Если вы все таки хотите
использовать <CODE>alloca</CODE> из этих библиотек, то вместо компиляции файла
<TT>`alloca.c'</TT> используйте <CODE>ar</CODE> для извлечения из них
<TT>`alloca.o'</TT>.


<P>
Для правильного объявления этой функции исходные тексты, использующие
<CODE>alloca</CODE>, должны начинаться примерно с нижеизложенного кода.  В некоторых
версиях AIX, объявление <CODE>alloca</CODE> должно предшествовать всему, за
исключением комментариев и директив препроцессора.  Директива
<CODE>#pragma</CODE> специальным образом выровнена (перед ней стоит несколько
пробелов), чтобы старые не-ANSI компиляторы C игнорировали ее, а не
выдавали ошибку.



<PRE>
/* AIX требует, чтобы это было первым кодом в файле.  */
#ifndef __GNUC__
# if HAVE_ALLOCA_H
#  include &#60;alloca.h&#62;
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* предопределено в cc +Olibcalls фирмы HP */
char *alloca ();
#   endif
#  endif
# endif
#endif
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_CLOSEDIR_VOID</B>
<DD><A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<A NAME="IDX159"></A>
Если значение, возвращаемое функцией <CODE>closedir</CODE>, не несет полезной
информации, то определяется <CODE>CLOSEDIR_VOID</CODE>. В противном случае
тот, кто вызывает эту функцию, может проверить возвращаемое значение на
наличие ошибки.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_FNMATCH</B>
<DD><A NAME="IDX160"></A>
<A NAME="IDX161"></A>
<A NAME="IDX162"></A>
Если функция <CODE>fnmatch</CODE> доступна и работает (в отличие от имеющейся
в SunOS 5.4), то определяется переменная <CODE>HAVE_FNMATCH</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_GETLOADAVG</B>
<DD><A NAME="IDX163"></A>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
Проверка того, как получить данные о загрузке системы. Если система
имеет функцию <CODE>getloadavg</CODE>, то этот макрос определяет переменную
<CODE>HAVE_GETLOADAVG</CODE>, и добавляет к <CODE>LIBS</CODE> библиотеки,
необходимые для получения этой функции.


<P>
В противном случае макрос добавляет <SAMP>`getloadavg.o'</SAMP> к выходной
переменной <CODE>LIBOBJS</CODE> и, возможно, определяет другие макросы
препроцессора C и выходные переменные:



<OL>
<LI>

Он определяет <CODE>SVR4</CODE>, <CODE>DGUX</CODE>, <CODE>UMAX</CODE> или <CODE>UMAX4_3</CODE>
на соответствующих системах.

<LI>

Если он находит <TT>`nlist.h'</TT>, то он определяет переменную
<CODE>NLIST_STRUCT</CODE>.

<LI>

Если <SAMP>`struct nlist'</SAMP> имеет поле <SAMP>`n_un'</SAMP>, то определяется
переменная <CODE>NLIST_NAME_UNION</CODE>.

<LI>

Если компиляция <TT>`getloadavg.c'</TT> определяет <CODE>LDAV_PRIVILEGED</CODE>,
то программы необходимо специальным образом устанавливать на эту систему, чтобы
<CODE>getloadavg</CODE> работала, и этот макрос определяет
<CODE>GETLOADAVG_PRIVILEGED</CODE>.

<LI>

Этот макрос устанавливает выходную переменную <CODE>NEED_SETGID</CODE>. Ее значением
является <SAMP>`true'</SAMP>, если требуется специальная установка, и <SAMP>`false'</SAMP> 
в противном случае. Если <CODE>NEED_SETGID</CODE> равен <SAMP>`true'</SAMP>, то этот 
макрос устанавливает <CODE>KMEM_GROUP</CODE> в значение, равное названию группы,
которая должна владеть установленной программой.
</OL>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_GETMNTENT</B>
<DD><A NAME="IDX176"></A>
<A NAME="IDX177"></A>
<A NAME="IDX178"></A>
Проверяет наличие <CODE>getmntent</CODE> в библиотеках <TT>`sun'</TT>, <TT>`seq'</TT>
и <TT>`gen'</TT> для Irix 4, PTX и Unixware, соответственно.  Затем, если
функция <CODE>getmntent</CODE> доступна, определяется переменная
<CODE>HAVE_GETMNTENT</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_GETPGRP</B>
<DD><A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<A NAME="IDX181"></A>
Если <CODE>getpgrp</CODE> запускается без аргументов (версия POSIX.1), то
определяется <CODE>GETPGRP_VOID</CODE>.  В противном случае функция является
BSD-версией, которая принимает в качестве аргумента идентификатор процесса.
Этот макрос не выполняет проверку наличия <CODE>getpgrp</CODE>; если вам
необходимо работать в такой ситуации, то сначала вызовите
<CODE>AC_CHECK_FUNC</CODE> для <CODE>getpgrp</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_MEMCMP</B>
<DD><A NAME="IDX182"></A>
<A NAME="IDX183"></A>
<A NAME="IDX184"></A>
Если функция <CODE>memcmp</CODE> недоступна, или не работает с восьмибитными
данными (как функция в SunOS 4.1.3), то <SAMP>`memcmp.o'</SAMP> добавляется к
выходной переменной <CODE>LIBOBJS</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_MMAP</B>
<DD><A NAME="IDX185"></A>
<A NAME="IDX186"></A>
<A NAME="IDX187"></A>
Если функция <CODE>mmap</CODE> существует и работает правильно, то
определяется переменная <CODE>HAVE_MMAP</CODE>. Проверяется только
фиксированное приватное отображение уже отображенной памяти.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_SELECT_ARGTYPES</B>
<DD><A NAME="IDX188"></A>
<A NAME="IDX189"></A>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>
Определяет правильный тип, передаваемый каждому из аргументов функции
<CODE>select</CODE>, и определяет эти типы в переменных
<CODE>SELECT_TYPE_ARG1</CODE>, <CODE>SELECT_TYPE_ARG234</CODE> и
<CODE>SELECT_TYPE_ARG5</CODE>. Значением по умолчанию для
<CODE>SELECT_TYPE_ARG1</CODE> является <SAMP>`int'</SAMP>, для
<CODE>SELECT_TYPE_ARG234</CODE> типом по умолчанию является <SAMP>`int *'</SAMP> и для
<CODE>SELECT_TYPE_ARG5</CODE> типом по умолчанию является <SAMP>`struct timeval
*'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_SETPGRP</B>
<DD><A NAME="IDX193"></A>
<A NAME="IDX194"></A>
<A NAME="IDX195"></A>
Если <CODE>setpgrp</CODE> запускается без аргументов (версия POSIX.1), то
определяется <CODE>SETPGRP_VOID</CODE>. В противном случае, функция является
BSD-версией, которая принимает в качестве аргумента идентификатор процесса.
Этот макрос не выполняет проверку наличия <CODE>setpgrp</CODE>; если вам
необходимо работать в такой ситуации, то сначала вызовите
<CODE>AC_CHECK_FUNC</CODE> для <CODE>setpgrp</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_SETVBUF_REVERSED</B>
<DD><A NAME="IDX196"></A>
<A NAME="IDX197"></A>
<A NAME="IDX198"></A>
Если <CODE>setvbuf</CODE> принимает тип буферизации как второй аргумент, а
указатель на буфер как третий аргумент, а не наоборот, то
определяется переменная <CODE>SETVBUF_REVERSED</CODE>. Это справедливо для
System V до выпуска 3.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_STRCOLL</B>
<DD><A NAME="IDX199"></A>
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
Если функция <CODE>strcoll</CODE> существует и работает правильно, то
определяется переменная <CODE>HAVE_STRCOLL</CODE>. Этот макрос выполняет
больше проверок, чем просто вызов <SAMP>`AC_CHECK_FUNCS(strcoll)'</SAMP>,
потому что некоторые системы имеют неправильные определения
<CODE>strcoll</CODE>, которыми не следует пользоваться.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_STRFTIME</B>
<DD><A NAME="IDX202"></A>
<A NAME="IDX203"></A>
<A NAME="IDX204"></A>
Проверка наличия <CODE>strftime</CODE> в библиотеке <TT>`intl'</TT>, для SCO UNIX.
Затем, если <CODE>strftime</CODE> доступна, определяется переменная
<CODE>HAVE_STRFTIME</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_UTIME_NULL</B>
<DD><A NAME="IDX205"></A>
<A NAME="IDX206"></A>
<A NAME="IDX207"></A>
Если вызов <SAMP>`utime(<VAR>file</VAR>, NULL)'</SAMP> устанавливает время
модификации файла <VAR>file</VAR> в текущее время, то определить переменную
<CODE>HAVE_UTIME_NULL</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_VFORK</B>
<DD><A NAME="IDX208"></A>
<A NAME="IDX209"></A>
<A NAME="IDX210"></A>
<A NAME="IDX211"></A>
Если найден файл <TT>`vfork.h'</TT>, то определяется переменная
<CODE>HAVE_VFORK_H</CODE>. Если работающая версия <CODE>vfork</CODE> не найдена, то
определить <CODE>vfork</CODE> как <CODE>fork</CODE>. Этот макрос проверяет несколько
известных ошибок в реализации <CODE>vfork</CODE> и если найдена одна из таких
реализаций, то считается, что система не имеет работающей версии
<CODE>vfork</CODE>. Макрос не считает, ошибкой реализации, если
при вызове потомком функции <CODE>signal</CODE> изменяются обработчики
сигналов родителя, поскольку потомки редко изменяют обработчики
сигналов родительского процесса.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_VPRINTF</B>
<DD><A NAME="IDX212"></A>
<A NAME="IDX213"></A>
<A NAME="IDX214"></A>
<A NAME="IDX215"></A>
Если найдена функция <CODE>vprintf</CODE>, то определяется переменная
<CODE>HAVE_VPRINTF</CODE>. В противном случае, если найдена функция
<CODE>_doprnt</CODE>, то определяется переменная <CODE>HAVE_DOPRNT</CODE>. (Если
функция <CODE>vprintf</CODE> доступна, то вы можете считать, что
функции <CODE>vfprintf</CODE> и <CODE>vsprintf</CODE> тоже доступны).
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_FUNC_WAIT3</B>
<DD><A NAME="IDX216"></A>
<A NAME="IDX217"></A>
<A NAME="IDX218"></A>
Если функция <CODE>wait3</CODE> найдена, и заполняет содержимое своего
третьего аргумента (<SAMP>`struct rusage *'</SAMP>), чего не делает HP-UX, то
определяется переменная <CODE>HAVE_WAIT3</CODE>.
</DL>




<H3><A NAME="SEC28" HREF="autoconf-ru_toc.html#TOC28">Проверка базовых функций</A></H3>
<P>
@anchor{Generic Functions}
 
Эти макросы используются для нахождения функций, которые не имеют
специальных макросов проверки. Если функции могут находиться в других
библиотеках, а не в стандартной библиотеке C, то сначала вызовите макрос
<CODE>AC_CHECK_LIB</CODE> для проверки наличия нужных библиотек. Если вам
нужно не только проверить, существует ли функция, но и уточнить ее
поведение, то вам придется написать свой собственный тест для этой
функции (see section <A HREF="autoconf-ru_5.html#SEC40">Написание тестов</A>).


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_FUNC</B> <I>(<VAR>function</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX219"></A>
<A NAME="IDX220"></A>
Если функция C с именем <VAR>function</VAR> доступна, то запускаются команды
командного процессора <VAR>action-if-found</VAR>, в противном случае
запускаются <VAR>action-if-not-found</VAR>. Если вы просто хотите определить
символ препроцессора, если функция существует, то вместо этого макроса попробуйте
использовать <CODE>AC_CHECK_FUNCS</CODE>. Этот макрос проверяет 
компоновку с библиотекой C, даже если был вызван макрос
<CODE>AC_LANG_CPLUSPLUS</CODE>, поскольку C++ является более
стандартизованным, чем C. (see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>, для дополнительной
информации о выборе языка, для которого проводятся проверки).
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_FUNCS</B> <I>(<VAR>function</VAR>... [, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX221"></A>
<A NAME="IDX222"></A>
<A NAME="IDX223"></A>
Для каждой из заданных <VAR>function</VAR> в списке, разделенном пробелами, в
случае если она доступна, определить переменную
<CODE>HAVE_<VAR>function</VAR></CODE> (все буквы заглавные). Если задан аргумент
<VAR>action-if-found</VAR>, то выполняется дополнительный код командного
процессора, если одна из функций найдена. Вы можете задать значение
<SAMP>`break'</SAMP> для прекращения цикла при нахождении первой функции. Если
задан аргумент <VAR>action-if-not-found</VAR>, то эти команды выполняются,
когда одна из функций не найдена.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_REPLACE_FUNCS</B> <I>(<VAR>function</VAR>...)</I>
<DD><A NAME="IDX224"></A>
<A NAME="IDX225"></A>
<A NAME="IDX226"></A>
Этот макрос подобен вызову макроса <CODE>AC_CHECK_FUNCS</CODE>, используя код
<VAR>action-if-not-found</VAR>, который добавляет <SAMP>`<VAR>function</VAR>.o'</SAMP> к
выходной переменной <CODE>LIBOBJS</CODE>. Вы можете объявить функцию, для
которой будет использована ваша замена, поместив ее прототип
между директивами <SAMP>`#ifndef HAVE_<VAR>function</VAR>'</SAMP>. Если система имеет
нужную функцию, то эта функция, вероятно, будет объявлена в заголовочном
файле, который вы должны включить в свою программу, так что вы не должны 
повторно объявлять ее, во избежание конфликта объявлений.
</DL>




<H2><A NAME="SEC29" HREF="autoconf-ru_toc.html#TOC29">Заголовочные файлы</A></H2>
<P>
@anchor{Header Files}


<P>
Следующие макросы проверяют наличие определенных заголовочных
файлов языка C.   Если для нужного вам заголовочного файла нет
специального макроса, и при этом вам не нужно проверять специальные
особенности этого файла, то можно использовать один из стандартных
макросов проверки заголовочных файлов.




<H3><A NAME="SEC30" HREF="autoconf-ru_toc.html#TOC30">Проверка отдельных заголовочных файлов</A></H3>
<P>
@anchor{Particular Headers}


<P>
Эти макросы выполняют проверку отдельных заголовочных файлов---
существуют ли они и, в некоторых случаях, объявлены ли в них какие-либо
символы.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_DECL_SYS_SIGLIST</B>
<DD><A NAME="IDX227"></A>
<A NAME="IDX228"></A>
<A NAME="IDX229"></A>
Определяет переменную <CODE>SYS_SIGLIST_DECLARED</CODE>, если переменная
<CODE>sys_siglist</CODE> объявлена в системном заголовочном файле--- либо
в <TT>`signal.h'</TT>, либо в <TT>`unistd.h'</TT>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_DIR_HEADER</B>
<DD><A NAME="IDX230"></A>
<A NAME="IDX231"></A>
<A NAME="IDX232"></A>
<A NAME="IDX233"></A>
<A NAME="IDX234"></A>
<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
Подобен вызову макросов <CODE>AC_HEADER_DIRENT</CODE> и
<CODE>AC_FUNC_CLOSEDIR_VOID</CODE>, но определяет немного другой набор макросов
препроцессора C, для указания того, какой заголовочный файл найден. Этот
макрос и имена, которые он определяет, считаются устаревшими.  Макрос
определяет следующие имена:


<DL COMPACT>

<DT><TT>`dirent.h'</TT>
<DD>
<CODE>DIRENT</CODE>
<DT><TT>`sys/ndir.h'</TT>
<DD>
<CODE>SYSNDIR</CODE>
<DT><TT>`sys/dir.h'</TT>
<DD>
<CODE>SYSDIR</CODE>
<DT><TT>`ndir.h'</TT>
<DD>
<CODE>NDIR</CODE>
</DL>

<P>
Вдобавок, если функция <CODE>closedir</CODE> не возвращает информативного
значения, то определяется переменная <CODE>VOID_CLOSEDIR</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HEADER_DIRENT</B>
<DD><A NAME="IDX237"></A>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
<A NAME="IDX240"></A>
<A NAME="IDX241"></A>
<A NAME="IDX242"></A>


<P>
Проверка следующих заголовочных файлов, и для первого файла, который
найден и определяет <SAMP>`DIR'</SAMP>, определить нижеследующие макросы
препроцессора C:


<DL COMPACT>

<DT><TT>`dirent.h'</TT>
<DD>
<CODE>HAVE_DIRENT_H</CODE>
<DT><TT>`sys/ndir.h'</TT>
<DD>
<CODE>HAVE_SYS_NDIR_H</CODE>
<DT><TT>`sys/dir.h'</TT>
<DD>
<CODE>HAVE_SYS_DIR_H</CODE>
<DT><TT>`ndir.h'</TT>
<DD>
<CODE>HAVE_NDIR_H</CODE>
</DL>

<P>
В исходном тексте объявления библиотеки каталогов должны выглядеть
примерно так:



<PRE>
#if HAVE_DIRENT_H
# include &#60;dirent.h&#62;
# define NAMLEN(dirent) strlen((dirent)-&#62;d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)-&#62;d_namlen
# if HAVE_SYS_NDIR_H
#  include &#60;sys/ndir.h&#62;
# endif
# if HAVE_SYS_DIR_H
#  include &#60;sys/dir.h&#62;
# endif
# if HAVE_NDIR_H
#  include &#60;ndir.h&#62;
# endif
#endif
</PRE>

<P>
Используя нижеследующие объявления, программа должна объявить переменные с
типом <CODE>struct dirent</CODE>, а не <CODE>struct direct</CODE>, а доступ к полю
длины имени каталога она должна получать путем передачи указателя на
<CODE>struct dirent</CODE> макросу <CODE>NAMLEN</CODE>.


<P>
Этот макрос также проверяет наличие библиотек <TT>`dir'</TT> и <TT>`x'</TT> в
SCO Xenix.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HEADER_MAJOR</B>
<DD><A NAME="IDX243"></A>
<A NAME="IDX244"></A>
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>
Если <TT>`sys/types.h'</TT> не определяет <CODE>major</CODE>, <CODE>minor</CODE> и
<CODE>makedev</CODE>, но это делается в <TT>`sys/mkdev.h'</TT>, то определяется
переменная <CODE>MAJOR_IN_MKDEV</CODE>; в противном случае, если эти функции
определяются в <TT>`sys/sysmacros.h'</TT>, то определяется переменная
<CODE>MAJOR_IN_SYSMACROS</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HEADER_STDC</B>
<DD><A NAME="IDX247"></A>
<A NAME="IDX248"></A>
<A NAME="IDX249"></A>
Определяет <CODE>STDC_HEADERS</CODE>, если система имеет заголовочные файлы
ANSI C.  Это макрос проверяет наличие <TT>`stdlib.h'</TT>, <TT>`stdarg.h'</TT>,
<TT>`string.h'</TT> и <TT>`float.h'</TT>; если система имеет эти файлы, то,
скорее всего, имеются и остальные заголовочные файлы ANSI C. Этот макрос
также проверяет, что <TT>`string.h'</TT> объявляет <CODE>memchr</CODE> (и поэтому, 
скорее всего, еще и другие функции <CODE>mem</CODE>), объявляется ли в
<TT>`stdlib.h'</TT> функция <CODE>free</CODE> (и, по видимому, <CODE>malloc</CODE> и
другие относящиеся к ним функции), и будут ли макросы из <TT>`ctype.h'</TT>
работать с символами с установленным старшим битом, как этого требует
ANSI C.


<P>
Используйте <CODE>STDC_HEADERS</CODE> вместо of <CODE>__STDC__</CODE> для
определения, имеются ли в системе совместимые с ANSI заголовочные файлы
(и, вероятно, функции библиотеки C), поскольку многие системы, имеющие GCC,
не имеют заголовочные файлы ANSI C.


<P>
На системах без заголовочных файлов ANSI C существует так много
вариантов, что, вероятно, легче объявить используемые вами функции, чем
точно определять, какой из заголовочные файлов определяет эти
функции. Некоторые системы содержат смесь функций ANSI и BSD; некоторые
из них по большей части совместимы с ANSI, но не имеют
<SAMP>`memmove'</SAMP>; некоторое определяют функции BSD как макросы в файлах
<TT>`string.h'</TT> или <TT>`strings.h'</TT>; некоторые из них имеют только
функции BSD, но с <TT>`string.h'</TT>; некоторые объявляют функции работы с
памятью в <TT>`memory.h'</TT>, некоторые в <TT>`string.h'</TT>; и т. п.
Скорее всего,
достаточно проверить наличие одной функции работы со строками и одной
функции работы с памятью; если библиотека имеет ANSI-версии этих
функций, то, скорее всего, она имеет и большинство других функций. Вы
должны поместить следующий код в <TT>`configure.in'</TT>:



<PRE>
AC_HEADER_STDC
AC_CHECK_FUNCS(strchr memcpy)
</PRE>

<P>
а затем, в вашем коде вы можете поместить следующие строки:



<PRE>
#if STDC_HEADERS
# include &#60;string.h&#62;
#else
# ifndef HAVE_STRCHR
#  define strchr index
#  define strrchr rindex
# endif
char *strchr (), *strrchr ();
# ifndef HAVE_MEMCPY
#  define memcpy(d, s, n) bcopy ((s), (d), (n))
#  define memmove(d, s, n) bcopy ((s), (d), (n))
# endif
#endif
</PRE>

<P>
Если вы используете функции, которые не имеют эквивалентов в BSD, такие
как <CODE>memchr</CODE>, <CODE>memset</CODE> <CODE>strtok</CODE> или <CODE>strspn</CODE>, то
просто макросов будет недостаточно; вы должны предоставить реализацию
каждой из функций.  Простой способ подключить ваши реализации только
если они действительно нужны (потому что функции из системной библиотеки 
могут быть вручную оптимизированы) --- это, например, поместить
функцию <CODE>memchr</CODE> в файл <TT>`memchr.c'</TT>, и использовать макрос
<SAMP>`AC_REPLACE_FUNCS(memchr)'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HEADER_SYS_WAIT</B>
<DD><A NAME="IDX250"></A>
<A NAME="IDX251"></A>
<A NAME="IDX252"></A>
Если <TT>`sys/wait.h'</TT> существует и совместим с POSIX.1, то определяется
переменная <CODE>HAVE_SYS_WAIT_H</CODE>. Несовместимость может возникнуть,
если файла <TT>`sys/wait.h'</TT> не существует, или для сохранения значения
статуса он использует старую BSD-версию <CODE>union wait</CODE> вместо
<CODE>int</CODE>. Если <TT>`sys/wait.h'</TT> не является совместимым с POSIX.1, то
вместо его включения определяется макрос POSIX.1 с его обычной
реализацией. Вот пример:



<PRE>
#include &#60;sys/types.h&#62;
#if HAVE_SYS_WAIT_H
# include &#60;sys/wait.h&#62;
#endif
#ifndef WEXITSTATUS
# define WEXITSTATUS(stat_val) ((unsigned)(stat_val) &#62;&#62; 8)
#endif
#ifndef WIFEXITED
# define WIFEXITED(stat_val) (((stat_val) &#38; 255) == 0)
#endif
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_MEMORY_H</B>
<DD><A NAME="IDX253"></A>
<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
Определяет <CODE>NEED_MEMORY_H</CODE>, если <CODE>memcpy</CODE>, <CODE>memcmp</CODE>, и
т. п. не объявлены в файле <TT>`string.h'</TT> и существует файл
<TT>`memory.h'</TT>. Этот макрос является устаревшим; вместо него
используйте вызов <CODE>AC_CHECK_HEADERS(memory.h)</CODE>. Смотрите пример для
<CODE>AC_HEADER_STDC</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_UNISTD_H</B>
<DD><A NAME="IDX256"></A>
<A NAME="IDX257"></A>
<A NAME="IDX258"></A>
Определяет переменную <CODE>HAVE_UNISTD_H</CODE>, если в системе имеется файл
<TT>`unistd.h'</TT>. Этот макрос является устаревшим; вместо него
используйте вызов <SAMP>`AC_CHECK_HEADERS(unistd.h)'</SAMP>.


<P>
Для проверки того, что система поддерживает POSIX.1, можно использовать
следующий код:



<PRE>
#if HAVE_UNISTD_H
# include &#60;sys/types.h&#62;
# include &#60;unistd.h&#62;
#endif

#ifdef _POSIX_VERSION
/* Код для систем POSIX.1 */
#endif
</PRE>

<P>
<A NAME="IDX259"></A>
<CODE>_POSIX_VERSION</CODE> определяется, когда <TT>`unistd.h'</TT> подключен в
системах, совместимых с POSIX.1.  Если файла <TT>`unistd.h'</TT> не существует,
то, скорее всего, эта система не относится к POSIX.1.  Однако некоторые
не-POSIX.1 системы имеют файл <TT>`unistd.h'</TT>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_USG</B>
<DD><A NAME="IDX260"></A>
<A NAME="IDX261"></A>
<A NAME="IDX262"></A>


<P>
Определяет <CODE>USG</CODE>, если система не имеет файла <TT>`strings.h'</TT>,
<CODE>rindex</CODE>, <CODE>bzero</CODE> и т. п. Это означает, что система имеет
<TT>`string.h'</TT>, <CODE>strrchr</CODE>, <CODE>memset</CODE> и т. п.


<P>
Символ <CODE>USG</CODE> является устаревшим.  Вместо этого макроса смотрите
пример для <CODE>AC_HEADER_STDC</CODE>.
</DL>




<H3><A NAME="SEC31" HREF="autoconf-ru_toc.html#TOC31">Базовые проверки заголовочных файлов</A></H3>
<P>
@anchor{Generic Headers}


<P>
Эти макросы используются для нахождения системных заголовочных файлов,
для которых не существует отдельного теста.  Если вам надо проверить не
только наличие заголовочного файла, но и его содержимое, то придется
написать для этого собственный тест
(see section <A HREF="autoconf-ru_5.html#SEC40">Написание тестов</A>).


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_HEADER</B> <I>(<VAR>header-file</VAR>, [<VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX263"></A>
<A NAME="IDX264"></A>
Если системный заголовочный файл <VAR>header-file</VAR> существует, то
исполняются команды командного процессора <VAR>action-if-found</VAR>, в
противном случае выполняются <VAR>action-if-not-found</VAR>. Если вы просто
хотите определить символ, если заголовочный файл доступен, то лучше
используйте макрос <CODE>AC_CHECK_HEADERS</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_HEADERS</B> <I>(<VAR>header-file</VAR>... [, <VAR>action-if-found</VAR> [, <VAR>action-if-not-found</VAR>]])</I>
<DD><A NAME="IDX265"></A>
<A NAME="IDX266"></A>
<A NAME="IDX267"></A>
Для каждого системного заголовочного файла <VAR>header-file</VAR>, заданного
в списке через пробел, в случае его существования определить
переменную <CODE>HAVE_<VAR>header-file</VAR></CODE> (все буквы заглавные). Если
задан аргумент <VAR>action-if-found</VAR>, то выполняется дополнительный код
командного процессора в случае, когда файл найден. Вы можете задать
аргумент <SAMP>`break'</SAMP> для прекращения итераций, когда найден первый
файл.  Если задан аргумент <VAR>action-if-not-found</VAR>, то он выполняется,
когда заголовочный файл не найден.
</DL>




<H2><A NAME="SEC32" HREF="autoconf-ru_toc.html#TOC32">Структуры</A></H2>
<P>
@anchor{Structures}


<P>
Следующие макросы проверяют наличие определенных структур или полей
структур.  Для проверки структур, не перечисленных в этом разделе,
используйте макрос <CODE>AC_EGREP_CPP</CODE> (see section <A HREF="autoconf-ru_5.html#SEC41">Исследование деклараций</A>)
или <CODE>AC_TRY_COMPILE</CODE> (see section <A HREF="autoconf-ru_5.html#SEC42">Проверка синтаксиса</A>).


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HEADER_STAT</B>
<DD><A NAME="IDX268"></A>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
Если макросы <CODE>S_ISDIR</CODE>, <CODE>S_ISREG</CODE> и т. п., определенные в
<TT>`sys/stat.h'</TT>, работают неправильно (возвращая неверные
положительные результаты), то определяется переменная
<CODE>STAT_MACROS_BROKEN</CODE>. Это происходит на системах Tektronix UTekV,
Amdahl UTS и Motorola System V/88.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_HEADER_TIME</B>
<DD><A NAME="IDX271"></A>
<A NAME="IDX272"></A>
<A NAME="IDX273"></A>
Если программа может подключать как <TT>`time.h'</TT>, так и <TT>`sys/time.h'</TT>, то
определяется переменная <CODE>TIME_WITH_SYS_TIME</CODE>. В некоторых старых
системах <TT>`sys/time.h'</TT> подключает <TT>`time.h'</TT>, но <TT>`time.h'</TT>
не защищен от многократного подключения, так что программы не должны
явно подключать оба файла. Этот макрос полезен для программ, которые,
например, используют структуры <CODE>struct timeval</CODE> или <CODE>struct
timezone</CODE>, вместе с <CODE>struct tm</CODE>.  Этот макрос лучше всего
использовать
вместе с <CODE>HAVE_SYS_TIME_H</CODE>, который может быть проверен с помощью
<CODE>AC_CHECK_HEADERS(sys/time.h)</CODE>.



<PRE>
#if TIME_WITH_SYS_TIME
# include &#60;sys/time.h&#62;
# include &#60;time.h&#62;
#else
# if HAVE_SYS_TIME_H
#  include &#60;sys/time.h&#62;
# else
#  include &#60;time.h&#62;
# endif
#endif
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_STRUCT_ST_BLKSIZE</B>
<DD><A NAME="IDX274"></A>
<A NAME="IDX275"></A>
<A NAME="IDX276"></A>
Если <CODE>struct stat</CODE> содержит поле <CODE>st_blksize</CODE>, то определяется
переменная <CODE>HAVE_ST_BLKSIZE</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_STRUCT_ST_BLOCKS</B>
<DD><A NAME="IDX277"></A>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>
Если <CODE>struct stat</CODE> содержит поле <CODE>st_blocks</CODE>, то определяется 
переменная <CODE>HAVE_ST_BLOCKS</CODE>. В противном случае, <SAMP>`fileblocks.o'</SAMP> 
добавляется к выходной переменной <CODE>LIBOBJS</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_STRUCT_ST_RDEV</B>
<DD><A NAME="IDX281"></A>
<A NAME="IDX282"></A>
<A NAME="IDX283"></A>
Если <CODE>struct stat</CODE> содержит поле <CODE>st_rdev</CODE>, то определяется
переменная <CODE>HAVE_ST_RDEV</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_STRUCT_TM</B>
<DD><A NAME="IDX284"></A>
<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
Если <TT>`time.h'</TT> не определяет <CODE>struct tm</CODE>, то определяется
символ <CODE>TM_IN_SYS_TIME</CODE>, что означает, что <TT>`sys/time.h'</TT>
следовало бы определить <CODE>struct tm</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_STRUCT_TIMEZONE</B>
<DD><A NAME="IDX287"></A>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
<A NAME="IDX290"></A>
Определяет, как получить текущую временную зону.  Если <CODE>struct tm</CODE>
имеет поле <CODE>tm_zone</CODE>, то определяется переменная
<CODE>HAVE_TM_ZONE</CODE>. В противном случае, если найден внешний массив
<CODE>tzname</CODE>, то определяется переменная <CODE>HAVE_TZNAME</CODE>.
</DL>




<H2><A NAME="SEC33" HREF="autoconf-ru_toc.html#TOC33">Объявления типов</A></H2>
<P>
@anchor{Typedefs}


<P>
Следующие макросы проверяют определения типов (typedef) языка C.  Если для нужного
вам определения типа нет специального макроса, и вам не нужно выполнять
проверку специальных возможностей, то можно использовать общие
макросы проверки объявлений типов.




<H3><A NAME="SEC34" HREF="autoconf-ru_toc.html#TOC34">Проверка отдельных объявлений типов</A></H3>
<P>
@anchor{Particular Typedefs}


<P>
Эти макросы проверяют конкретные объявления типов C в файлах
<TT>`sys/types.h'</TT> и <TT>`stdlib.h'</TT> (если он существует).


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_GETGROUPS</B>
<DD><A NAME="IDX291"></A>
<A NAME="IDX292"></A>
<A NAME="IDX293"></A>
Определяет <CODE>GETGROUPS_T</CODE> равным <CODE>gid_t</CODE> или <CODE>int</CODE>, в
зависимости от того, что именно является базовым типом массива-аргумента 
функции <CODE>getgroups</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_MODE_T</B>
<DD><A NAME="IDX294"></A>
<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
Если <CODE>mode_t</CODE> не определен, то определить тип <CODE>mode_t</CODE> равным
<CODE>int</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_OFF_T</B>
<DD><A NAME="IDX297"></A>
<A NAME="IDX298"></A>
<A NAME="IDX299"></A>
Если <CODE>off_t</CODE> не определен, то определить <CODE>off_t</CODE> равным
<CODE>long</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_PID_T</B>
<DD><A NAME="IDX300"></A>
<A NAME="IDX301"></A>
<A NAME="IDX302"></A>
Если <CODE>pid_t</CODE> не определен, то определить <CODE>pid_t</CODE> равным
<CODE>int</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_SIGNAL</B>
<DD><A NAME="IDX303"></A>
<A NAME="IDX304"></A>
<A NAME="IDX305"></A>
Если <TT>`signal.h'</TT> определяет <CODE>signal</CODE> как возвращающий указатель
на функцию, возвращающую <CODE>void</CODE>, то переменная <CODE>RETSIGTYPE</CODE>
становится равной <CODE>void</CODE>; в противном случае она определяется с
типом <CODE>int</CODE>.


<P>
Определить обработчики сигналов как возвращающие тип <CODE>RETSIGTYPE</CODE>:



<PRE>
RETSIGTYPE
hup_handler ()
{
...
}
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_SIZE_T</B>
<DD><A NAME="IDX306"></A>
<A NAME="IDX307"></A>
<A NAME="IDX308"></A>
Если <CODE>size_t</CODE> не определен, то определить <CODE>size_t</CODE> как
<CODE>unsigned</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_TYPE_UID_T</B>
<DD><A NAME="IDX309"></A>
<A NAME="IDX310"></A>
<A NAME="IDX311"></A>
<A NAME="IDX312"></A>
Если <CODE>uid_t</CODE> не определен, то определить <CODE>uid_t</CODE> равным
<CODE>int</CODE> и <CODE>gid_t</CODE> равным <CODE>int</CODE>.
</DL>




<H3><A NAME="SEC35" HREF="autoconf-ru_toc.html#TOC35">Базовые проверки объявлений типов</A></H3>
<P>
@anchor{Generic Typedefs}


<P>
Эти макросы используются для проверки определений типов (typedef), которые не были
описаны в разделе конкретных макросов проверок.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_TYPE</B> <I>(<VAR>type</VAR>, <VAR>default</VAR>)</I>
<DD><A NAME="IDX313"></A>
<A NAME="IDX314"></A>
Если тип <VAR>type</VAR> не определен в <TT>`sys/types.h'</TT>, или в
<TT>`stdlib.h'</TT>, или в <TT>`stddef.h'</TT> (если они существуют), то
определить этот тип равным встроенному типу C (или C++) <VAR>default</VAR>;
например, <SAMP>`short'</SAMP> или <SAMP>`unsigned'</SAMP>.
</DL>




<H2><A NAME="SEC36" HREF="autoconf-ru_toc.html#TOC36">Характеристики компилятора C</A></H2>
<P>
@anchor{C Compiler Characteristics}


<P>
Следующие макросы выполняют проверку свойств компилятора C или
архитектуры машины. Для проверки характеристик, не перечисленных в этом
разделе, используйте макросы <CODE>AC_TRY_COMPILE</CODE> (see section <A HREF="autoconf-ru_5.html#SEC42">Проверка синтаксиса</A>) или <CODE>AC_TRY_RUN</CODE> (see section <A HREF="autoconf-ru_5.html#SEC44">Проверка поведения во время выполнения</A>).


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_BIGENDIAN</B>
<DD><A NAME="IDX315"></A>
<A NAME="IDX316"></A>
<A NAME="IDX317"></A>
Если слова хранятся в порядке, когда самый значимый байт хранится первым
(подобно процессорам Motorola и SPARC, но не Intel и VAX), то
определяется переменная <CODE>WORDS_BIGENDIAN</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_CONST</B>
<DD><A NAME="IDX318"></A>
<A NAME="IDX319"></A>
<A NAME="IDX320"></A>
Если компилятор C не поддерживает полностью ключевое слово <CODE>const</CODE>,
то макросу <CODE>const</CODE> присваивается пустое значение. Некоторые
компиляторы C не определяют константу <CODE>__STDC__</CODE>, но поддерживают
<CODE>const</CODE>; некоторые компиляторы, определяющие
<CODE>__STDC__</CODE>, не полностью поддерживают <CODE>const</CODE>.  Программы могут
просто использовать <CODE>const</CODE>, как будто любой компилятор C
поддерживает его; для тех компиляторов, которые не имеют такой поддержки,
<TT>`Makefile'</TT> или заголовочный файл настройки определят это слово как
имеющее пустое значение.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_INLINE</B>
<DD><A NAME="IDX321"></A>
<A NAME="IDX322"></A>
<A NAME="IDX323"></A>
Если компилятор C поддерживает <CODE>inline</CODE>, то ничего не
делается. В противном случае, <CODE>inline</CODE> определяется равным
<CODE>__inline__</CODE> или <CODE>__inline</CODE>, если компилятор поддерживает один
из этих вариантов, иначе <CODE>inline</CODE> определяется равным пустому
значению.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_CHAR_UNSIGNED</B>
<DD><A NAME="IDX324"></A>
<A NAME="IDX325"></A>
<A NAME="IDX326"></A>
Если тип C <CODE>char</CODE> является беззнаковым, то определяется переменная
<CODE>__CHAR_UNSIGNED__</CODE> (если компилятор C еще не определил ее).
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_LONG_DOUBLE</B>
<DD><A NAME="IDX327"></A>
<A NAME="IDX328"></A>
<A NAME="IDX329"></A>
Если компилятор C поддерживает тип <CODE>long double</CODE>, то определяется
переменная <CODE>HAVE_LONG_DOUBLE</CODE>. Некоторые компиляторы C, которые не
определяют <CODE>__STDC__</CODE>, поддерживают <CODE>long double</CODE>; а
некоторые компиляторы, определяющие <CODE>__STDC__</CODE>, не поддерживают тип
<CODE>long double</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_C_STRINGIZE</B>
<DD><A NAME="IDX330"></A>
<A NAME="IDX331"></A>
<A NAME="IDX332"></A>
Если препроцессор C поддерживает строковый (stringizing) оператор, то определяется
переменная <CODE>HAVE_STRINGIZE</CODE>. Строковым (stringinzing)оператором является <SAMP>`#'</SAMP>
и он используется в макросах, например:



<PRE>
#define x(y) #y
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_CHECK_SIZEOF</B> <I>(<VAR>type</VAR> [, <VAR>cross-size</VAR>])</I>
<DD><A NAME="IDX333"></A>
<A NAME="IDX334"></A>
Определить <CODE>SIZEOF_<VAR>uctype</VAR></CODE> равным числу байтов во встроенном
типе C (или C++) <VAR>type</VAR>, например, <SAMP>`int'</SAMP> или <SAMP>`char *'</SAMP>.
Если <SAMP>`type'</SAMP> неизвестен компилятору, то переменная получает
значение 0.
<VAR>uctype</VAR> является <VAR>type</VAR>, со строчными буквами,
преобразованными в прописные, пробелы преобразуются в знаки
подчеркивания, и знаки звездочка (<CODE>*</CODE>) заменяются на <SAMP>`P'</SAMP>. Если
производится кросс-компиляция, то используется значение <VAR>cross-size</VAR>
(если оно задано), в противном случае <CODE>configure</CODE> прекращает работу
с выдачей сообщения об ошибке.


<P>
Например, вызов

<PRE>
AC_CHECK_SIZEOF(int *)
</PRE>

<P>
определяет <CODE>SIZEOF_INT_P</CODE> равным 8 на системах DEC Alpha AXP.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_INT_16_BITS</B>
<DD><A NAME="IDX335"></A>
<A NAME="IDX336"></A>
<A NAME="IDX337"></A>
Если тип <CODE>int</CODE> имеет размер 16 бит, то определяется переменная
<CODE>INT_16_BITS</CODE>. Этот макрос является устаревшим; вместо него лучше
использовать общий макрос <SAMP>`AC_CHECK_SIZEOF(int)'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_LONG_64_BITS</B>
<DD><A NAME="IDX338"></A>
<A NAME="IDX339"></A>
<A NAME="IDX340"></A>
Если тип <CODE>long int</CODE> имеет размер 64 бита, то определяется
переменная <CODE>LONG_64_BITS</CODE>. Этот макрос является устаревшим; вместо
него лучше использовать вызов <SAMP>`AC_CHECK_SIZEOF(long)'</SAMP>.
</DL>




<H2><A NAME="SEC37" HREF="autoconf-ru_toc.html#TOC37">Характеристики компилятора Fortran 77</A></H2>
<P>
@anchor{Fortran 77 Compiler Characteristics}


<P>
Следующие макросы используются для проверки характеристик компилятора
Fortran 77.  Для проверки характеристик, не перечисленных в этом разделе,
используйте макросы <CODE>AC_TRY_COMPILE</CODE> (see section <A HREF="autoconf-ru_5.html#SEC42">Проверка синтаксиса</A>)
или <CODE>AC_TRY_RUN</CODE> (see section <A HREF="autoconf-ru_5.html#SEC44">Проверка поведения во время выполнения</A>), убедившись, что перед
этим вы установили Fortran 77 текущим языком.
<CODE>AC_LANG_FORTRAN77</CODE> (see section <A HREF="autoconf-ru_5.html#SEC51">Выбор языка</A>).


<P>
<DL>
<DT><U>Macro:</U> <B>AC_F77_LIBRARY_LDFLAGS</B>
<DD><A NAME="IDX341"></A>
<A NAME="IDX342"></A>
<A NAME="IDX343"></A>
Определяет ключи командной строки компоновщика (например, <SAMP>`-L'</SAMP> и
<SAMP>`-l'</SAMP>) для <EM>внутренних библиотек Fortran 77 и библиотек времени
исполнения</EM>, которые требуются для правильной компоновки программ на
Fortran 77 или разделяемых библиотек.  Выходная переменная <CODE>FLIBS</CODE>
устанавливается равной этим флагам.


<P>
Этот макрос предназначен для использования в ситуациях, когда необходимо
смешать исходный код, например на C++ и Fortran 77, в одну программу или
разделяемую библиотеку (see section `Смешивание кода Fortran 77 с кодом на C и C++' in <CITE>GNU Automake</CITE>).


<P>
Например, если объектные файлы от компиляторов C++ и Fortran 77 должны
быть скомпонованы вместе, то для компоновки должен использоваться
компилятор/компоновщик C++, поскольку специфические для C++ вещи,
такие как вызовы
глобальных конструкторов, подстановке шаблонов, разрешении обработки
исключений, и т. п., нуждаются в специальных действиях во время компоновки.


<P>
Однако в этих случаях должны быть подключены и внутренние библиотеки
Fortran 77, а также библиотеки времени исполнения, а
компилятор/компоновщик C++ просто не знает, какие библиотеки Fortran 77
должны быть добавлены. Для определения библиотек Fortran 77 и был создан
макрос <CODE>AC_F77_LIBRARY_LDFLAGS</CODE>.
</DL>




<H2><A NAME="SEC38" HREF="autoconf-ru_toc.html#TOC38">Системные сервисы</A></H2>
<P>
@anchor{System Services}


<P>
Следующие макросы проверяют наличие сервисов операционной системы или ее
возможности.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_CYGWIN</B>
<DD><A NAME="IDX344"></A>
<A NAME="IDX345"></A>
Проверяет наличие среды Cygwin. Если она присутствует, то переменная
среды <CODE>CYGWIN</CODE> получает значение <SAMP>`yes'</SAMP>.  В противном случае 
переменная <CODE>CYGWIN</CODE> получает пустое значение.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_EXEEXT</B>
<DD><A NAME="IDX346"></A>
<A NAME="IDX347"></A>
<A NAME="IDX348"></A>
Определяет переменную подстановки <CODE>EXEEXT</CODE>, основанную на
расширении файла, выдаваемого компилятором, после исключения файлов с
расширениями .c, .o и .obj.  Для Unix обычным значением является пустая
строка, а для Win32 --- <SAMP>`.exe'</SAMP> и <SAMP>`.EXE'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_OBJEXT</B>
<DD><A NAME="IDX349"></A>
<A NAME="IDX350"></A>
<A NAME="IDX351"></A>
Определяет переменную подстановки <CODE>OBJEXT</CODE>, основанную на выводе
компилятора, после исключения файлов с расширением .c. Обычно имеет
значение <SAMP>`.o'</SAMP> в Unix, и <SAMP>`.obj'</SAMP> на системах Win32.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_MINGW32</B>
<DD><A NAME="IDX352"></A>
<A NAME="IDX353"></A>
Проверяет наличие среды компилятора MingW32. Если она присутствует, то
переменная <CODE>MINGW32</CODE> получает значение <SAMP>`yes'</SAMP>.  В противном
случае переменная <CODE>MINGW32</CODE> получает пустое значение.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PATH_X</B>
<DD><A NAME="IDX354"></A>
<A NAME="IDX355"></A>
Этот макрос пробует определить расположение заголовочных файлов и
библиотек X Window System. Если пользователь задал ключи командной
строки <SAMP>`--x-includes=<VAR>dir</VAR>'</SAMP> и <SAMP>`--x-libraries=<VAR>dir</VAR>'</SAMP>,
то используются заданные каталоги. Если один из ключей или оба не
заданы, то пропущенные значения получают запуском <CODE>xmkmf</CODE> для
простого <TT>`Imakefile'</TT> и разбора полученного файла
<TT>`Makefile'</TT>. Если произошел сбой (например, если <CODE>xmkmf</CODE>
отсутствует), то производится поиск в нескольких каталогах, где часто
располагаются эти файлы. Если один из этих способов был удачен, то
переменные командного процессора <CODE>x_includes</CODE> и <CODE>x_libraries</CODE>
устанавливаются равными найденным каталогам (в том случае, если эти
каталоги не входят в пути, в которых компилятор по умолчанию производит
поиск).


<P>
Если оба этих метода дают сбой, или пользователь задал ключ командной
строки <SAMP>`--without-x'</SAMP>, то переменная командного процессора <CODE>no_x</CODE> 
получает значение <SAMP>`yes'</SAMP>; в противном случае она получает пустое
значение.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_PATH_XTRA</B>
<DD><A NAME="IDX356"></A>
<A NAME="IDX357"></A>
<A NAME="IDX358"></A>
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>
Расширенная версия <CODE>AC_PATH_X</CODE>. Она добавляет к выходной переменной
<CODE>X_CFLAGS</CODE> ключи компилятора C, которые необходимы X, а также флаги
X для компоновщика к переменной <CODE>X_LIBS</CODE>. Если X не доступна, то
добавляется <SAMP>`-DX_DISPLAY_MISSING'</SAMP> к <CODE>X_CFLAGS</CODE>.


<P>
Этот макрос также выполняет проверки специальных библиотек, в которых
нуждаются некоторые системы для того, чтобы скомпилировать программу
для X.
Он добавляет все, что необходимо для таких систем, к выходной
переменной <CODE>X_EXTRA_LIBS</CODE>. Он также проверяет наличие специальных
библиотек X11R6, которые необходимо скомпоновать до использования
<SAMP>`-lX11'</SAMP>, и добавляет найденные библиотеки к выходной переменной
<CODE>X_PRE_LIBS</CODE>.


</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>AC_SYS_INTERPRETER</B>
<DD><A NAME="IDX362"></A>
<A NAME="IDX363"></A>
Проверяет, поддерживает ли система начало скриптов со строки в форме
<SAMP>`#! /bin/csh'</SAMP> для выбора интерпретатора, который будет
использоваться для данного скрипта. После запуска этого макроса код
командного процессора в
<CODE>configure.in</CODE> может проверить переменную <CODE>interpval</CODE>; она будет 
равна <SAMP>`yes'</SAMP>, если система поддерживает <SAMP>`#!'</SAMP>, и <SAMP>`no'</SAMP> в
противном случае.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_SYS_LONG_FILE_NAMES</B>
<DD><A NAME="IDX364"></A>
<A NAME="IDX365"></A>
<A NAME="IDX366"></A>
Если система поддерживает имена файлов длиннее 14 символов, то будет
определена переменная <CODE>HAVE_LONG_FILE_NAMES</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_SYS_RESTARTABLE_SYSCALLS</B>
<DD><A NAME="IDX367"></A>
<A NAME="IDX368"></A>
<A NAME="IDX369"></A>
Если система автоматически перезапускает системный вызов, который был
прерван сигналом, то определяется переменная
<CODE>HAVE_RESTARTABLE_SYSCALLS</CODE>.
</DL>




<H2><A NAME="SEC39" HREF="autoconf-ru_toc.html#TOC39">Варианты UNIX</A></H2>
<P>
@anchor{UNIX Variants}


<P>
Следующие макросы проверяют наличие конкретных операционных систем, что
может потребовать специальной обработки в программах из-за
исключительных странностей в их заголовочных файлах или библиотеках. Эти
макросы являются бородавками (наростами); они будут заменены на более
систематизированные, разбитые на предоставляемые ими функции или
устанавливаемые ими параметры среды.


<P>
<DL>
<DT><U>Macro:</U> <B>AC_AIX</B>
<DD><A NAME="IDX370"></A>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>
На AIX определяет переменную <CODE>_ALL_SOURCE</CODE>.  Позволяет использовать
некоторые функции BSD. Должен вызываться до макросов,
запускающих компилятор C.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_DYNIX_SEQ</B>
<DD><A NAME="IDX373"></A>
<A NAME="IDX374"></A>
На Dynix/PTX (Sequent UNIX) добавляет <SAMP>`-lseq'</SAMP> к выходной
переменной <CODE>LIBS</CODE>. Этот макрос является устаревшим; используйте
вместо него <CODE>AC_FUNC_GETMNTENT</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_IRIX_SUN</B>
<DD><A NAME="IDX375"></A>
<A NAME="IDX376"></A>
На IRIX (Silicon Graphics UNIX) добавляет <SAMP>`-lsun'</SAMP> к выходной
переменной <CODE>LIBS</CODE>. Этот макрос является устаревшим. Если вы
используете его для проверки наличия <CODE>getmntent</CODE>, то вместо него
используйте макрос <CODE>AC_FUNC_GETMNTENT</CODE>. Если вы использовали его
для NIS-версий функций работы с паролями и группами, то вместо него
используйте <SAMP>`AC_CHECK_LIB(sun, getpwnam)'</SAMP>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_ISC_POSIX</B>
<DD><A NAME="IDX377"></A>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>
<A NAME="IDX380"></A>
На POSIX-версии ISC UNIX определяет переменную <CODE>_POSIX_SOURCE</CODE> и
добавляет <SAMP>`-posix'</SAMP> (для компилятора GNU C) или <SAMP>`-Xp'</SAMP> (для
других компиляторов C) к выходной переменной <CODE>CC</CODE>. Это позволяет
использовать возможности POSIX. Макрос должен быть вызван после вызова
<CODE>AC_PROG_CC</CODE> и до вызова любых других макросов, которые запускают
компилятор C.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_MINIX</B>
<DD><A NAME="IDX381"></A>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>
На Minix определяет переменные <CODE>_MINIX</CODE> и <CODE>_POSIX_SOURCE</CODE> и
определяет <CODE>_POSIX_1_SOURCE</CODE> со значением 2. Это позволяет
использовать возможности POSIX. Должен вызываться до вызова других
макросов, запускающих компилятор C.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_SCO_INTL</B>
<DD><A NAME="IDX386"></A>
<A NAME="IDX387"></A>
<A NAME="IDX388"></A>
На SCO UNIX добавляет <SAMP>`-lintl'</SAMP> к выходной переменной <CODE>LIBS</CODE>.
Этот макрос является устаревшим; вместо него используйте макрос
<CODE>AC_FUNC_STRFTIME</CODE>.
</DL>


<P>
<DL>
<DT><U>Macro:</U> <B>AC_XENIX_DIR</B>
<DD><A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>
На Xenix добавляет <SAMP>`-lx'</SAMP> к выходной переменной <CODE>LIBS</CODE>. Также,
если используется <TT>`dirent.h'</TT>, то к переменной <CODE>LIBS</CODE> добавляется
<SAMP>`-ldir'</SAMP>. Этот макрос является устаревшим; вместо него используйте
<CODE>AC_HEADER_DIRENT</CODE>.
</DL>


<P><HR><P>
Go to the <A HREF="autoconf-ru_1.html">first</A>, <A HREF="autoconf-ru_3.html">previous</A>, <A HREF="autoconf-ru_5.html">next</A>, <A HREF="autoconf-ru_19.html">last</A> section, <A HREF="autoconf-ru_toc.html">table of contents</A>.
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</BODY>
</HTML>

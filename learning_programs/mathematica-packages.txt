Код, который вы хотите часто переиспользовать как "библиотеку" для Mathematica, Лучше создать в пакете. 
Учебник для общих методов для установки пакетов является он-лайн документацией по ссылке: tutorial/SettingUpMathematicaPackages.

В понимании пакетов хорошо также быть знакомым с Контекстами в Mathematica. 
Учебник о контекстах можно найти в этой он-лайн документации по ссылке: tutorial/Contexts.

tutorial/ModularityAndTheNamingOfThingsOverview
=== Модульность и именование ===
Модули и локальные переменные
локальные константы
как работают модули
переменные в чистых функциях и правилах.
Немые переменные в математике
Блоки и локальные значения
Блоки в сравнении с модулями
Контексты
контексты и пакеты
пакеты языка wolfram
Установка пакетов языка wolfram
файлы для пакетов
автоматическая загрузка пакетов
Управление символами и контекстами по имени
перехват создания новых исмволов
----------------------------------------------
=== Контексты ===
Вседа является хорошей идеей давать переменным и функциям имена, которые настолько ясны, насколько это возможно.
Иногда тем не менее, такие имена могут становиться слишком длинными. 

В языке Wolfram, вы можете использовать нотацию "контекстов" для организации имен символов. 
Контексты в частности выжны в пакетах языка Wolfram, которые вводят символы, чьи имена обязаны не конфликтовать с любыми другими символами. 
Если вы пишите пакет языка Wolfram, или создаете сложное использование пакетов, что написали другие, то вам требуется знать о контекстах. 

Базовая идея состоит в том, что полное имя люого символа разбивается на части: контекст и короткое имя. 
Полное имя записывается как context`short, где ` - обратная кавычка или символ тупого ударения (десятичный код ASCII 96), называтеся "отметка контекста" в языке Wolfram. 

...примеры ...

Типично иметь все символы, которые относятся к отдельному топику, в отдельном контексте. 
Следовательно, на пример, символы, которые обозначают физические величины, могут иметь контекст PhysicalUnits`. 
Такие символы могут иметь полные имена такие как PhysicalUnits`Joule или PhysicalUnits`Mole. 

Также вы свегда можете ссылаться на символ по его полному имени, часто соглашаются использовать короткие имена. 

В любой данной точке сессии языка Wolfram, всегда имеется текущий контекст $Context. 
Вы можете ссылаться на символы, которые находятся в этом контексте, просто задавая их короткие имена, 
если символ не затенен символом с таким же коротким именем в $ContextPath. 
Если символ с заданным коротким имененм существует в пути контекста, он будет использоваться вместо символа в текущем контексте.

...примеры ...

Контексты в языке Wolfram работают примерно так же как директории в большинстве файловых систем.
Вы всегда можете задать определенный файл указав его полное имя, включая его директорию.
Но в любой заданной точке существует текущая директория, аналогичная текущему контексту языка Wolfram.
Файлы, которые находятся в этой директории могут быть заданы при помощи их коротких имен.

=== контексты и пакеты ===
Типичный пакет, написанный на языке wolfram вводит несколько новых символов, предназначенных для использования за пределами пакета.
Эти символы могут соответствовать например новым функциям или новым объектам, определенным в пакете.

Есть общая конвенция, что все новые символы, введенные в новом пакете, кладутся в контекст, чье имя соответствует имени пакета.
Когда вы считываете пакет, его контекст добавляется в начало вашего пути поиска контекстов $ContextPath.

...примеры ...

Полные имена символов, определенных в пакетах часто достаточно длинны.
Тем не менее в большинстве случаев вам необходимо использовать только их короткие имена.

Если при чтении пакета его символы затеняют уже имеющиеся, то происходит warning

поиск происходит начала в пути контекстов, а потом в текущем контексте

=== пакеты языка wolfram ===
как загружаются пакеты см. tutorial/ExternalPrograms
guide/StandardExtraPackages

=== Установка пакетов языка wolfram ===
Package`
Package`Private`

BeginPackage["Package`"]
f::usage="text", ...
Begin["`Private`"]
f[args]=value, ...
End[]
EndPackage[]

Begin["c`"]; Print[Context[x]]; End[] - здесь Begin[] не сработает, т.к. это выр-е сначала прочитается (всё), а потом будет выполняться

=== файлы для пакетов ===
порядок поиска файла, заданного контекстом:
name.mx
name.mx/$SystemID/name.mx
name.m
name/init.m
dir/...  


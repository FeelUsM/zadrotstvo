p - POSIX https://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html
параллельность ---------------------------------------------------
  -j [N], --jobs[=N]          Запускать одновременно до N заданий; если N не указано, число заданий неограничено.
  -l [N], --load-average[=N], --max-load[=N]         Не запускать несколько заданий, если загрузка больше N.
  -O[ТИП], --output-sync[=ТИП] Синхронизировать вывод параллельных заданий с типом ТИП.
выбор make-файла---------------------------------------------------
  -C КАТАЛОГ, --directory=КАТАЛОГ Перейти в КАТАЛОГ перед выполнением действий.
p -f ФАЙЛ, --file=ФАЙЛ, --makefile=ФАЙЛ Использовать ФАЙЛ в качестве makefile.
  -E СТРОКА, --eval=СТРОКА    Вычислить СТРОКУ как предложение makefile.
переменные ---------------------------------------------------
  -I КАТАЛОГ, --include-dir=КАТАЛОГ Искать включаемые make-файлы в КАТАЛОГЕ.
p -e, --environment-overrides Переменные окружения заменяют значения makefile.
  --warn-undefined-variables  Выдавать предупреждение при ссылке на неопределённую переменную.
  -R, --no-builtin-variables   Выключить установку встроенных значений переменных.
цели и правила ---------------------------------------------------
p -r, --no-builtin-rules      Не использовать встроенные неявные правила.
  -W ФАЙЛ, --what-if=ФАЙЛ, --new-file=ФАЙЛ, --assume-new=ФАЙЛ Считать ФАЙЛ всегда новым.
  -o ФАЙЛ, --old-file=ФАЙЛ, --assume-old=ФАЙЛ Считать ФАЙЛ очень старым и не переделывать его.
  -B, --always-make           Без условий отрабатывать все цели.
p -t, --touch                 Установить время доступа целей в текущее, а не пересобирать их.
  -L, --check-symlink-times   Использовать последнее mtime при выборе между символическими ссылками и целью.
p -q, --question              Не применять способ; код завершения показывает, всё ли уже сделано.
обработка ошибок ---------------------------------------------------
p -k, --keep-going            Продолжать работу, даже если некоторые цели не могут быть достигнуты.
p -S, --no-keep-going, --stop Отменить ключ -k.
p -i, --ignore-errors         Игнорировать ошибки способов.
сообщения ---------------------------------------------------
n -n, --just-print, --dry-run, --recon Не применять способ на самом деле; просто напечатать его.

p -s, --silent, --quiet        Не показывать сами способы.
  --no-silent                 Показывать способы (отключает режим --silent).
  -d                          Выводить массу отладочных сообщений.
  --debug[=ФЛАГИ]             Выводить различные типы отладочной информации.
	 a for all debugging output (same as using -d)
	 b for basic  debugging,  
	 v for  more  verbose basic debugging, 
	 i for showing implicit rules, 
	 j for details on invocation of commands, and 
	 m for debugging while remaking makefiles.  
	 Use n to disable all previous debugging flags 
  --trace                     Выводить трассировочную информацию.
p -p, --print-data-base       Напечатать внутреннюю базу данных make.

  -w, --print-directory       Напечатать текущий каталог.
  --no-print-directory        Отменить ключ -w, даже если он был явно указан.

ничего не делать ---------------------------------------------------
  -v, --version               Показать информацию о версии и выйти.
  -h, --help                  Показать эту справку и выйти.
  -b, -m                      Игнорируется для совместимости.
.  



цели : пререквизиты | упорядоченные пререквизиты
	-команда # make продолжит работу, если команда завершиться с ошибкой

.PHONY: список виртуальных целей

VPATH - путь поиска пререквезитов
$@ - цель (имя файла)
$% - цель внутри архива
$< - 1й пререквизит
$? - все новые пререквизиты
$^ - все пререквизиты, каждый по 1 разу
$+ - все пререквизиты, как указано
$| - все упорядоченные пререквизиты
$* - ???

foo.o : foo.c defs.h
	cc -c -o $@ $<

$? - например, чтобы напечатать обновленные файлы



http://linux.yaroslavl.ru/docs/prog/gnu_make_3-79_russian_manual.html#SEC93


если пререквизит - неявная цель, 

.	    Назначение программы make
.		Как читать данное руководство
.		Ошибки и проблемы 
.	    Знакомство с make-файлами (makefiles)
.		Как выглядят правила (rules)
.		Пример простого make-файла
.		Как make обрабатывает make-файл
15,52		Упрощение make-файла с помощью переменных
16,00		Неявные правила упрощают make-файл
16,03		Другой стиль написания make-файлов
16,11		Правило для очистки каталога 
16,35	    Создание make-файлов
16.53		Из чего состоят make-файлы
			комментарии	#
			переменные
			директивы
				многострочные "переменные"
				include
				условная "компиляция"
			явные правила
			неявные правила
17,15		Имена make-файлов
			если нет make-файла, то надо явно указывать цель для неявных правил
18,33		Подключение других make-файлов
			если нет нужного файла, будет предупреждение, и он будет добавлен в список целей
			sinclude - если отсутствует или не получается собрать - ничего страшного
18,48		Переменная MAKEFILES
			вначале подключаются файлы, указанные здесь
21.03	...	Автоматическое обновление make-файлов
			после того как всё прочитал пытается рассматривать все make-файлы как цели и обновлять их
21,16	...	"Перекрытие" (overriding) части make-файла
22,24	...	Как make читает make-файл 
			главная цель - самая первая (включая include-файлы, но не включая MAKEFILES)
				кроме начинающихся с . и шаблонных
22.40	    Составление правил (rules)
23.01		Синтаксис правил
23.20		Использование шаблонных символов (wildcard characters) в именах файлов
23,55		    Примеры шаблонных имен
00.06		    Проблемы при использовании шаблонных имен
00.15		    Функция wildcard 
			раскрываются только в целях, пререквизитах и wildcard
			как в shell: * ? [...]
00.18		Поиск пререквизитов по каталогам
19.00		    Переменная VPATH: список каталогов для поиска пререквизитов
			VPATH - если цель в другой директории и она устарела - она обновится в текущей директории
			GPATH - если цель в другой директории и она устарела - она обновится в той директории в которой она есть
19.33		    Директива vpath(шаблон список-папок)
19.45		    Процедура поиска по каталогам
			текущая, vpath(...), VAPTH
19.53		    Написание команд с учетом поиска по каталогам
20.08	...	    Поиск в каталогах и неявные правила
20.42		    Поиск в каталогах для подключаемых библиотек 
			пререквизиты вида -lимя
				заменяются на значение из .LIBPATTERNS (lib%.so lib%.a)
				и ищутся дополнительнов /lib /usr/lib prefix/lib
21,57		Абстрактные цели (phony targets)
			если пререквизит - абстрактная цель - такое правило будет выполняться всегда, но лучше так не делать
			??? что если цель существует, но как папка
22,15		Правила без команд и пререквизитов
			выполняются всегда
			если вообще без команд - выполняется неявное правило
22,22		Использование пустых целей (empty target files) для фиксации событий
			FORCE : 
13.46	...	Имена специальных целей
13.56	...	Правила с несколькими целями
			как несколько одинаковых правил с одной целью, теми же пререквизитами и командами
			а еще там придумали группы целей - которые обновляются одной командой
				цели &: пререквизиты
14.32		Несколько правил с одной целью
			все пререквизиты собираются вместе
			но команды должны быть указаны только в одном правиле
			если вообще без команд - выполняется неявное правило
		Статические шаблонные правила (static pattern rules)
		    Синтаксис статических шаблонных правил
			цели : шаблон : пререквизиты
		    Сравнение статических шаблонных правил (static pattern rules) и неявных правил (implicit rules) 
		Правила с двойным двоеточием (double-colon rules)
			если способ обновления одной и той же цели зависит от пререквизита:
				цель :: пререк1
					ком1
				цель :: пререк2
					ком2
		Автоматическая генерация списка пререквизитов 
			cc -M main.c
			->	main.o : main.c defs.h
	    Написание команд
		Отображение исполняемых команд (command echoing)
			@com - не отображается
		Исполнение команд
		Параллельное исполнение команд
		Ошибки при исполнении команд
		Прерывание (interrupting) или принудительное завершение (killing) make
		Рекурсивный вызов make
		    Как работает переменная MAKE
		    Связь с make "нижнего уровня" (sub-make) через переменные
		    Передача опций в make "нижнего уровня"
		    Опция `--print-directory' 
		Именованные командные последовательности (canned command sequences)
		Пустые команды (empty commands) 
	    Использование переменных (variables)
		Обращение к переменным
		Две разновидности (flavors) переменных
		"Расширенные" способы обращения к переменным
		    Ссылка с заменой (substitution reference)
		    Вычисляемые имена переменных (computed variable names) 
		Как переменные получают свои значения
		Установка значения переменной
		Добавление текста к переменной
		Директива override
		Многострочные переменные
		Переменные из операционного окружения (environment)
		Целе-зависимые (target-specific) значения переменных
		Шаблонно-зависимые (pattern-specific) значения переменных 
	    Условные части (conditional parts) make-файла
		Пример условной конструкции
		Синтаксис условных конструкций
		Проверка опций запуска make в условных конструкциях 
	    Функции преобразования текста
		Синтаксис вызова функций
		Функции анализа и подстановки строк
		Функции для обработки имен файлов
		Функция foreach
		Функция if
		Функция call
		Функция origin
		Функция shell
		Функции управления сборкой 
	    Запуск make
		Аргументы для задания make-файла
		Аргументы для задания главной цели (goal)
		Вместо исполнения команд
		Предотвращение перекомпиляции некоторых файлов
		"Перекрытие" (overriding) переменных
		Проверка компиляции программы
		Обзор опций 
	    Использование неявных правил (implicit rules)
		Использование неявных правил (implicit rules)
		Перечень имеющихся неявных правил
		Используемые в неявных правилах переменные
		"Цепочки" (chains) неявных правил
		Определение и переопределение шаблонных правил (pattern rules)
		    Введение в шаблонные правила (pattern rules)
		    Примеры шаблонных правил
		    Автоматические переменные
		    Процедура сопоставления с шаблоном
		    Шаблонные правила с призвольным (match-anything) соответствием
		    Отмена действия неявных правил 
		Определение правил "последнего шанса" (last-resort rules)
		Устаревшие суффиксные правила (suffix rules)
		Алгоритм поиска неявных правил 
	    Использование make для обновления архивов
		Использование элементов архива в качестве целей
		Неявные правила для целей - элементов архива
		    Обновление каталога символов архивного файла 
		Проблемы при использовании архивов
		Суффиксные правила для архивных файлов 
	    Возможности GNU make
	    Несовместимость и нереализованные функции
	    Принятые соглашения для make-файлов
		Общие соглашения для make-файлов
		Использование утилит
		Переменные для имен команд
		Переменные для имен каталогов инсталляции
		Стандартные имена целей для пользователей
		"Категории" команд инсталляции 
	    Справочник
	    Сообщения об ошибках
	    Пример "сложного" make-файла
	    Индекс
	    Индекс: функции, переменные и директивы 
	    




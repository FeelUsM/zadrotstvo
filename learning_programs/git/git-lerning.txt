git config переменная значение
	--system	-> /etc/gitconfig
	--global	-> ~/.gitconfig
	--local		-> ./.git/config
	--list	перечислить все измененные по умолчанию
		user.name
		user.email
		core.editor	или $EDITOR
		merge.tool	--- diff утилита
		init.defaultBranch
		color.status=auto
		color.branch=auto
		color.interactive=auto
		color.diff=auto
		--show-origin
		alias.unstage 'reset HEAD --'
		alias.co checkout
		alias.br branch
		alias.ci commit
		alias.st statusgit help команда
git <команда> --help
git <команда> -h
man git-<команда>
------------------------------------------------------
git log --pretty=format:"%h %cd %an""$(printf \\t)""%s" --date=short --graph > gitlog
git remote
git remote show origin >> gitlog
git tag | wc -l
for h in $(git tag ); do printf '%s\t%s\n' $h "$(git log -1 --date=short --format=format:"%h %cd %an""$(printf \\t)""%s" $h)"; done >> gitlog
for h in $(git log --pretty=format:%H ); do git show --stat --date=short --format=format:"%h %cd %an""$(printf \\t)""%s" $h; done > gitlog1
git show --stat <tag>


git clone --shallow-since=2019-02-19 'git://git.sv.gnu.org/gnulib.git' 'gnulib'
git submodule init -- gnulib
git submodule update -- gnulib
git submodule init -- gl-mod/bootstrap
git submodule update -- gl-mod/bootstrap
gnulib/gnulib-tool --no-changelog --avoid=dummy --libtool --macro-prefix=GL --with-tests --tests-base=gnulib-tests --aux-dir=build-aux --m4-base=m4 --local-dir=gl --local-dir=gl-mod/bootstrap --symlink --import announce-gen bootstrap...

------------------------------------------------------
git init
git clone url.git [folder]
		https://
		git:// --- только чтение (?)
		user@server:/ (ssh)
git remote --- перечисляет "имена" удаленных репозиториев
		origin - имя репозитория, 
	-v --- посмотреть url-ы для (fetch) и (push)
	add имя url --- добавить удаленный репозиторий
	show [удал. сервер]
	rename name-old name-new
	remove name
git fetch имя_репозитория --- получить всю информацию из этого репозитория, которой у меня нет
		после этого все удаленные ветки надо будет сливать со своими: git merge сервер/ветка
git pull = git fetch отслеживаемый_репозиторий + слияние с текущим
git push [удал. сервер=origin] [ветка=master] --- по умолчанию выкладывает только текущую ветку
	удал_сервер метка
	удал_сервер --tags --- выложить все метки
	сервер лок_ветка:уд_ветка --- взять локальную ветку, и скопировать ее в удаленную
		я так понял, на удаленном сервере допускается только fast forward merge
	сервер :уд_ветка --- удалить на сервере удаленную ветку
	origin <tagname> --- по умолчанию не отправлет тэги
------------------------------------------------------
.gitignore
git status
		неотслеживаемые
		отслеживаемые измененные
		проиндексированные
	-s --short	--- короткий вывод статуса
		.	--- статус файла
		 .	--- проиндексирован ли
		 M README		отредактирован но не проиндексирован
		MM Rakefile		добавлен в индекс и после отредактирован
		A  lib/git.rb		новый файл добавлен в индекс
		M  lib/simplegit.rb	добавлен в индекс
		?? LICENSE.txt		неотслеживаемый
git diff
	--word-diff 	--- diff по словам {+добавленное слово+} [-удаленное слово-]
	-U1 		--- 1 строка контекста
git apply		--- прочитать со стандартного входа diff и применить его
	-R		--- прочитать со стандартного входа diff и применить его в обратном порядке
git grep [опции] выражение [коммит]
	-n	--- вывести номера строк
	--count	--- вывести количество совпадений для каждого файла
	-p	--- вывести, из какой функции вызывалось
	--break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
git log			--- история коммитов
	-3 		--- 3 последних коммита
	--since ...
	--until ...
	--autor ...
	--committer

	-p 		--- также выводить diff
	--stat 		--- также выводить status - сокращенная статистика
	--shortstat
	--name-only	--- только имена измененных файлов
	--name-status	--- только имена измененных файлов и сколько добавлено/удалено внутри

	--short
	--full
	--fuller

	--pretty=
		oneline		--- в одну строку
		format:"..."	
			%H	Хеш коммита
			%h	Сокращенный хеш коммита
			%T	Хеш дерева
			%t	Сокращенный хеш дерева
			%P	Хеш родителей
			%p	Сокращенный хеш родителей
			%an	Имя автора
			%ae	Электронная почта автора
			%ad	Дата автора (формат даты можно задать опцией --date=option)
			%ar	Относительная дата автора
			%cn	Имя коммитера
			%ce	Электронная почта коммитера
			%cd	Дата коммитера
			%cr	Относительная дата коммитера
			%s	Содержание	
	--oneline
	--graph		--- добавить граф веток

	
	--abbrev-commit	--- Показывает только несколько символов SHA-1 
	--relative-date	--- типа "2 weeks ago"
	
	--since=<date>
	--until=<date>
	--no-merge	--- исключить коммиты слияния
	опции git diff
	-g 		--- в таком же формате как git reflog
	ветка_A..ветка_B	--- коммиты ветки_B с того момента как она (или от нее) отделилась от ветки_A
	origin/master..HEAD	--- те коммиты, которые будут отправлены на сервер
	origin/master..		--- те коммиты, которые будут отправлены на сервер
	refA refB ^refC		--- коммиты, достижимые из refA и refB но не достижимые из refC
	refA refB --not refC	--- коммиты, достижимые из refA и refB но не достижимые из refC
	master...experiment	--- коммиты, достижимые или из master или из experiment, но не из обоих сразу
	--left-right master...experiment	--- --..--, с указанием, какой коммит достижим из master, а какой из experiment
	-Sстрока	--- найти в истории и в соотв. diff-ах строку
	-Gпаттерн	--- найти в истории и в соотв. diff-ах паттерн
	-L :функция:файл	--- все изменения в заданной функции в заданном файле
	-L '/unsigned long git_deflate_bound/',/^}/:zlib.c	--- --..-- только функция задается рег.выр-ом
git tag --- тегами помечают коммиты
		обычные - только имя
		аннотированные - как коммит
	без аргументов 		--- печатает имена тегов
	-l 'шаблон' 		--- какие имена тегов печатать
	имя [коммит=последний]		 	--- создание легковесной
	-a имя -m сообщение [коммит=последний]	--- создание аннотированной
	-s имя -m сообщение [коммит=последний]	--- создание аннотированной и подписанной при помощи GPG (нужен закрытый ключ ц. подписи)
	-v имя			--- верификация ц. подписи GPG (желателен открытый ключ ц. подписи)
	-d имя			--- удалить тэг
git show метка/ветка/коммит	--- посмотреть метку/ветку/коммит
	HEAD@{5}	--- посмотреть коммит, где был HEAD 5 операций над HEAD назад
	master@{yesterday}
	HEAD@{2.months.ago}
		метка/ветка/коммит - указатель
	указатель^	--- предок данного указателя
	указатель^2	--- 2й предок данного указателя, если данный указатель имеет 2 или более предков (например это был merge)
	указатель~	--- предок данного указателя
	указатель~3	--- предок в 3м поколении данного указателя
	указатель^^^	--- предок в 3м поколении данного указателя
	HEAD~3^2
------------------------------------------------------
git add файлы
	-i/--interactive	--- интерактивный режим добавления
	--patch 	--- избирательно откатить измения содержимого файла по частям
git rm [опции] файлы
	-f 		--- удалять из индекса
	--cached 	--- оставить на диске
git mv from to 		--- сам определяет, что переименовано
git stash 		--- спрятать текущие изменения в стек заначек
	save 		--- спрятать текущие изменения в стек заначек
	save --keep-index	--- спрятать то, что не добавлено в индекс
	-u/--include-untracked	--- спрятать также и неотслеживаемые файлы
	--all		--- спрятать всё
	--patch		--- в интерактивном режим спросит вас о том, какие из изменений вы хотите спрятать, а какие оставить
	list		--- показать стек заначек
	apply [id-заначки]	--- применить указанную или последнюю заначку
	apply [id-заначки] --index	--- применить указанную или последнюю заначку, и восстановить, что было в индексе
	show -p id-заначки	--- напечатать diff заначки
	drop id-заначки	--- удалить заданную заначку из стека
	pop		--- применить и удалить заначку из вершины стека
	branch		--- создать новую ветку от того места, где произошло прятанье
git clean		--- очистить изменения
	-f		--- также неотслеживаемые файлы
	-d		--- удалить пустые директории
	-n		--- ничего не удалять а только показать, что было бы удалено
	-x		--- очистить также, что попадает под .gitignore
	-i		--- в интерактивном режиме
git commit
	-a		--- не парится по поводу git add
	-m message
	-v		--- если отсутствует -m, то в текстовом редакторе выведет git diff а не git status
	--amend		--- объединить текущий и предыдущий коммиты с сообщением последнего (если есть, иначе предыдущего)
		HEAD - указатель на текущую ветку, родитель следующего коммита
git revert ссылка	--- сделать коммит, который приводит текущее состояние в состояние, задаваемое ссылкой
git reflog		--- выдать последние значения HEAD
		ORIG_HEAD=HEAD@{1}
git restore
	<file>		--- восстанавливает файл в индексе и в рабочем каталоге
	--staged <file>	--- восстанавливает файл в индексе
git checkout
	коммит		--- установить рабочий каталог в соответствии с коммитом
				скорее всего получится detached HEAD
	-- <file>... (* не работает) --- установить файл на диске в соответствии с последним коммитом
	ветка		--- переключиться на соотв. ветку (не должно быть незакоммиченных файлов(?))
			(?)пытается выполнить в Рабочем Каталоге простые слияния так, чтобы все файлы, которые вы не изменяли, были обновлены
	-b ветка	--- создать ветку и сразу на нее переключиться (не должно быть незакоммиченных файлов(?))
	-b ветка коммит	--- создать ветку от коммита и сразу на нее переключиться
	--track исх_ветка	--- создать ветку от исх_ветки с таким же именем и сразу на нее переключиться
	--patch 	--- избирательно откатить изменения содержимого файла по частям
git reset
	HEAD --		--- убрать все файлы из индекса
	HEAD <file>...	--- убрать файл из проиндексированного
	опц. ссылка	--- перемещает HEAD и текущую ветку на заданную ссылку
	--soft		--- и всё, индекс и рабочий каталог останутся как есть 
		(если до этого индекс был пуст, то после этого он будет содержать предыдущее значение HEAD)
	--mixed		--- дополнительно устанавливает индекс на новый HEAD
	--hard		--- ещё дополнительно устанавливает рабочий каталог на новый HEAD
	[опц.=--mixed] [ссылка=HEAD] файл	--- пропускает перемещение HEAD и текущей ветки на заданную ссылку
			но устанавливает файл в индексе или еще и в рабочем каталоге в значение, которое указано в ссылке
	--patch 	--- избирательно откатить изменения содержимого файла по частям
git switch -c имя-новой-ветки коммит --- 
git branch имя		--- ветка_имя := текущая_ветка - создание новой ветки, но не переключение на нее
	-d имя		--- удаление ветки (она должна присутствовать в git branch --merget)
	-D имя		--- удаление ветки в любом случае
	без аргументов	--- выведет список веток, * напротив HEAD
	-v		--- выведет список веток, * напротив HEAD, напротив каждой ветки последний коммит
	--merged	--- список веток, которые были слиты с текущей веткой
	--no-merged	---			не
	-r		--- remote branches
	-a		--- local and remote branches
git merge ветка	--- сливает текущую ветку с заданной (текущая+=заданная)
		fast forward - если ветки находятся на одной линии
		новый коммит слияния - в противном случае
		или оставит изменения незакомииченными, если возник конфликт, а в конфликтных файлах появятся соотв. пометки
git mergetool	--- ...
git rebase ветка	--- перемещение изменений между ветвлением и текущей веткой на указанную
		Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.
		? а что насчет конфликтов? ведь заданные изменения можно применить не к любому файлу

слияние репозиториев
https://ahitrin.github.io/work/2012/07/16/%D0%A1%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B5%D0%B2-%D0%B2-git/
распаковка одновременно двух веток
https://stackoverflow.com/questions/2048470/git-working-on-two-branches-simultaneously
-----------------------------------------
file system		git изначально был разработан как файловая система

---- объекты ---
SHA-1			40 16-ричных символов
object name		40 16-ричных символов, можно сокращать до нескольких, но чтобы были уникальны внутри репозитория
hash			имя объекта
object identifier	object name
object			единица хранения в Git, идентифицируется хешом(именем) и не может быть изменена

---- рабочая область ---
working tree		распакованные файлы - HEAD + незакоммиченные изменения
index			файлы, которые сохранены как объекты, сохранённая версия working tree.
			??? содержит 2ю и 3ю версию рабочей области, которая использовалась при слиянии ???
index entry		информация об отдельном файле, хранящаяся в индексе.
				запись индекса может быть не присоединена, если слияние началось, но еще не закончилось (т.е. индекс содержит несколько версий этого файла)
cache			устаревшее название индекса
clean			рабочая область чистая, если она совпадает с текущей веткой.
dirty			рабочая область грязная, если она имеет изменения, которые не закоммичены в текущую ветку.
stash entry		объект, используемый для временного хранения содержимого грязной рабочей области и индекса для дальнейшего использования
worktree		Репозиторий может иметь 0 (голый репозиторий) или больше рабочих областей, связанных с ним. Каждая worktree содержит working tree, и метаданные
				часть из которых общая для всех worktree, а часть индивидуальна (индекс, HEAD, псевдоссылки типа MERGE_HEAD, др. ссылки и конфигурационный файл)
				
---- коммиты ---
blob object		безтиповый объект, т.е. содержимое файла
tree			рабочая область или древовидный объект с зависимыми древовидными и безтиповыми объектами (сохранённое представление рабочей области)
tree object		объект, содержащий список имён файлов и их атрибутов со ссылками на безтиповые и древовидные объекты. Дерево эквивалентно директории.
directory		то что выдает нам ls
parent			предшественники в линии разработки
commit object		содержит информацию о ревизии:
				предки
				коммиттер, автор, дата
				древовидный объект директории
commit			ревизия, точка в истории
revision		синоним коммита
changeset		набор изменений - коммит в BitKeeper/cvsps. Не имеет смысла в git
DAG			Directed acyclic graph. Коммит-объекты формируют однонаправленный ацикличный граф.

---- ссылки и ветки ---
ref			имя, начинающееся на 'refs/' , которое указывает на хэш объекта или другую ссылку (это symref). Хранится в репозитории.
				иногда можно сокращать, см getrevisions(7)
				есть подпространства имён (refs/heads/, reafs/tags/, ...)
				есть исключения, например HEAD
symref			симмвольная ссылка - не хэш, а ссылка на ссылку, формат ref: refs/some/thing. Типичный пример - HEAD.
pseudoref		файлы в $GIT_DIR, которые ведут себя как ссылки в git rev-parse, но обрабатываются специально. Но git rev-parse работает.
				Имя большими буквами, содержат SHA-1, пробел и возможно доп. данные. Не являются символьными ссылками. (=> HEAD - не псевдо-ссылка)
				Примеры MERGE_HEAD, CHERRY_PICK_HEAD.
per-worktree ref	HEAD, refs/bisect/* и др.
reflog			показывает локальную "историю" ссылки, типа: 3я последняя ревизия репозитория, теккущее состояние этого репозитория вчера в 9:14. см. git reflog
head			ссылка на коммит на кончике ветки. головы (веток) хранятся в refs/heads/
				Но если ссылки запакованные (git-pack-refs(1)), то в другом месте хранятся
head ref		то же что и head
branch			линия разработки. Кончик ветки - последний коммит в ней - называется головой ветки. 
				Может быть много веток, но рабочее пространство ассоциируется только с одной из них, на неё указывает HEAD
HEAD			текущая ветка. Ссылка, которая указывает на голову одной из веток, за исключением случая "отсоединённый HEAD", в этом случае HEAD указывает на произвольный коммит
master			ветка, создаваемая по умолчанию при создании репозитория, которая становится активной веткой.
				 В большинстве случаев это включает в себя локальную разработку, хотя это чисто условно и не требуется. 
topic branch		обычная ветка, которая используется для концептуальной линии разработки. Т.к. ветки просты и дёшевы, часто хочется иметь несколько веток,
				каждая из которых содержит хорошо определенную концепцию или небольшие инкрементальные но связананные изменения.
rewind			выкидывание части разработки, например присоединение головы ветки к более ранней ревизии.
rebase			применение последовательности изменений к другой ветке, (?) и присваивание ее головы на результат
cherry-picking		в жаргоне SCM означает выбор изменений (в коммитах) и применение их к другим файлам. 
				есть команда git cherry-peak , которая берет изменения из данного коммита и применяет их к текущей ветке, создавая новый коммит.
				
---- тэги, доступность ---
tag object		ссылка на другой объект и сообщение (примерно как коммит-объект). Может также содержать PGP сигнатуру, в этом случае называется подписанный тэг-объект.
tag			ссылка в пространстве имен 'refs/tags/', указывающая на объект произвольного типа (обычно коммит или другой тег).
				В отличие от головы тэг не обновляется командой commit.
				Не имеет ни чего общего с Lisp тэгами (которые называются тип объекта в контекста git).
				Тег обычно используется для пометок в цепочке коммитов.
object type		blob-object, tree-object, commit-object or tag-object
chain			список объектов, где каждый объект содержит ссылку на своего преемника (?) (например преемник commit-а - его предок)
reachable		предки данного коммита, если они доступны из него.
				Объект доступен из другого, если мы можем попасть туда из первого 
				по цепочке от тэгов, от коммитов к их предкам или деревьям, от деревьев к деревьям или блоб-ам, которые они содержат
unreachable object	объект, который недоступен из веток, тэгов или других ссылок
dangling object		болтающийся объект - недоступный объект, который недоступен даже из недоступных объектов. На него никто не ссылается
commit-ish (also committish) коммит-объект или тэг-объект, который указывает на коммит-объект или на тэг-объект, который указывает на коммит-объект или на ...
tree-ish (also treeish)	древовидный - дерево-объект или commit-ish или тэг-объект, который указывает на tree-ish

---- репозиторий как целое ---
SCM			Source code management (tool).
core Git		фундаментальные структуры данных и утилиты гит. Предоставляет только ограниченные средства управления исходным кодом.
plumbing		сантехника - другое называние core Git
porcelain		фарфор - другое незвание программ, зависящих от core Git. Предоставляет больше возможностей управления исходным кодом чем сантехника.
object database		Набор объектов, идентифицируемых хэшами. Обычно содержатся в .git/objects/
repository		коллекция ссылок на б.д. объектов, которые доступны из этих ссылок. Возможно дополненные метаданными из фарфора. 
				Репозиторий может делиться свой б.д. объектов с другими репозиториями через alternate mechanism
Git archive		синоним репозитория (для архаичных людей)
alternate object database через alternate mechanism репозиторий может наследовать часть б.д. объектов из другой б.д., которая называется альтернативной
checkout		обновление всего рабочего пространства или его части из объекта дерева или блоба из б.д. объектов.
				а также обновление индекса и HEAD-а если все рабочее дерево было направлено на новую ветвь.
detached HEAD		обычно HEAD содержит имя ветки. команды, которые работают с историей, представленной HEAD, работают с вершиной ветки на который указывает HEAD.
				Git позволяет checkout произвольный коммит, который не является вершиной ветки. В этом случае HEAD называется отсоединённым.
				Обратите внимание, что команды, которые работают с историей ветки (например git commit, которая строит историю на вершине ветки) продолжают работать с отсоединённым HEAD.
				Они обновляют HEAD, но не влияют ни на какую ветку. 
				Команды, которые работают с текущей веткой (например 'git branch --set-upstream-to' которая устанавливает, с какой удалённой веткой интегрируется текущая ветка)
				очевидно не могут работать вообще.
bare repository		голый репозиторий - который не содержит распакованных файлов. Папка имеет вид repository.git . Обычно используется для публичных репозиториев.
gitfile			файл '.git' в корне рабочей директории, который указывает на директорию с репозиторием

---- слияние ---
merge			перенос содержимого из некоторой ветки (возможно из удалённого репозитория) в текущую ветку
				В случае если присоединяемая ветка находится в другом репозитории, ето делается сначала при помощи fetch, и только потом merge. Комбинация fetch и merge называется pull.
				Слияние - автоматический процесс, который определяет изменения, повившиеся после того как ветки разошлись, и применяет их для объединения.
				В случае возниконовения конфликтов требуется ручное вмешательство для завершения слияния.
			merge commit - (если не fast-forward) - результат успешного слияния, коммит, который имеет в качестве предков вершины объединяемых веток
evil merge		содержит изменения, которых нет ни в одном родителе
octopus			объединение более чем 2 веток
resolve			Действие по исправлению вручную того, что осталось после неудачного автоматического слияния.
fast-forward		специальный тип слияния, когда добавляемая к вашей ревизии ветка имеет изменения, которые происходили от того, что у вас есть.
				В этом случае вы не делаете merge commit, а просто обновляете вашу ветку чтобы она указывала на ту же ревизию, которая на вершине добавляемой ветки.
				Это часто происходит на удалённо отслеживаемой ветке.
unmerged index		индекс, который содержит неприсоединённые записи индекса

---- удалённые репозитории ---
remote repository	репозиторий, который используется для отслеживания того же проекта, но находится где-то еще. 
				Для взаимодействия с ними см. fetch или push
origin			ведущий удалённый репозиторий по умолчанию. Обновления ведущего репозитория выбираются (fetch) из удалённо-отслеживаемых веток т.е. из origin/<имя-ветки>
				их можно посмотреть при помощи git branch -r
remote-tracking branch	ссылка, которая используется для следования другому репозиторию. Обычно выглядит как refs/remotes/foo/bar (удалённый репозиторий foo, ветка bar)
				и соответствует правому refspec для fetch.
				Удалённо-отслеживаемая ветка не дожна содержать прямых модификаций или иметь локальные коммиты.
upstream branch		ветка по умолчанию, которая добавляется в запрашиваемую ветку (слиянием или rebase-ом)
				Она конфигурируется через branch.<name>.remote и branch.<name>.merge.
				Если ведущая ветка A это origin/B, иногда говорят, что A отслеживает origin/B.
refspec			используется push и fetch для описания отображения между локальной и удалённой ссылкой.
push			выталкивание ветки означает получение ссылки на голову удалённого репозитория. 
				Если она является предком головы локльной ветки, помещает объекты, доступные из локальной ветки в удалённую, если они там отсутствуют.
				Если голова удалённой ветки не является предком головы локльной ветки, - происходит неудача.
fetch			выборка ветки означает получение головы ветки из другого репозитория, и поиск объектов, которые отсутствуют в локальной б.д. объектов, и их получение. см. git fetch
pull			вытягивание ветки означает выборка ветки и слияние её с локальной. см. git pull
----





pack
pack index

pathspec

overlay
grafts
hook
pickaxe
shallow clone
shallow repository
submodule
superproject

git config переменная значение
	--system	-> /etc/gitconfig
	--global	-> ~/.gitconfig
	--local		-> ./.git/config
	--list	перечислить все измененные по умолчанию
		user.name
		user.email
		core.editor	или $EDITOR
		merge.tool	--- diff утилита
		init.defaultBranch
		color.status=auto
		color.branch=auto
		color.interactive=auto
		color.diff=auto
		--show-origin
		alias.unstage 'reset HEAD --'
		alias.co checkout
		alias.br branch
		alias.ci commit
		alias.st statusgit help команда
git <команда> --help
git <команда> -h
man git-<команда>
------------------------------------------------------
git log --pretty=format:"%h %cd %an""$(printf \\t)""%s" --date=short --graph > gitlog
git remote
git remote show origin >> gitlog
git tag | wc -l
for h in $(git tag ); do printf '%s\t%s\n' $h "$(git log -1 --date=short --format=format:"%h %cd %an""$(printf \\t)""%s" $h)"; done >> gitlog
for h in $(git log --pretty=format:%H ); do git show --stat --date=short --format=format:"%h %cd %an""$(printf \\t)""%s" $h; done > gitlog1
git show --stat <tag>


git clone --shallow-since=2019-02-19 'git://git.sv.gnu.org/gnulib.git' 'gnulib'
git submodule init -- gnulib
git submodule update -- gnulib
git submodule init -- gl-mod/bootstrap
git submodule update -- gl-mod/bootstrap
gnulib/gnulib-tool --no-changelog --avoid=dummy --libtool --macro-prefix=GL --with-tests --tests-base=gnulib-tests --aux-dir=build-aux --m4-base=m4 --local-dir=gl --local-dir=gl-mod/bootstrap --symlink --import announce-gen bootstrap...

------------------------------------------------------
git init
git clone url.git [folder]
		https://
		git:// --- только чтение (?)
		user@server:/ (ssh)
git remote --- перечисляет "имена" удаленных репозиториев
		origin - имя репозитория, 
	-v --- посмотреть url-ы для (fetch) и (push)
	add имя url --- добавить удаленный репозиторий
	show [удал. сервер]
	rename name-old name-new
	remove name
git fetch имя_репозитория --- получить всю информацию из этого репозитория, которой у меня нет
		после этого все удаленные ветки надо будет сливать со своими: git merge сервер/ветка
git pull = git fetch отслеживаемый_репозиторий + слияние с текущим
git push [удал. сервер=origin] [ветка=master] --- по умолчанию выкладывает только текущую ветку
	удал_сервер метка
	удал_сервер --tags --- выложить все метки
	сервер лок_ветка:уд_ветка --- взять локальную ветку, и скопировать ее в удаленную
		я так понял, на удаленном сервере допускается только fast forward merge
	сервер :уд_ветка --- удалить на сервере удаленную ветку
	origin <tagname> --- по умолчанию не отправлет тэги
------------------------------------------------------
.gitignore
git status
		неотслеживаемые
		отслеживаемые измененные
		проиндексированные
	-s --short	--- короткий вывод статуса
		.	--- статус файла
		 .	--- проиндексирован ли
		 M README		отредактирован но не проиндексирован
		MM Rakefile		добавлен в индекс и после отредактирован
		A  lib/git.rb		новый файл добавлен в индекс
		M  lib/simplegit.rb	добавлен в индекс
		?? LICENSE.txt		неотслеживаемый
git diff
	--word-diff 	--- diff по словам {+добавленное слово+} [-удаленное слово-]
	-U1 		--- 1 строка контекста
git apply		--- прочитать со стандартного входа diff и применить его
	-R		--- прочитать со стандартного входа diff и применить его в обратном порядке
git grep [опции] выражение [коммит]
	-n	--- вывести номера строк
	--count	--- вывести количество совпадений для каждого файла
	-p	--- вывести, из какой функции вызывалось
	--break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
git log			--- история коммитов
	-3 		--- 3 последних коммита
	--since ...
	--until ...
	--autor ...
	--committer

	-p 		--- также выводить diff
	--stat 		--- также выводить status - сокращенная статистика
	--shortstat
	--name-only	--- только имена измененных файлов
	--name-status	--- только имена измененных файлов и сколько добавлено/удалено внутри

	--short
	--full
	--fuller

	--pretty=
		oneline		--- в одну строку
		format:"..."	
			%H	Хеш коммита
			%h	Сокращенный хеш коммита
			%T	Хеш дерева
			%t	Сокращенный хеш дерева
			%P	Хеш родителей
			%p	Сокращенный хеш родителей
			%an	Имя автора
			%ae	Электронная почта автора
			%ad	Дата автора (формат даты можно задать опцией --date=option)
			%ar	Относительная дата автора
			%cn	Имя коммитера
			%ce	Электронная почта коммитера
			%cd	Дата коммитера
			%cr	Относительная дата коммитера
			%s	Содержание	
	--oneline
	--graph		--- добавить граф веток

	
	--abbrev-commit	--- Показывает только несколько символов SHA-1 
	--relative-date	--- типа "2 weeks ago"
	
	--since=<date>
	--until=<date>
	--no-merge	--- исключить коммиты слияния
	опции git diff
	-g 		--- в таком же формате как git reflog
	ветка_A..ветка_B	--- коммиты ветки_B с того момента как она (или от нее) отделилась от ветки_A
	origin/master..HEAD	--- те коммиты, которые будут отправлены на сервер
	origin/master..		--- те коммиты, которые будут отправлены на сервер
	refA refB ^refC		--- коммиты, достижимые из refA и refB но не достижимые из refC
	refA refB --not refC	--- коммиты, достижимые из refA и refB но не достижимые из refC
	master...experiment	--- коммиты, достижимые или из master или из experiment, но не из обоих сразу
	--left-right master...experiment	--- --..--, с указанием, какой коммит достижим из master, а какой из experiment
	-Sстрока	--- найти в истории и в соотв. diff-ах строку
	-Gпаттерн	--- найти в истории и в соотв. diff-ах паттерн
	-L :функция:файл	--- все изменения в заданной функции в заданном файле
	-L '/unsigned long git_deflate_bound/',/^}/:zlib.c	--- --..-- только функция задается рег.выр-ом
git tag --- тегами помечают коммиты
		обычные - только имя
		аннотированные - как коммит
	без аргументов 		--- печатает имена тегов
	-l 'шаблон' 		--- какие имена тегов печатать
	имя [коммит=последний]		 	--- создание легковесной
	-a имя -m сообщение [коммит=последний]	--- создание аннотированной
	-s имя -m сообщение [коммит=последний]	--- создание аннотированной и подписанной при помощи GPG (нужен закрытый ключ ц. подписи)
	-v имя			--- верификация ц. подписи GPG (желателен открытый ключ ц. подписи)
	-d имя			--- удалить тэг
git show метка/ветка/коммит	--- посмотреть метку/ветку/коммит
	HEAD@{5}	--- посмотреть коммит, где был HEAD 5 операций над HEAD назад
	master@{yesterday}
	HEAD@{2.months.ago}
		метка/ветка/коммит - указатель
	указатель^	--- предок данного указателя
	указатель^2	--- 2й предок данного указателя, если данный указатель имеет 2 или более предков (например это был merge)
	указатель~	--- предок данного указателя
	указатель~3	--- предок в 3м поколении данного указателя
	указатель^^^	--- предок в 3м поколении данного указателя
	HEAD~3^2
------------------------------------------------------
git add файлы
	-i/--interactive	--- интерактивный режим добавления
	--patch 	--- избирательно откатить измения содержимого файла по частям
git rm [опции] файлы
	-f 		--- удалять из индекса
	--cached 	--- оставить на диске
git mv from to 		--- сам определяет, что переименовано
git stash 		--- спрятать текущие изменения в стек заначек
	save 		--- спрятать текущие изменения в стек заначек
	save --keep-index	--- спрятать то, что не добавлено в индекс
	-u/--include-untracked	--- спрятать также и неотслеживаемые файлы
	--all		--- спрятать всё
	--patch		--- в интерактивном режим спросит вас о том, какие из изменений вы хотите спрятать, а какие оставить
	list		--- показать стек заначек
	apply [id-заначки]	--- применить указанную или последнюю заначку
	apply [id-заначки] --index	--- применить указанную или последнюю заначку, и восстановить, что было в индексе
	show -p id-заначки	--- напечатать diff заначки
	drop id-заначки	--- удалить заданную заначку из стека
	pop		--- применить и удалить заначку из вершины стека
	branch		--- создать новую ветку от того места, где произошло прятанье
git clean		--- очистить изменения
	-f		--- также неотслеживаемые файлы
	-d		--- удалить пустые директории
	-n		--- ничего не удалять а только показать, что было бы удалено
	-x		--- очистить также, что попадает под .gitignore
	-i		--- в интерактивном режиме
git commit
	-a		--- не парится по поводу git add
	-m message
	-v		--- если отсутствует -m, то в текстовом редакторе выведет git diff а не git status
	--amend		--- объединить текущий и предыдущий коммиты с сообщением последнего (если есть, иначе предыдущего)
		HEAD - указатель на текущую ветку, родитель следующего коммита
git revert ссылка	--- сделать коммит, который приводит текущее состояние в состояние, задаваемое ссылкой
git reflog		--- выдать последние значения HEAD
		ORIG_HEAD=HEAD@{1}
git restore
	<file>		--- восстанавливает файл в индексе и в рабочем каталоге
	--staged <file>	--- восстанавливает файл в индексе
git checkout
	коммит		--- установить рабочий каталог в соответствии с коммитом
				скорее всего получится detached HEAD
	-- <file>... (* не работает) --- установить файл на диске в соответствии с последним коммитом
	ветка		--- переключиться на соотв. ветку (не должно быть незакоммиченных файлов(?))
			(?)пытается выполнить в Рабочем Каталоге простые слияния так, чтобы все файлы, которые вы не изменяли, были обновлены
	-b ветка	--- создать ветку и сразу на нее переключиться (не должно быть незакоммиченных файлов(?))
	-b ветка коммит	--- создать ветку от коммита и сразу на нее переключиться
	--track исх_ветка	--- создать ветку от исх_ветки с таким же именем и сразу на нее переключиться
	--patch 	--- избирательно откатить изменения содержимого файла по частям
git reset
	HEAD --		--- убрать все файлы из индекса
	HEAD <file>...	--- убрать файл из проиндексированного
	опц. ссылка	--- перемещает HEAD и текущую ветку на заданную ссылку
	--soft		--- и всё, индекс и рабочий каталог останутся как есть 
		(если до этого индекс был пуст, то после этого он будет содержать предыдущее значение HEAD)
	--mixed		--- дополнительно устанавливает индекс на новый HEAD
	--hard		--- ещё дополнительно устанавливает рабочий каталог на новый HEAD
	[опц.=--mixed] [ссылка=HEAD] файл	--- пропускает перемещение HEAD и текущей ветки на заданную ссылку
			но устанавливает файл в индексе или еще и в рабочем каталоге в значение, которое указано в ссылке
	--patch 	--- избирательно откатить изменения содержимого файла по частям
git branch имя		--- ветка_имя := текущая_ветка - создание новой ветки, но не переключение на нее
	-d имя		--- удаление ветки (она должна присутствовать в git branch --merget)
	-D имя		--- удаление ветки в любом случае
	без аргументов	--- выведет список веток, * напротив HEAD
	-v		--- выведет список веток, * напротив HEAD, напротив каждой ветки последний коммит
	--merged	--- список веток, которые были слиты с текущей веткой
	--no-merged	---			не
	-r		--- remote branches
	-a		--- local and remote branches
git merge ветка	--- сливает текущую ветку с заданной (текущая+=заданная)
		fast forward - если ветки находятся на одной линии
		новый коммит слияния - в противном случае
		или оставит изменения незакомииченными, если возник конфликт, а в конфликтных файлах появятся соотв. пометки
git mergetool	--- ...
git rebase ветка	--- перемещение изменений между ветвлением и текущей веткой на указанную
		Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.
		? а что насчет конфликтов? ведь заданные изменения можно применить не к любому файлу

слияние репозиториев
https://ahitrin.github.io/work/2012/07/16/%D0%A1%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B5%D0%B2-%D0%B2-git/
распаковка одновременно двух веток
https://stackoverflow.com/questions/2048470/git-working-on-two-branches-simultaneously

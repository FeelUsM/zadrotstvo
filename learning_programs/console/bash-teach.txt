эпиграф - картинка: "мир металла прекрасен и удивителен"

Есть книжка advanced bash scripting guide (переведена).
Я не пытаюсь изложить весь материал по теме, я лишь пытаюсь его структурировать (на основе собственного опыта).
По каждой программе/команде можно найти отдельный подробный мануал (к тому же программы еще и обновляются).
Здесь дан обзор программ.
курс состоит из двух частей:
1) 6 способов взаимодействия между процессами 
1) разное для тех, кто будет запускать скрипты и программы
2) разное для тех, кто будет писать скрипты
2) и немного администрирования
// - язык си
>> - для тех, кто будет писать скрипты
... - самому надо изучать
На экзамен (можно придумать письменный тест):
на 3: знать 6 способов взаимодействия между процессами с точки зрения запускателя скриптов
+1 балл: знать 6 способов взаимодействия между процессами сточки зрения писателя скриптов и сточки зрения си
+1 балл: знать регулярные выражения

------------------------------------------
6 способов взаимодействия между процессами 
------------------------------------------
=== intro) встроенные и обычные команды ===
оболочка - интерпрпетатор, читает команды и выполняет их, обращаясь к ОС; оболочка операционной системы
bash sh tcsh zsh - прикаждом запуске все переменные инициализируются заново
.bashrc - если надо изменить инициализацию
help command vs command --help vs man command vs info command
alias - сокращения
пакет gnu coreutils
$PATH - где оно может быть
команда аргументы
./команда аргумент
bash команда аргументы
which - где эта программа
какому пакету принадлежит файл?...
uname - где вы (на какой машине)
date - когда вы (не путать с time)

=== 1) текущая директория ===
абсолютные и относительные пути
//fopen() и др //...
pwd - где я (в какой директории)
cd (pushdir popdir)
ls  --color=auto --group-directories-first --escape
touch (важен в make)
mkdir
rm
mv
cp
ln - offtop: симлинки, хардлинки

=== 2) аргументы ===
разделяются пробелами, кавычки, экранирование в кавычках, спец-символы
//main(argc, argv) //fork(); exec(); system()
>> $1...$N $# $@ $*
echo и (>> $() или `` )
соглашения о ключах, ключах с аргументами
часто используемые ключи: -h --help, -v --version, --verbose

=== 3) код возврата ===
//main(){return 0}
test [
true
false
&& ||
if
while
for
seq
set -e

=== 4) потоки ввода вывода ===
echo и (>> $() или `` )
0, 1, 2
//stdin, stdout, stderr //popen(); 
/dev/null
перенаправление: < файл, > файл, >> файл (порядок >/dev/null 2>&1)
пайпы |
именованные пайпы ...
конец файла ^D
конструкция "документ здесь"
cat, (offtop: less)
tee
nc (netcat), микрофон, динамики...

=== 5) переменные среды и просто переменные ===
синтаксис 
	переменная интерпретатора: var_без_пробела_= значение
	переменные среды для одной команды: (var_без_пробела_= значение)* команда аргументы
export
set
env
$RANDOM
//...

=== 6) сигналы  ===
как прерывания
//...
kill
9й сигнал, ^C
>> trap

-------------------------------------------------------
разное для тех, кто будет запускать скрипты и программы
-------------------------------------------------------
=== процессы ===
ps
top
htop
time
=== задачи ===
в баше программы можно сворачивать!
^Z
fg bg
jobs

=== работа по сети ===
nc (netcat) и протоколы IP, TCP, DNS
ssh
scp
rsync ...
screen
wget, (curl...)
openssl - самому изучить там всякие сертификаты...

=== редакторы и просмотрщики (консольные) ===
less, watch
vi, vim :q или :wq или :q!
emacs C-X C-C
nano F???
tar -zxf -czf

----------------------------------------
разное для тех, кто будет писать скрипты
----------------------------------------
=== #! ===
disclimer:
	оболочка служит скорее для запуска процессов и организации взаимодействия между ними, 
	чем для создания какой-то логики или реализации алгоритмов
	так происходит потому, что сама оболочка умеет мало, а на запуск процессов тратиться ощутимое количество ресурсов
	для организации логики лучше использовать python, perl, ruby; php, javascript(node-js); java, scala
	высокопроизводительные процессы лучше делать на c, c++
# - комментарий
#! - сигнатура, какой программой открывать этот файл
ключ остановки по ошибке
функции
case
read +для паролей...

=== работа с текстом ===
cat
head
tail
wc
printf
==== работа с таблицами ====
cut
paste
sort
awk
==== регулярные выражения ====
Диалог:
 - я умею читать чужие мысли
 - а я умею читать чужие регулярные выражения
 - ОК, ты победил
есть разные диалекты
grep
sed
${%/#} - встроенные #-удалить найденное начало, %-удалить найденный конец, /-найти подстроку и заменить
	#% - самое короткое, ##%% - самый длинный, /-одна замена, //-все заменить
==== кодировки ====
iconv
==== прочее ====
m4

=== цветной терминал ===
escape-последовательности
tput
настраиваем приглашение оболочки

---------------------------
и немного администрирования
---------------------------
find
du
работа с диском...

=== работаем с кодом ===
git, svn
make -j кол-во процессов
die gnu autotools (die - по немецки артикль мн.ч., а по английски - умрите!)
cmake, qmake...
gnu binutils
gcc, g++, gfortran, clang
gdb

=== пакеты, установка и удаление программ ===
... надо бы самому поизучать ...
apt-cyg...
структура файловой системы

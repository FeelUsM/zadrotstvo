Мини-учебник по bash/shell.
Для кого этот мини-учебник? Для всех кто только-что научился работать с файловой системой через командную строку.
О чем этот у мини-чебник? О том, как передаваить и получать информацию из запускаемых программ. 

Способы передачи информации в дочерние процессы и обратно:
* текущая директория
* аргументы
* переменные среды
* стандартные потоки 
* код возврата
* сигналы
Эта классификация справедлива при запуске любого процесса из любого процесса (не обязательно bash) FIXME, но в этом миниучебнике рассматривается синтаксис запуска процессов именно из bash/shell.
Возможно кагда-нибудь я опишу, как видны эти понятия изнутри bash-скриптов и си-программ.

=== текущая директория ===
Все относительные пути к файлам (например переданные через аргументы) будут вычисляться в абсолютные именно относительно нее.
Текущая директория дочернего процесса инициализируется текущей директорией запускающего процесса в момент запуска.
Впринципе ее можно отнести к переменным среды (PWD), но на практике она обрабатывается отдельно.

=== аргументы ===
Все аргументы имеют тип строка.
Синтаксис вызова команды прост:
> команда пробельные_символы последовательность_аргументов, разделенных пробельными_символами
А что делать, если мы хотим передать строку, содержащую пробелы, как один аргумент?
Для этого есть кавычки. Кавычки бывают двух типов: одинарные (сильные) и двойные (слабые).
Внутри одинарных кавычек все символы передаются как есть, без исключений. Т.е. экранировать НИЧЕГО нельзя (даже саму кавчку).
Внутри двойных кавычек раскрываются переменные, и выражения, связанные с символом '$', происходит замена тильды, а так же возможно экранирование как в си + символов #$~. ...
А еще такие строки (как в кавычках, так и без) можно конкатенировать, записав друг за другом без пробела.

Также, в качестве аргумента можно одной программе передать вывод другой программы (на стандартный поток вывода).
Для этого нужно на месте аргумента для первой программы в обратных кавычках `вызвать вторую программу`, или внутри конструкции $(вот так). Первый способ не позволяет провернуть то же самое с аргументами второй программы, а второй способ не работает со стандартизированным в POSIX sh.

Также мне кажется уместным в этом разделе упомянуть о команде echo(эхо), которая свои аргументы просто выводит на стандатный вывод, и о команде printf, которая аналогична echo, но работает как одноименная функция из си.

В качестве бонуса Ссылка на соглашение об аргументах.

=== переменные среды ===
Это ассоциативный массив имя(строка) -> значение(строка), который присутствует в каждом запущенном процессе, впрочем как и все понятия (6 штук), рассматриваемые этим топиком. Так же как и текущая директория, переменные среды дочернего процесса инициализируется переменными среды запускающего процесса в момент запуска.
В bash (и sh) также есть обычные переменные. Все переменные среды являются и обычными, но не наоборот FIXME.
Синтаксис объявления переменной:
> ИМЯбез_пробела= аргумент
Для создания в текущем сеансе или в скрипте переменной (обычной), нужно написать ее имя, а за тем обязательно без пробела исмвол '=', после которого идет значение.
///?возможно ли несколько присваиваний на одной строке?
А ткже, если перед именем команды на той же строке сделать несколько таких присваиваний, то эти переменные добавятся в переменными среды для этой команды, но в текущем сеансе/скрипте они не отразятся (ни как обычные переменные, ни как переменные среды///проверить)
Для использования переменной или переменной среды надо лишь перед ее именем написать символ $.
Чтобы превратить обычную переменную в переменную среды есть коменда export, а чтобы сделать наоборот - unexport.
Чтобы посмотреть все обычные переменные и переменные среды, есть команда set (у нее так же много других предназначений...).
Чтобы посмотреть все переменные среды, есть коменда env.

=== потоки ===
У каждой программы есть потоки ввода, вывода и ошибок, и по умолчанию они направлены из/на консоль.
За исключением тех программ, которые указаны как аргументы других команд - у них поток вывода (но не ошибок) становится аргументом соотв. команды.
И их можно перенаправить в файл/из файла.
синтаксис, последовательность
между программами
именованные каналы
cat, paste, tee
^D

!!! ссылка на tput и на википедию с кодами терминала

PIPESTATUS

UNIFDEF(1)                    Programmer's Manual                   UNIFDEF(1)

NAME
     unifdef, unifdefall -- удаляет условные операторы препроцессора в коде

SYNOPSIS
     unifdef [-bBcdehKkmnsStV] [-Ipath] [-[i]Dsym[=val]] [-[i]Usym] ...
             [-f defile] [-x {012}] [-M backext] [-o outfile] [infile ...]
     unifdefall [-Ipath] ... file

DESCRIPTION
	Утилита unifdef выборочно обрабатывает условные директивы cpp(1).
	Она удаляет из файла как директивы, так и любой дополнительный текст, который следует удалить по их указанию, 
	в противном случае оставив файл в покое.
	
     Утилита unifdef работает со строками #if, #ifdef, #ifndef, #elif, #else и #endif, используя макросы, указанные в параметрах командной строки -D и -U или в файлах определений -f.
     Директива обрабатывается, если спецификаций макроса достаточно, чтобы обеспечить определенное значение для своего управляющего выражения.
     Если результат ложен, директива и следующие строки под ее контролем удаляются.
     Если результат равен true, удаляется только директива.
     Директива #ifdef или #ifndef пропускается без изменений, если не указан ее управляющий макрос.
     Любое управляющее выражение #if или #elif, которое имеет неизвестное значение или которое unifdef не может проанализировать, передается без изменений.
     По умолчанию unifdef игнорирует строки #if и #elif с константными выражениями; его можно указать обработать, указав флаг -k в командной строке.

     Он понимает часто используемое подмножество синтаксиса выражений для строк #if и #elif: целочисленные константы, целочисленные значения макросов, определенных в командной строке, оператор defined(), операторы !, ~, - (унарный), * , /,%, +, -, <, <=,>,> =, ==,! =, &, ^, |, &&, || и выражения в скобках.
     Деление на ноль рассматривается как неизвестное значение. Для оператора && используется своего рода ``короткое замыкание'': если один из операндов определенно равен false, то результат ложен, даже если значение другого операнда неизвестно.
     Аналогично, если любой из операндов || безусловно, верен, тогда результат верен.

     При оценке выражения unifdef сначала не раскрывает макросы.
     Значение макроса должно быть простым числом, а не выражением.
     Допускается ограниченная форма косвенного обращения, где значением одного макроса является имя другого.

     В большинстве случаев unifdef не различает объектно-подобные макросы (без аргументов) и функционально-подобные макросы (с аргументами).
     Функциональный вызов макроса может появляться в управляющих выражениях #if и #elif.
     Если макрос не определен явно или определен с помощью флага -D в командной строке или с помощью #define в файле -f определений, его аргументы игнорируются.
     Если макрос явно не определен в командной строке с флагом -U или с #undef в файле -f определений, он может не иметь никаких аргументов, поскольку это приводит к синтаксической ошибке.	

     Утилита unifdef знает достаточно о C, чтобы знать, когда одна из директив неактивна, потому что она находится внутри комментария, или не может быть оценена, потому что она разделена строкой с обратной косой чертой.
     Он обнаруживает необычно отформатированные директивы препроцессора и пропускает их без изменений, когда компоновка слишком странна для обработки. (См. Раздел «ОШИБКИ» ниже.)

     Сценарий unifdefall может использоваться для удаления всех условных директив cpp(1) из файла.
     Он использует unifdef -s и cpp -dM для получения списков всех управляющих макросов и их определений (или их отсутствия), затем вызывает unifdef с соответствующими аргументами для обработки файла.

OPTIONS
     -Dsym=val
	Задает макрос с определенным значением
	
     -Dsym
	Задает макрос со значением 1
     
     -Usym
	Зачает, что макрос неопределен
	
     -iDsym[=val]
     -iUsym
	Си-строки, комментарии и продолжения строкигнорируются в блоках #ifdef и #ifndef, контролируемых макросом с этой опцией
	
     -f defile
	Файл defile содержит директивы препроцессора #define и #undef, которые имеют тот же эффект, что и соответствующие аргументы командной строки-D и-U.  Вы можете иметь несколько аргументов-f и смешивать их с аргументами-D и-U; более поздние параметры переопределяют более ранние.
	
	Каждая директива должна быть в одной строке.  Объектно-подобные определения макросов (без аргументов) устанавливаются в заданное значение.  Функциональные макроопределения (с аргументами) обрабатываются так, как если бы они были установлены в 1.
	
	Предупреждение: строковые литералы и символьные константы не анализируются правильно в файлах-f.
	
     -s
	Вместо препроцессинга входного файла как обчно, эта опция заставлет unifdef записать список макросов, которые используются директивами препроцессора, управляющими выражениями.
	
     -S
	Как опция -s, но еще печатается глубина вложенности каждого макроса.
	Это полезно для определения количества возможных комбинаций взаимозависимых определенных / неопределенных макросов.
	
     -t
	Выключает парсинг для си-строк, комментариев и продолжений строк, что является полезным для обычного текста.
	Это общая версия для флагов -iD и -iU
-----
     -d
	Включение отладочных сообщений

     -h
	print help

     -V
	Напечатать версию
-----
     -b
	Замените удаленные строки пустыми строками вместо их удаления.
        Взаимоисключающие с опцией-B.
	
     -B
	Сжатие пустых строк вокруг удаленного раздела.  Взаимоисключающие с опцией -b.
	
     -c
	Дополнение, т.е. строки, которые должны быть удалены, остаются и наоборот
	
     -e
	По умолчанию unifdef сообщит об ошибке, если ему нужно удалить директиву препроцессора, которая охватывает более одной строки, например, если у него есть многострочный комментарий, висящий на его правом конце.  Флаг-e заставляет его игнорировать строку вместо этого.
	
     -Ipath
	Задает для unifdefall дополнительное место поиска #include файлов.
	Эта опция игнорируется unifdef для совместимости с cpp(1) и для упрощения реализации inifdefall.
	
     -K
	Всегда обрабатывать результат операторов && и || как неопределенный, если хотябы один из операндов неопределен, 
	вместо short-circuiting-а, когда неопределенный операнд не влияет на результат. 
	Эта опция для совместимости с предыдущими версиями unifdef.
	
     -k
	Обрабатывать строки #if и #elif с контсантными выражениями.
	По умолчанию секции, управляемые такими строками, пропускаются без изменений, потому что обычно начинаются с ``#if 0'' и используются как комментарии, чтобы наметить будущее или прошлое развитие.
	Было бы грубо их удалять, также как удалять обычные комментарии.
-----
     -m
	Модифицировать один или более файлов на месте.
	Если исходный файл не модифицируется, оригинал сохраняется вместо перезаписи точно такой же копией.
	
     -M backext
	Модифицировать исходные файлы на месте и сохранить бэкап оригиналов добавляя backext к их именам.
	Если backext имеет нулевую длину, ведет себя как с опцией -m.
	
     -n
	Добавлять директивы #line в места удаленных строк, чтобы ошибки при компилировании выходного файла соответствовали строкам входного файла.
	
     -o outfile
	Записать результат в outfile, вместо stdout, при обработке одного файла.
	
     -x {012}
	Установить exit status в ноль, один или два. См раздел EXIT STATUS
	
     Утилита unifdef читает вход с stdin-а, если аргумент infile отсутствует.
     Вы должны использовать опции -m или -M, Если входных файлов несколько.
     Вы можете задать ввод с stdin или вывод в stdout при помощи '-'
     
     Утилита unifdef распознает опцию -Dsym of diff(1).
     
EXIT STATUS
     In normal usage the unifdef utility's exit status depends on the mode set
     using the -x option.

     If the exit mode is zero (the default) then unifdef exits with status 0
     if the output is an exact copy of the input, or with status 1 if the out-
     put differs.

     If the exit mode is one, unifdef exits with status 1 if the output is
     unmodified or 0 if it differs.

     If the exit mode is two, unifdef exits with status zero in both cases.

     In all exit modes, unifdef exits with status 2 if there is an error.

     The exit status is 0 if the -h or -V command line options are given.

DIAGNOSTICS
     EOF in comment

     Inappropriate #elif, #else or #endif

     Missing macro name in #define or #undef

     Obfuscated preprocessor control line

     Premature EOF (with the line number of the most recent unterminated #if)

     Too many levels of nesting

     Unrecognized preprocessor directive

     Unterminated char or string literal

SEE ALSO
     cpp(1), diff(1)

     The unifdef home page is http://dotat.at/prog/unifdef

HISTORY
     The unifdef command appeared in 2.9BSD.  ANSI C support was added in
     FreeBSD 4.7.

AUTHORS
     The original implementation was written by Dave Yost <Dave@Yost.com>.
     Tony Finch <dot@dotat.at> rewrote it to support ANSI C.

BUGS
     Expression evaluation is very limited.

     Character constants are not evaluated.  String literals and character
     constants in -f definition files are ignored rather than parsed as part
     of a macro's replacement tokens.

     Source files are processed one line at a time, so preprocessor directives
     split across more than one physical line (because of comments or back-
     slash-newline) cannot be handled in every situation.

     Trigraphs are not recognized.

     There is no support for macros with different definitions at different
     points in the source file.

     The text-mode and ignore functionality does not correspond to modern
     cpp(1) behaviour.

                               December 3, 2015
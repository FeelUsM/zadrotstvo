git config паременная значение
	--system	-> /etc/gitconfig
	--global	-> ~/.gitconfig
			-> ./.git/config
	--list	перечислить все измененные по умолчанию
		user.name
		user.email
		core.editor	или $EDITOR
		merge.tool	--- diff утилита
git help команда
------------------------------------------------------
git init
git clone url.git [folder]
		https://
		git:// --- только чтение (?)
		user@server:/ (ssh)
git remote --- перечисляет "имена" удаленных репозиториев
		origin - имя репозитория, 
	-v --- посмотреть url-ы для (fetch) и (push)
	add имя url --- добавить удаленный репозиторий
	show [удал. сервер]
	rename name-old name-new
	rm name
git fetch имя_репозитория --- получить всю инвормацию из этого репозитория, которой у меня нет
		после этого все удаленные ветки надо будет сливать со своими: git merge сервер/ветка
git pull = git fetch отслеживаемый_репозиторий + слияние с текущим
git push [удал. сервер=origin] [ветка=master] --- по умолчанию выкладывает только текущую ветку
	удал_сервер метка
	удал_сервер --tags --- выложить все метки
	сервер лок_ветка:уд_ветка --- взять локальную ветку, и скпировать ее в удаленную
		я так понял, на удаленном сервере допускается только fast forward merge
	сервер :уд_ветка --- удалить на сервере удаленную ветку
------------------------------------------------------
.gitignore
git status
		неотслеживаемые
		отслеживаемые измененные
		проиндексированные
	-s 	--- ???
git diff
	--word-diff 	--- diff по словам {+добавленное слово+} [-удаленное слово-]
	-U1 		--- 1 строка контекста
git apply		--- прочитать со стандартного входа diff и применить его
	-R		--- прочитать со стандартного входа diff и применить его в обратном порядке
git grep [опции] выражение [коммит]
	-n	--- вывести номера строк
	--count	--- вывести количество совпадений для каждого файла
	-p	--- вывести, из какой функции вызывалось
	--break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
git log			--- история коммитов
	-3 		--- 3 последних коммита
	--since ...
	--until ...
	--autor ...
	--committer
	--abbrev-commit	--- 
	--pretty=
		oneline		--- в одну строку
		format:"..."	
	--graph		--- добавить граф веток
	--relative-date	--- типа "2 weeks ago"
	--stat 		--- также выводить status
	--name-only	--- только имена измененных файлов
	--name-status	--- только имена измененных файлов и сколько добавлено/удалено внутри
	-p 		--- также выводить diff
	опции git diff
	-g 		--- в таком же формате как git reflog
	ветка_A..ветка_B	--- коммиты ветки_B с того момента как она (или от нее) отделилась от ветки_A
	origin/master..HEAD	--- те коммиты, которые будут отправлены на сервер
	origin/master..		--- те коммиты, которые будут отправлены на сервер
	refA refB ^refC		--- коммиты, достижымые из refA и refB но не достижимые из refC
	refA refB --not refC	--- коммиты, достижымые из refA и refB но не достижимые из refC
	master...experiment	--- коммиты, достижимые или из master или из experiment, но не из обоих сразу
	--left-right master...experiment	--- --..--, с указанием, какой коммит достижим из master, а какой из experiment
	-Sстрока	--- найти в истории и в соотв. diff-ах строку
	-Gпаттерн	--- найти в истории и в соотв. diff-ах паттерн
	-L :функция:файл	--- все изменения в заданной функции в заданном файле
	-L '/unsigned long git_deflate_bound/',/^}/:zlib.c	--- --..-- только функция задается рег.выр-ом
git tag --- тегами помечают коммиты
		обычные - только имя
		аннотированные - как коммит
	без аргументов 		--- печатает имена тегов
	-l 'шаблон' 		--- какие имена тегов печатать
	имя [коммит=последний]		 	--- создание легковесной
	-a имя -m сообщение [коммит=последний]	--- создание аннотированной
	-s имя -m сообщение [коммит=последний]	--- создание аннотированной и подписанной при помощи GPG (нужен закрытый ключ ц. подписи)
	-v имя			--- верификация ц. подписи GPG (желателен открытый ключ ц. подписи)
git show метка/ветка/коммит	--- посмотреть метку/ветку/коммит
	HEAD@{5}	--- посмотреть коммит, где был HEAD 5 операций над HEAD назад
	master@{yesterday}
	HEAD@{2.months.ago}
		метка/ветка/коммит - указатель
	указатель^	--- предок данного указателя
	указатель^2	--- 2й предок данного указателя, если данный указатель имеет 2 или более предков (например это был merge)
	указатель~	--- предок данного указателя
	указатель~3	--- предок в 3м поколении данного указателя
	указатель^^^	--- предок в 3м поколении данного указателя
	HEAD~3^2
------------------------------------------------------
git add файлы
	-i/--interactive	--- интерактивный режим добавления
	--patch 	--- избирательно откатить измения содержимого файла по частям
git rm [опции] файлы
	-f 		--- удалять из индекса
	--cached 	--- оставить на диске
git mv from to 		--- сам определяет, что переименовано
git stash 		--- спрятать текущие изменения в стек заначек
	save 		--- спрятать текущие изменения в стек заначек
	save --keep-index	--- спрятать то, что не добавлено в индекс
	-u/--include-untracked	--- спрятать также и неотслеживаемые файлы
	--all		--- спрятать всё
	--patch		--- в интерактивном режим спросит вас о том, какие из изменений вы хотите спрятать, а какие оставить
	list		--- показать стек заначек
	apply [id-заначки]	--- применить указанную или последнюю заначку
	apply [id-заначки] --index	--- применить указанную или последнюю заначку, и восстановить, что было в индексе
	show -p id-заначки	--- напечатать diff заначки
	drop id-заначки	--- удалить заданную заначку из стека
	pop		--- применить и удалить заначку из вершины стека
	branch		--- создать новую ветку от того места, где произошло прятанье
git clean		--- очистить изменения
	-f		--- также неотслеживаемые файлы
	-d		--- удалить пустые директории
	-n		--- ничего не удалять а только показать, что было бы удалено
	-x		--- очистить также, что попадает под .gitignore
	-i		--- в интерактивном режиме
git commit
	-a		--- не парится по поводу git add
	-m message
	-v		--- если отсутствует -m, то в текстовом редакторе выведет git diff а не git status
	--amend		--- объединить текущий и предыдущий коммиты с сообщением последнего (если есть, иначе предыдущего)
		HEAD - указатель на текущую ветку, родитель следующего коммита
git revert ссылка	--- сделать коммит, который приводит текущее состояние в состояние, задаваемое ссылкой
git reflog		--- выдать последние значения HEAD
		ORIG_HEAD=HEAD@{1}
git checkout
	-- <file>... (* не работает) --- установить файл на диске в соответствии с последним коммитом
	ветка		--- переключиться на соотв. ветку (не должно быть незакоммиченных файлов(?))
			(?)пытается выполнить в Рабочем Каталоге простые слияния так, чтобы все файлы, которые вы не изменяли, были обновлены
	-b ветка	--- создать ветку и сразу на нее переключиться (не должно быть незакоммиченных файлов(?))
	-b ветка исх_ветка	--- создать ветку от исх_ветки и сразу на нее переключиться
	--track исх_ветка	--- создать ветку от исх_ветки с таким же именем и сразу на нее переключиться
	--patch 	--- избирательно откатить измения содержимого файла по частям
git reset
	HEAD <file>...	--- убрать файл из проиндексированного
	опц. ссылка	--- перемещает HEAD и текущую ветку на заданную ссылку
	--soft		--- и всё, индекс и рабочий каталог остануться как есть 
		(если до этого индекс был пуст, топосле этого он будет содержать предыдущее значение HEAD)
	--mixed		--- дополнительно устанавливает индекс на новый HEAD
	--hard		--- ещё дополнительно устанавливает рабочий каталог на новый HEAD
	[опц.=--mixed] [ссылка=HEAD] файл	--- пропускает перемещение HEAD и текущей ветки на заданную ссылку
			но устанавливает файл в индексе или еще и в рабочем каталоге в значение, которое указано в ссылке
	--patch 	--- избирательно откатить измения содержимого файла по частям
git branch имя		--- ветка_имя := текущая_ветка - создание новой ветки, но не переключение на нее
	-d имя		--- удаление ветки (она должна присутствовать в git branch --merget)
	-D имя		--- удаление ветки в любом случае
	без аргументов	--- выведет список веток, * напротив HEAD
	-v		--- выведет список веток, * напротив HEAD, напротив каждой ветки последний коммит
	--merged	--- писок веток, которые были слиты с текущей веткой
	--no-merged	---			не
	-r		--- remote branches
	-a		--- local and remote branches
git merge ветка	--- сливает текущую ветку с заданной (текущая+=заданная)
		fast forward - если ветки находятся на одной линии
		новый коммит слияния - в противном случае
		или оставит изменения незакомииченными, если возник конфликт, а в конфликтных файлах появятся соотв. пометки
git mergetool	--- ...
git rebase ветка	--- перемещение изменений между ветвлением и текущей веткой на указанную
		Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.
		? а что насчет конфликтов? ведь заданные изменения можно применить не к любому файлу

слияние репозиториев
https://ahitrin.github.io/work/2012/07/16/%D0%A1%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B5%D0%B2-%D0%B2-git/
распаковка одновременно двух веток
https://stackoverflow.com/questions/2048470/git-working-on-two-branches-simultaneously
